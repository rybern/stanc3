  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp ad-level-failing.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace ad_level_failing_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'ad-level-failing.stan', line 45, column 2 to column 21)",
                                                      " (in 'ad-level-failing.stan', line 46, column 2 to column 22)",
                                                      " (in 'ad-level-failing.stan', line 47, column 2 to column 19)",
                                                      " (in 'ad-level-failing.stan', line 48, column 2 to column 22)",
                                                      " (in 'ad-level-failing.stan', line 52, column 2 to column 26)",
                                                      " (in 'ad-level-failing.stan', line 54, column 4 to column 52)",
                                                      " (in 'ad-level-failing.stan', line 53, column 2 to line 56, column 3)",
                                                      " (in 'ad-level-failing.stan', line 60, column 2 to column 24)",
                                                      " (in 'ad-level-failing.stan', line 61, column 2 to column 23)",
                                                      " (in 'ad-level-failing.stan', line 62, column 2 to column 21)",
                                                      " (in 'ad-level-failing.stan', line 63, column 2 to column 23)",
                                                      " (in 'ad-level-failing.stan', line 65, column 2 to column 41)",
                                                      " (in 'ad-level-failing.stan', line 67, column 4 to column 49)",
                                                      " (in 'ad-level-failing.stan', line 66, column 2 to line 67, column 49)",
                                                      " (in 'ad-level-failing.stan', line 69, column 2 to column 53)",
                                                      " (in 'ad-level-failing.stan', line 29, column 2 to column 19)",
                                                      " (in 'ad-level-failing.stan', line 30, column 2 to column 14)",
                                                      " (in 'ad-level-failing.stan', line 31, column 2 to column 13)",
                                                      " (in 'ad-level-failing.stan', line 32, column 2 to column 20)",
                                                      " (in 'ad-level-failing.stan', line 33, column 2 to column 18)",
                                                      " (in 'ad-level-failing.stan', line 37, column 2 to column 14)",
                                                      " (in 'ad-level-failing.stan', line 38, column 2 to column 32)",
                                                      " (in 'ad-level-failing.stan', line 40, column 2 to column 14)",
                                                      " (in 'ad-level-failing.stan', line 41, column 2 to column 13)",
                                                      " (in 'ad-level-failing.stan', line 17, column 4 to column 17)",
                                                      " (in 'ad-level-failing.stan', line 19, column 4 to column 59)",
                                                      " (in 'ad-level-failing.stan', line 21, column 4 to column 30)",
                                                      " (in 'ad-level-failing.stan', line 22, column 4 to column 48)",
                                                      " (in 'ad-level-failing.stan', line 24, column 4 to column 16)",
                                                      " (in 'ad-level-failing.stan', line 15, column 31 to line 25, column 3)"};


template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__,
T3__>::type>
simple_SIR(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__,
          T1__,
          T2__,
          T3__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    local_scalar_t__ lcm_sym4__;
    double lcm_sym3__;
    double lcm_sym2__;
    double lcm_sym1__;
    {
      current_statement__ = 25;
      validate_non_negative_index("dydt", "4", 4);
      std::vector<local_scalar_t__> dydt;
      dydt = std::vector<local_scalar_t__>(4, 0);
      
      current_statement__ = 26;
      assign(dydt, cons_list(index_uni(1), nil_index_list()),
        (((-theta[(1 - 1)] * y[(4 - 1)]) / (y[(4 - 1)] + theta[(2 - 1)])) *
          y[(1 - 1)]), "assigning variable dydt");
      lcm_sym4__ = (theta[(3 - 1)] * y[(2 - 1)]);
      assign(dydt, cons_list(index_uni(2), nil_index_list()),
        ((((theta[(1 - 1)] * y[(4 - 1)]) / (y[(4 - 1)] + theta[(2 - 1)])) *
           y[(1 - 1)]) - lcm_sym4__), "assigning variable dydt");
      current_statement__ = 27;
      assign(dydt, cons_list(index_uni(3), nil_index_list()), lcm_sym4__,
        "assigning variable dydt");
      current_statement__ = 28;
      assign(dydt, cons_list(index_uni(4), nil_index_list()),
        ((theta[(4 - 1)] * y[(2 - 1)]) - (theta[(5 - 1)] * y[(4 - 1)])),
        "assigning variable dydt");
      current_statement__ = 29;
      return dydt;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct simple_SIR_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__,
T3__>::type>
operator()(const T0__& t, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__)  const 
{
return simple_SIR(t, y, theta, x_r, x_i, pstream__);
}
};

class ad_level_failing_model : public model_base_crtp<ad_level_failing_model> {

 private:
  double lcm_sym30__;
  int pos__;
  int N_t;
  std::vector<double> t;
  std::vector<double> y0;
  std::vector<int> stoi_hat;
  std::vector<double> B_hat;
  double t0;
  double kappa;
  std::vector<double> x_r;
  std::vector<int> x_i;
 
 public:
  ~ad_level_failing_model() { }
  
  std::string model_name() const { return "ad_level_failing_model"; }
  
  ad_level_failing_model(stan::io::var_context& context__,
                         unsigned int random_seed__ = 0,
                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "ad_level_failing_model_namespace::ad_level_failing_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","N_t","int",
          context__.to_vec());
      
      current_statement__ = 16;
      N_t = context__.vals_i("N_t")[(1 - 1)];
      current_statement__ = 17;
      validate_non_negative_index("t", "N_t", N_t);
      context__.validate_dims("data initialization","t","double",
          context__.to_vec(N_t));
      t = std::vector<double>(N_t, 0);
      
      current_statement__ = 17;
      assign(t, nil_index_list(), context__.vals_r("t"),
        "assigning variable t");
      current_statement__ = 18;
      validate_non_negative_index("y0", "4", 4);
      context__.validate_dims("data initialization","y0","double",
          context__.to_vec(4));
      y0 = std::vector<double>(4, 0);
      
      current_statement__ = 18;
      assign(y0, nil_index_list(), context__.vals_r("y0"),
        "assigning variable y0");
      current_statement__ = 19;
      validate_non_negative_index("stoi_hat", "N_t", N_t);
      context__.validate_dims("data initialization","stoi_hat","int",
          context__.to_vec(N_t));
      stoi_hat = std::vector<int>(N_t, 0);
      
      current_statement__ = 19;
      assign(stoi_hat, nil_index_list(), context__.vals_i("stoi_hat"),
        "assigning variable stoi_hat");
      current_statement__ = 20;
      validate_non_negative_index("B_hat", "N_t", N_t);
      context__.validate_dims("data initialization","B_hat","double",
          context__.to_vec(N_t));
      B_hat = std::vector<double>(N_t, 0);
      
      current_statement__ = 20;
      assign(B_hat, nil_index_list(), context__.vals_r("B_hat"),
        "assigning variable B_hat");
      
      lcm_sym30__ = std::numeric_limits<double>::quiet_NaN();
      t0 = lcm_sym30__;
      current_statement__ = 21;
      t0 = 0;
      
      current_statement__ = 22;
      kappa = lcm_sym30__;
      current_statement__ = 22;
      kappa = 1000000;
      current_statement__ = 23;
      validate_non_negative_index("x_r", "0", 0);
      x_r = std::vector<double>(0, 0);
      
      current_statement__ = 24;
      validate_non_negative_index("x_i", "0", 0);
      x_i = std::vector<int>(0, 0);
      
      current_statement__ = 16;
      current_statement__ = 16;
      check_greater_or_equal(function__, "N_t", N_t, 0);
      current_statement__ = 22;
      current_statement__ = 22;
      check_greater_or_equal(function__, "kappa", 1000000, 0);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "ad_level_failing_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      local_scalar_t__ lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      std::vector<local_scalar_t__> lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      std::vector<std::vector<local_scalar_t__>> lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      int lcm_sym15__;
      int lcm_sym14__;
      local_scalar_t__ beta;
      
      current_statement__ = 1;
      beta = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        beta = stan::math::lb_constrain(beta, 0, lp__);
      } else {
        current_statement__ = 1;
        beta = stan::math::lb_constrain(beta, 0);
      }
      local_scalar_t__ gamma;
      
      current_statement__ = 2;
      gamma = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        gamma = stan::math::lb_constrain(gamma, 0, lp__);
      } else {
        current_statement__ = 2;
        gamma = stan::math::lb_constrain(gamma, 0);
      }
      local_scalar_t__ xi;
      
      current_statement__ = 3;
      xi = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        xi = stan::math::lb_constrain(xi, 0, lp__);
      } else {
        current_statement__ = 3;
        xi = stan::math::lb_constrain(xi, 0);
      }
      local_scalar_t__ delta;
      
      current_statement__ = 4;
      delta = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        delta = stan::math::lb_constrain(delta, 0, lp__);
      } else {
        current_statement__ = 4;
        delta = stan::math::lb_constrain(delta, 0);
      }
      current_statement__ = 5;
      validate_non_negative_index("y", "N_t", N_t);
      current_statement__ = 5;
      validate_non_negative_index("y", "4", 4);
      std::vector<std::vector<local_scalar_t__>> y;
      y = std::vector<std::vector<local_scalar_t__>>(N_t, std::vector<local_scalar_t__>(4, 0));
      
      {
        current_statement__ = 6;
        validate_non_negative_index("theta", "5", 5);
        std::vector<double> theta;
        theta = std::vector<double>(5, 0);
        
        assign(lcm_sym25__, nil_index_list(),
          stan::math::array_builder<local_scalar_t__>().add(beta)
          .add(1000000).add(gamma).add(xi).add(delta).array(),
          "assigning variable lcm_sym25__");
        assign(lcm_sym20__, nil_index_list(),
          integrate_ode_rk45(simple_SIR_functor__(), y0, 0, t, lcm_sym25__,
            x_r, x_i, pstream__), "assigning variable lcm_sym20__");
        assign(y, nil_index_list(), lcm_sym20__, "assigning variable y");
      }
      current_statement__ = 5;
      if (logical_gte(N_t, 1)) {
        {
          {
            {
              lcm_sym29__ = lcm_sym20__[(1 - 1)][(1 - 1)];
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     lcm_sym29__, 0);
              {
                current_statement__ = 5;
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       lcm_sym20__[(1 - 1)][(2 - 1)], 0);
              }
              {
                current_statement__ = 5;
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       lcm_sym20__[(1 - 1)][(3 - 1)], 0);
              }
              {
                current_statement__ = 5;
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       lcm_sym20__[(1 - 1)][(4 - 1)], 0);
              }
            }
          }
          for (size_t sym1__ = 2; sym1__ <= N_t; ++sym1__) {
            {
              current_statement__ = 5;
              current_statement__ = 5;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     lcm_sym20__[(sym1__ - 1)][(1 - 1)], 0);
              {
                current_statement__ = 5;
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       lcm_sym20__[(sym1__ - 1)][(2 - 1)], 0);
              }
              {
                current_statement__ = 5;
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       lcm_sym20__[(sym1__ - 1)][(3 - 1)], 0);
              }
              {
                current_statement__ = 5;
                current_statement__ = 5;
                check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                       lcm_sym20__[(sym1__ - 1)][(4 - 1)], 0);
              }
            }}
        }
      } else {
        lcm_sym29__ = lcm_sym20__[(1 - 1)][(1 - 1)];
      }
      {
        current_statement__ = 8;
        lp_accum__.add(cauchy_log<propto__>(beta, 0, 2.5));
        current_statement__ = 9;
        lp_accum__.add(cauchy_log<propto__>(gamma, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(cauchy_log<propto__>(xi, 0, 25));
        current_statement__ = 11;
        lp_accum__.add(cauchy_log<propto__>(delta, 0, 1));
        current_statement__ = 12;
        lp_accum__.add(
          poisson_log<propto__>(stoi_hat[(1 - 1)],
            (y0[(1 - 1)] - lcm_sym29__)));
        current_statement__ = 14;
        if (logical_gte(N_t, 2)) {
          current_statement__ = 13;
          lp_accum__.add(
            poisson_log<propto__>(stoi_hat[(2 - 1)],
              (lcm_sym29__ - lcm_sym20__[(2 - 1)][(1 - 1)])));
          for (size_t n = 3; n <= N_t; ++n) {
            current_statement__ = 13;
            lp_accum__.add(
              poisson_log<propto__>(stoi_hat[(n - 1)],
                (lcm_sym20__[((n - 1) - 1)][(1 - 1)] -
                  lcm_sym20__[(n - 1)][(1 - 1)])));}
        } 
        current_statement__ = 15;
        lp_accum__.add(
          lognormal_log<propto__>(B_hat,
            stan::math::log(col(to_matrix(lcm_sym20__), 4)), 0.15));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "ad_level_failing_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      std::vector<double> lcm_sym9__;
      std::vector<std::vector<double>> lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      double beta;
      
      current_statement__ = 1;
      beta = in__.scalar();
      current_statement__ = 1;
      beta = stan::math::lb_constrain(beta, 0);
      double gamma;
      
      current_statement__ = 2;
      gamma = in__.scalar();
      current_statement__ = 2;
      gamma = stan::math::lb_constrain(gamma, 0);
      double xi;
      
      current_statement__ = 3;
      xi = in__.scalar();
      current_statement__ = 3;
      xi = stan::math::lb_constrain(xi, 0);
      double delta;
      
      current_statement__ = 4;
      delta = in__.scalar();
      current_statement__ = 4;
      delta = stan::math::lb_constrain(delta, 0);
      current_statement__ = 5;
      validate_non_negative_index("y", "N_t", N_t);
      current_statement__ = 5;
      validate_non_negative_index("y", "4", 4);
      std::vector<std::vector<double>> y;
      y = std::vector<std::vector<double>>(N_t, std::vector<double>(4, 0));
      
      vars__.push_back(beta);
      vars__.push_back(gamma);
      vars__.push_back(xi);
      vars__.push_back(delta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      {
        current_statement__ = 6;
        validate_non_negative_index("theta", "5", 5);
        std::vector<double> theta;
        theta = std::vector<double>(5, 0);
        
        assign(lcm_sym9__, nil_index_list(),
          stan::math::array_builder<double>().add(beta).add(1000000)
          .add(gamma).add(xi).add(delta).array(),
          "assigning variable lcm_sym9__");
        assign(lcm_sym8__, nil_index_list(),
          integrate_ode_rk45(simple_SIR_functor__(), y0, 0, t, lcm_sym9__,
            x_r, x_i, pstream__), "assigning variable lcm_sym8__");
        assign(y, nil_index_list(), lcm_sym8__, "assigning variable y");
      }
      {
        lcm_sym5__ = logical_gte(N_t, 1);
        if (lcm_sym5__) {
          vars__.push_back(lcm_sym8__[(1 - 1)][(1 - 1)]);
          for (size_t sym2__ = 2; sym2__ <= N_t; ++sym2__) {
            vars__.push_back(lcm_sym8__[(sym2__ - 1)][(1 - 1)]);}
        } 
        {
          if (lcm_sym5__) {
            vars__.push_back(lcm_sym8__[(1 - 1)][(2 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= N_t; ++sym2__) {
              vars__.push_back(lcm_sym8__[(sym2__ - 1)][(2 - 1)]);}
          } 
        }
        {
          if (lcm_sym5__) {
            vars__.push_back(lcm_sym8__[(1 - 1)][(3 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= N_t; ++sym2__) {
              vars__.push_back(lcm_sym8__[(sym2__ - 1)][(3 - 1)]);}
          } 
        }
        {
          if (lcm_sym5__) {
            vars__.push_back(lcm_sym8__[(1 - 1)][(4 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= N_t; ++sym2__) {
              vars__.push_back(lcm_sym8__[(sym2__ - 1)][(4 - 1)]);}
          } 
        }
      }
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      
      pos__ = 1;
      double beta;
      
      current_statement__ = 1;
      beta = context__.vals_r("beta")[(1 - 1)];
      current_statement__ = 1;
      beta = stan::math::lb_free(beta, 0);
      double gamma;
      
      current_statement__ = 2;
      gamma = context__.vals_r("gamma")[(1 - 1)];
      current_statement__ = 2;
      gamma = stan::math::lb_free(gamma, 0);
      double xi;
      
      current_statement__ = 3;
      xi = context__.vals_r("xi")[(1 - 1)];
      current_statement__ = 3;
      xi = stan::math::lb_free(xi, 0);
      double delta;
      
      current_statement__ = 4;
      delta = context__.vals_r("delta")[(1 - 1)];
      current_statement__ = 4;
      delta = stan::math::lb_free(delta, 0);
      vars__.push_back(beta);
      vars__.push_back(gamma);
      vars__.push_back(xi);
      vars__.push_back(delta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("beta");
    names__.push_back("gamma");
    names__.push_back("xi");
    names__.push_back("delta");
    names__.push_back("y");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N_t);
    
    dims__.push_back(4);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "beta");
    param_names__.push_back(std::string() + "gamma");
    param_names__.push_back(std::string() + "xi");
    param_names__.push_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (size_t sym31__ = 1; sym31__ <= 4; ++sym31__) {
        {
          for (size_t sym32__ = 1; sym32__ <= N_t; ++sym32__) {
            {
              param_names__.push_back(std::string() + "y" + '.' + std::to_string(sym32__) + '.' + std::to_string(sym31__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "beta");
    param_names__.push_back(std::string() + "gamma");
    param_names__.push_back(std::string() + "xi");
    param_names__.push_back(std::string() + "delta");
    if (emit_transformed_parameters__) {
      for (size_t sym31__ = 1; sym31__ <= 4; ++sym31__) {
        {
          for (size_t sym32__ = 1; sym32__ <= N_t; ++sym32__) {
            {
              param_names__.push_back(std::string() + "y" + '.' + std::to_string(sym32__) + '.' + std::to_string(sym31__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" << N_t << ",\"element_type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"xi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" << N_t << ",\"element_type\":{\"name\":\"array\",\"length\":" << 4 << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef ad_level_failing_model_namespace::ad_level_failing_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp copy_fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace copy_fail_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'copy_fail.stan', line 71, column 2 to column 31)",
                                                      " (in 'copy_fail.stan', line 72, column 2 to column 40)",
                                                      " (in 'copy_fail.stan', line 76, column 2 to column 51)",
                                                      " (in 'copy_fail.stan', line 77, column 2 to column 49)",
                                                      " (in 'copy_fail.stan', line 78, column 2 to column 49)",
                                                      " (in 'copy_fail.stan', line 83, column 6 to column 20)",
                                                      " (in 'copy_fail.stan', line 84, column 6 to column 18)",
                                                      " (in 'copy_fail.stan', line 82, column 32 to line 85, column 5)",
                                                      " (in 'copy_fail.stan', line 87, column 6 to column 32)",
                                                      " (in 'copy_fail.stan', line 88, column 6 to column 23)",
                                                      " (in 'copy_fail.stan', line 86, column 38 to line 89, column 5)",
                                                      " (in 'copy_fail.stan', line 86, column 4 to line 89, column 5)",
                                                      " (in 'copy_fail.stan', line 81, column 20 to line 90, column 3)",
                                                      " (in 'copy_fail.stan', line 81, column 2 to line 90, column 3)",
                                                      " (in 'copy_fail.stan', line 26, column 4 to column 34)",
                                                      " (in 'copy_fail.stan', line 29, column 6 to column 32)",
                                                      " (in 'copy_fail.stan', line 32, column 8 to column 37)",
                                                      " (in 'copy_fail.stan', line 33, column 8 to column 32)",
                                                      " (in 'copy_fail.stan', line 41, column 8 to line 42, column 83)",
                                                      " (in 'copy_fail.stan', line 30, column 37 to line 43, column 7)",
                                                      " (in 'copy_fail.stan', line 28, column 22 to line 44, column 5)",
                                                      " (in 'copy_fail.stan', line 25, column 47 to line 46, column 3)",
                                                      " (in 'copy_fail.stan', line 105, column 8 to column 37)",
                                                      " (in 'copy_fail.stan', line 106, column 8 to column 41)",
                                                      " (in 'copy_fail.stan', line 104, column 40 to line 107, column 7)",
                                                      " (in 'copy_fail.stan', line 108, column 6 to column 37)",
                                                      " (in 'copy_fail.stan', line 103, column 22 to line 109, column 5)",
                                                      " (in 'copy_fail.stan', line 102, column 20 to line 110, column 3)",
                                                      " (in 'copy_fail.stan', line 102, column 2 to line 110, column 3)",
                                                      " (in 'copy_fail.stan', line 50, column 2 to column 20)",
                                                      " (in 'copy_fail.stan', line 51, column 2 to column 27)",
                                                      " (in 'copy_fail.stan', line 52, column 2 to column 44)",
                                                      " (in 'copy_fail.stan', line 53, column 2 to column 23)",
                                                      " (in 'copy_fail.stan', line 54, column 2 to column 54)",
                                                      " (in 'copy_fail.stan', line 58, column 2 to column 38)",
                                                      " (in 'copy_fail.stan', line 60, column 2 to column 45)",
                                                      " (in 'copy_fail.stan', line 61, column 2 to column 44)",
                                                      " (in 'copy_fail.stan', line 8, column 8 to column 17)",
                                                      " (in 'copy_fail.stan', line 7, column 6 to line 8, column 17)",
                                                      " (in 'copy_fail.stan', line 5, column 31 to line 10, column 3)",
                                                      " (in 'copy_fail.stan', line 65, column 4 to column 35)",
                                                      " (in 'copy_fail.stan', line 64, column 2 to line 65, column 35)",
                                                      " (in 'copy_fail.stan', line 15, column 6 to column 32)",
                                                      " (in 'copy_fail.stan', line 19, column 8 to column 17)",
                                                      " (in 'copy_fail.stan', line 18, column 6 to line 19, column 17)",
                                                      " (in 'copy_fail.stan', line 13, column 37 to line 20, column 5)",
                                                      " (in 'copy_fail.stan', line 12, column 30 to line 22, column 3)",
                                                      " (in 'copy_fail.stan', line 67, column 4 to column 33)",
                                                      " (in 'copy_fail.stan', line 66, column 2 to line 67, column 33)",
                                                      " (in 'copy_fail.stan', line 9, column 4 to column 13)",
                                                      " (in 'copy_fail.stan', line 21, column 4 to column 13)",
                                                      " (in 'copy_fail.stan', line 30, column 6 to line 43, column 7)",
                                                      " (in 'copy_fail.stan', line 28, column 4 to line 44, column 5)",
                                                      " (in 'copy_fail.stan', line 45, column 4 to column 15)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym33__;
    int lcm_sym32__;
    int lcm_sym31__;
    int lcm_sym30__;
    {
      lcm_sym31__ = size(y_i);
      if (logical_gte(lcm_sym31__, 1)) {
        current_statement__ = 39;
        if (y_i[(1 - 1)]) {
          current_statement__ = 38;
          return 1;
        } 
        for (size_t k = 2; k <= lcm_sym31__; ++k) {
          current_statement__ = 39;
          if (y_i[(k - 1)]) {
            current_statement__ = 38;
            return k;
          } }
      } 
      current_statement__ = 50;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym39__;
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    int lcm_sym35__;
    int lcm_sym34__;
    {
      lcm_sym37__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym37__, 0)) {
        int k;
        
        lcm_sym36__ = (size(y_i) - 0);
        current_statement__ = 45;
        if (y_i[(lcm_sym36__ - 1)]) {
          current_statement__ = 44;
          return lcm_sym36__;
        } 
        for (size_t k_rev = 1; k_rev <= lcm_sym37__; ++k_rev) {
          int k;
          
          lcm_sym35__ = (size(y_i) - k_rev);
          current_statement__ = 45;
          if (y_i[(lcm_sym35__ - 1)]) {
            current_statement__ = 44;
            return lcm_sym35__;
          } }
      } 
      current_statement__ = 51;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__,
T3__>::type, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions,
                const Eigen::Matrix<T2__, -1, -1>& p,
                const Eigen::Matrix<T3__, -1, -1>& phi,
                std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T2__,
          T3__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    double lcm_sym51__;
    double lcm_sym50__;
    double lcm_sym49__;
    double lcm_sym48__;
    double lcm_sym47__;
    int lcm_sym46__;
    int lcm_sym45__;
    int lcm_sym44__;
    int lcm_sym43__;
    int lcm_sym42__;
    int lcm_sym41__;
    int lcm_sym40__;
    {
      current_statement__ = 15;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      lcm_sym41__ = logical_gte(nind, 1);
      if (lcm_sym41__) {
        lcm_sym40__ = logical_gte(n_occasions, 1);
        if (lcm_sym40__) {
          lcm_sym51__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym51__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 15;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym51__,
              "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 15;
          if (lcm_sym40__) {
            lcm_sym51__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym51__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 15;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym51__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 53;
      if (lcm_sym41__) {
        current_statement__ = 16;
        assign(chi,
          cons_list(index_uni(1),
            cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
          "assigning variable chi");
        lcm_sym44__ = (n_occasions - 1);
        lcm_sym42__ = logical_gte(lcm_sym44__, 1);
        if (lcm_sym42__) {
          int t_curr;
          
          int t_next;
          
          lcm_sym46__ = (lcm_sym44__ + 1);
          current_statement__ = 19;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym44__), nil_index_list())),
            stan::math::fma(
              (rvalue(phi,
                 cons_list(index_uni(1),
                   cons_list(index_uni(lcm_sym44__), nil_index_list())),
                 "phi") *
                (1 -
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym46__ - 1)),
                        nil_index_list())), "p"))),
              rvalue(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(lcm_sym46__), nil_index_list())),
                "chi"),
              (1 -
                rvalue(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym44__), nil_index_list())),
                  "phi"))), "assigning variable chi");
          for (size_t t = 2; t <= lcm_sym44__; ++t) {
            int t_curr;
            
            lcm_sym43__ = (n_occasions - t);
            int t_next;
            
            lcm_sym45__ = (lcm_sym43__ + 1);
            current_statement__ = 19;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(lcm_sym43__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(1),
                     cons_list(index_uni(lcm_sym43__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((lcm_sym45__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(chi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym45__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym43__), nil_index_list())),
                    "phi"))), "assigning variable chi");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          current_statement__ = 16;
          assign(chi,
            cons_list(index_uni(i),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable chi");
          current_statement__ = 52;
          if (lcm_sym42__) {
            int t_curr;
            
            int t_next;
            
            lcm_sym46__ = (lcm_sym44__ + 1);
            current_statement__ = 19;
            assign(chi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym44__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(i),
                     cons_list(index_uni(lcm_sym44__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym46__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(lcm_sym46__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym44__), nil_index_list())),
                    "phi"))), "assigning variable chi");
            for (size_t t = 2; t <= lcm_sym44__; ++t) {
              int t_curr;
              
              lcm_sym43__ = (n_occasions - t);
              int t_next;
              
              lcm_sym45__ = (lcm_sym43__ + 1);
              current_statement__ = 19;
              assign(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(lcm_sym43__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_uni(lcm_sym43__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni((lcm_sym45__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(chi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym45__), nil_index_list())),
                    "chi"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym43__), nil_index_list())),
                      "phi"))), "assigning variable chi");}
          } }
      } 
      current_statement__ = 54;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__,
T3__>::type, -1, -1>
operator()(const int& nind, const int& n_occasions,
           const Eigen::Matrix<T2__, -1, -1>& p,
           const Eigen::Matrix<T3__, -1, -1>& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

class copy_fail_model : public model_base_crtp<copy_fail_model> {

 private:
  int lcm_sym180__;
  int lcm_sym179__;
  int lcm_sym178__;
  int lcm_sym177__;
  int lcm_sym176__;
  int lcm_sym175__;
  int lcm_sym174__;
  int lcm_sym173__;
  int lcm_sym172__;
  int lcm_sym171__;
  int lcm_sym170__;
  int lcm_sym169__;
  int lcm_sym168__;
  int lcm_sym167__;
  int lcm_sym166__;
  int lcm_sym165__;
  int lcm_sym164__;
  int lcm_sym163__;
  int lcm_sym162__;
  int lcm_sym161__;
  int lcm_sym160__;
  int lcm_sym159__;
  int lcm_sym158__;
  int lcm_sym157__;
  int lcm_sym156__;
  int lcm_sym155__;
  int lcm_sym154__;
  int lcm_sym153__;
  int lcm_sym152__;
  int lcm_sym151__;
  int lcm_sym150__;
  int pos__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~copy_fail_model() { }
  
  std::string model_name() const { return "copy_fail_model"; }
  
  copy_fail_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "copy_fail_model_namespace::copy_fail_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","nind","int",
          context__.to_vec());
      
      current_statement__ = 30;
      nind = context__.vals_i("nind")[(1 - 1)];
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      
      current_statement__ = 31;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 32;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 32;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(nind, n_occasions));
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, 0));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 32;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 32;
        pos__ = 1;
        lcm_sym150__ = logical_gte(n_occasions, 1);
        if (lcm_sym150__) {
          {
            lcm_sym151__ = logical_gte(nind, 1);
            if (lcm_sym151__) {
              current_statement__ = 32;
              assign(y,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())),
                y_flat__[(1 - 1)], "assigning variable y");
              current_statement__ = 32;
              pos__ = 2;
              for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 32;
                assign(y,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(1), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 32;
                pos__ = (pos__ + 1);}
            } 
            for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 32;
              if (lcm_sym151__) {
                current_statement__ = 32;
                assign(y,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 32;
                pos__ = (pos__ + 1);
                for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                  current_statement__ = 32;
                  assign(y,
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list())),
                    y_flat__[(pos__ - 1)], "assigning variable y");
                  current_statement__ = 32;
                  pos__ = (pos__ + 1);}
              } }
          }
        } else {
          lcm_sym151__ = logical_gte(nind, 1);
        }
      }
      context__.validate_dims("data initialization","max_age","int",
          context__.to_vec());
      
      current_statement__ = 33;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 34;
      validate_non_negative_index("x", "nind", nind);
      lcm_sym153__ = (n_occasions - 1);
      validate_non_negative_index("x", "(n_occasions - 1)", lcm_sym153__);
      context__.validate_dims("data initialization","x","int",
          context__.to_vec(nind, lcm_sym153__));
      x = std::vector<std::vector<int>>(nind, std::vector<int>(lcm_sym153__, 0));
      
      {
        std::vector<int> x_flat__;
        current_statement__ = 34;
        assign(x_flat__, nil_index_list(), context__.vals_i("x"),
          "assigning variable x_flat__");
        current_statement__ = 34;
        pos__ = 1;
        lcm_sym152__ = logical_gte(lcm_sym153__, 1);
        if (lcm_sym152__) {
          current_statement__ = 34;
          if (lcm_sym151__) {
            current_statement__ = 34;
            assign(x,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              x_flat__[(1 - 1)], "assigning variable x");
            current_statement__ = 34;
            pos__ = 2;
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              current_statement__ = 34;
              assign(x,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                x_flat__[(pos__ - 1)], "assigning variable x");
              current_statement__ = 34;
              pos__ = (pos__ + 1);}
          } 
          for (size_t sym1__ = 2; sym1__ <= lcm_sym153__; ++sym1__) {
            current_statement__ = 34;
            if (lcm_sym151__) {
              current_statement__ = 34;
              assign(x,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                x_flat__[(pos__ - 1)], "assigning variable x");
              current_statement__ = 34;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 34;
                assign(x,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  x_flat__[(pos__ - 1)], "assigning variable x");
                current_statement__ = 34;
                pos__ = (pos__ + 1);}
            } }
        } 
      }
      
      current_statement__ = 35;
      n_occ_minus_1 = lcm_sym153__;
      current_statement__ = 36;
      validate_non_negative_index("first", "nind", nind);
      first = std::vector<int>(nind, 0);
      
      current_statement__ = 37;
      validate_non_negative_index("last", "nind", nind);
      last = std::vector<int>(nind, 0);
      
      current_statement__ = 42;
      if (lcm_sym151__) {
        int inline_sym21__;
        int inline_sym23__;
        
        inline_sym23__ = 0;
        for (size_t inline_sym24__ = 1; inline_sym24__ <= 1; ++inline_sym24__) {
          lcm_sym160__ = size(y[(1 - 1)]);
          for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym160__;
               ++inline_sym22__) {
            current_statement__ = 39;
            if (y[(1 - 1)][(inline_sym22__ - 1)]) {
              inline_sym23__ = 1;
              inline_sym21__ = inline_sym22__;
              break;
            } }
          if (inline_sym23__) {
            break;
          } 
          inline_sym23__ = 1;
          inline_sym21__ = 0;
          break;}
        assign(first, cons_list(index_uni(1), nil_index_list()),
          inline_sym21__, "assigning variable first");
        for (size_t i = 2; i <= nind; ++i) {
          int inline_sym21__;
          int inline_sym23__;
          
          inline_sym23__ = 0;
          for (size_t inline_sym24__ = 1; inline_sym24__ <= 1;
               ++inline_sym24__) {
            lcm_sym159__ = size(y[(i - 1)]);
            for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym159__;
                 ++inline_sym22__) {
              current_statement__ = 39;
              if (y[(i - 1)][(inline_sym22__ - 1)]) {
                inline_sym23__ = 1;
                inline_sym21__ = inline_sym22__;
                break;
              } }
            if (inline_sym23__) {
              break;
            } 
            inline_sym23__ = 1;
            inline_sym21__ = 0;
            break;}
          assign(first, cons_list(index_uni(i), nil_index_list()),
            inline_sym21__, "assigning variable first");}
      } 
      current_statement__ = 49;
      if (lcm_sym151__) {
        int inline_sym25__;
        int inline_sym28__;
        
        inline_sym28__ = 0;
        for (size_t inline_sym29__ = 1; inline_sym29__ <= 1; ++inline_sym29__) {
          lcm_sym160__ = size(y[(1 - 1)]);
          lcm_sym157__ = (lcm_sym160__ - 1);
          for (size_t inline_sym27__ = 0; inline_sym27__ <= lcm_sym157__;
               ++inline_sym27__) {
            int inline_sym26__;
            
            lcm_sym156__ = (lcm_sym160__ - inline_sym27__);
            inline_sym26__ = lcm_sym156__;
            current_statement__ = 45;
            if (y[(1 - 1)][(lcm_sym156__ - 1)]) {
              inline_sym28__ = 1;
              inline_sym25__ = lcm_sym156__;
              break;
            } }
          if (inline_sym28__) {
            break;
          } 
          inline_sym28__ = 1;
          inline_sym25__ = 0;
          break;}
        assign(last, cons_list(index_uni(1), nil_index_list()),
          inline_sym25__, "assigning variable last");
        for (size_t i = 2; i <= nind; ++i) {
          int inline_sym25__;
          int inline_sym28__;
          
          inline_sym28__ = 0;
          for (size_t inline_sym29__ = 1; inline_sym29__ <= 1;
               ++inline_sym29__) {
            lcm_sym159__ = size(y[(i - 1)]);
            lcm_sym155__ = (lcm_sym159__ - 1);
            for (size_t inline_sym27__ = 0; inline_sym27__ <= lcm_sym155__;
                 ++inline_sym27__) {
              int inline_sym26__;
              
              lcm_sym154__ = (lcm_sym159__ - inline_sym27__);
              inline_sym26__ = lcm_sym154__;
              current_statement__ = 45;
              if (y[(i - 1)][(lcm_sym154__ - 1)]) {
                inline_sym28__ = 1;
                inline_sym25__ = lcm_sym154__;
                break;
              } }
            if (inline_sym28__) {
              break;
            } 
            inline_sym28__ = 1;
            inline_sym25__ = 0;
            break;}
          assign(last, cons_list(index_uni(i), nil_index_list()),
            inline_sym25__, "assigning variable last");}
      } 
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 31;
      current_statement__ = 31;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 32;
      if (lcm_sym151__) {
        current_statement__ = 32;
        if (lcm_sym150__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 32;
          if (lcm_sym150__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 32;
              current_statement__ = 32;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 32;
      if (lcm_sym151__) {
        current_statement__ = 32;
        if (lcm_sym150__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 32;
          if (lcm_sym150__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 32;
              current_statement__ = 32;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      current_statement__ = 33;
      current_statement__ = 33;
      check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 34;
      if (lcm_sym151__) {
        current_statement__ = 34;
        if (lcm_sym152__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                 x[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
            current_statement__ = 34;
            current_statement__ = 34;
            check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                   x[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 34;
          if (lcm_sym152__) {
            current_statement__ = 34;
            current_statement__ = 34;
            check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                   x[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
              current_statement__ = 34;
              current_statement__ = 34;
              check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                     x[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 34;
      if (lcm_sym151__) {
        current_statement__ = 34;
        if (lcm_sym152__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_less_or_equal(function__, "x[sym1__, sym2__]",
                              x[(1 - 1)][(1 - 1)], max_age);
          for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
            current_statement__ = 34;
            current_statement__ = 34;
            check_less_or_equal(function__, "x[sym1__, sym2__]",
                                x[(1 - 1)][(sym2__ - 1)], max_age);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 34;
          if (lcm_sym152__) {
            current_statement__ = 34;
            current_statement__ = 34;
            check_less_or_equal(function__, "x[sym1__, sym2__]",
                                x[(sym1__ - 1)][(1 - 1)], max_age);
            for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
              current_statement__ = 34;
              current_statement__ = 34;
              check_less_or_equal(function__, "x[sym1__, sym2__]",
                                  x[(sym1__ - 1)][(sym2__ - 1)], max_age);}
          } }
      } 
      current_statement__ = 36;
      if (lcm_sym151__) {
        current_statement__ = 36;
        current_statement__ = 36;
        check_greater_or_equal(function__, "first[sym1__]", first[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 36;
          current_statement__ = 36;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 36;
      if (lcm_sym151__) {
        current_statement__ = 36;
        current_statement__ = 36;
        check_less_or_equal(function__, "first[sym1__]", first[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 36;
          current_statement__ = 36;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);}
      } 
      current_statement__ = 37;
      if (lcm_sym151__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_greater_or_equal(function__, "last[sym1__]", last[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 37;
          current_statement__ = 37;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 37;
      if (lcm_sym151__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_less_or_equal(function__, "last[sym1__]", last[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 37;
          current_statement__ = 37;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      current_statement__ = 2;
      validate_non_negative_index("beta", "max_age", max_age);
      num_params_r__ += max_age;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "copy_fail_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      int lcm_sym149__;
      int lcm_sym148__;
      int lcm_sym147__;
      int lcm_sym146__;
      double lcm_sym145__;
      double lcm_sym144__;
      double lcm_sym143__;
      double lcm_sym142__;
      double lcm_sym140__;
      double lcm_sym138__;
      double lcm_sym141__;
      double lcm_sym136__;
      double lcm_sym135__;
      double lcm_sym134__;
      double lcm_sym133__;
      double lcm_sym132__;
      double lcm_sym131__;
      double lcm_sym130__;
      double lcm_sym129__;
      double lcm_sym128__;
      double lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      int lcm_sym124__;
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      int lcm_sym120__;
      int lcm_sym119__;
      int lcm_sym118__;
      int lcm_sym117__;
      int lcm_sym116__;
      int lcm_sym115__;
      int lcm_sym114__;
      int lcm_sym113__;
      int lcm_sym112__;
      int lcm_sym111__;
      int lcm_sym110__;
      int lcm_sym109__;
      int lcm_sym108__;
      int lcm_sym107__;
      int lcm_sym106__;
      int lcm_sym105__;
      int lcm_sym104__;
      int lcm_sym103__;
      local_scalar_t__ mean_p;
      
      current_statement__ = 1;
      mean_p = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      current_statement__ = 2;
      validate_non_negative_index("beta", "max_age", max_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(max_age);
      
      current_statement__ = 2;
      beta = in__.vector(max_age);
      current_statement__ = 2;
      if (logical_gte(max_age, 1)) {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            stan::math::lub_constrain(beta[(1 - 1)], 0, 1, lp__),
            "assigning variable beta");
        } else {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            stan::math::lub_constrain(beta[(1 - 1)], 0, 1),
            "assigning variable beta");
        }
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          current_statement__ = 2;
          if (jacobian__) {
            current_statement__ = 2;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1, lp__),
              "assigning variable beta");
          } else {
            current_statement__ = 2;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1),
              "assigning variable beta");
          }}
      } 
      current_statement__ = 3;
      validate_non_negative_index("phi", "nind", nind);
      lcm_sym116__ = (n_occasions - 1);
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym116__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym116__);
      
      lcm_sym105__ = logical_gte(nind, 1);
      if (lcm_sym105__) {
        lcm_sym106__ = logical_gte(lcm_sym116__, 1);
        if (lcm_sym106__) {
          lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
            "assigning variable phi");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym116__; ++sym2__) {
            current_statement__ = 3;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym141__, "assigning variable phi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym106__) {
            lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
            assign(phi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
              "assigning variable phi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym116__; ++sym2__) {
              current_statement__ = 3;
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym141__, "assigning variable phi");}
          } }
      } 
      current_statement__ = 4;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 4;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym116__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym116__);
      
      current_statement__ = 4;
      if (lcm_sym105__) {
        lcm_sym106__ = logical_gte(lcm_sym116__, 1);
        if (lcm_sym106__) {
          lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym116__; ++sym2__) {
            current_statement__ = 4;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym141__, "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym106__) {
            lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym116__; ++sym2__) {
              current_statement__ = 4;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym141__, "assigning variable p");}
          } }
      } 
      current_statement__ = 5;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 5;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      current_statement__ = 5;
      if (lcm_sym105__) {
        lcm_sym104__ = logical_gte(n_occasions, 1);
        if (lcm_sym104__) {
          lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym141__, "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym104__) {
            lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym141__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 14;
      if (lcm_sym105__) {
        lcm_sym147__ = first[(1 - 1)];
        lcm_sym118__ = (lcm_sym147__ - 1);
        if (logical_gte(lcm_sym118__, 1)) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable p");
          for (size_t t = 2; t <= lcm_sym118__; ++t) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable p");}
        } 
        current_statement__ = 12;
        if (logical_gte(lcm_sym116__, lcm_sym147__)) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym147__), nil_index_list())),
            beta[(x[(1 - 1)][(lcm_sym147__ - 1)] - 1)],
            "assigning variable phi");
          lcm_sym124__ = (lcm_sym147__ + 1);
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym147__), nil_index_list())), mean_p,
            "assigning variable p");
          for (size_t t = lcm_sym124__; t <= lcm_sym116__; ++t) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())),
              beta[(x[(1 - 1)][(t - 1)] - 1)], "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_p,
              "assigning variable p");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          lcm_sym146__ = first[(i - 1)];
          lcm_sym117__ = (lcm_sym146__ - 1);
          if (logical_gte(lcm_sym117__, 1)) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable p");
            for (size_t t = 2; t <= lcm_sym117__; ++t) {
              current_statement__ = 6;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable phi");
              current_statement__ = 7;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable p");}
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym116__, lcm_sym146__)) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym146__), nil_index_list())),
              beta[(x[(i - 1)][(lcm_sym146__ - 1)] - 1)],
              "assigning variable phi");
            lcm_sym123__ = (lcm_sym146__ + 1);
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym146__), nil_index_list())),
              mean_p, "assigning variable p");
            for (size_t t = lcm_sym123__; t <= lcm_sym116__; ++t) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())),
                beta[(x[(i - 1)][(t - 1)] - 1)], "assigning variable phi");
              current_statement__ = 10;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_p,
                "assigning variable p");}
          } }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym11__;
      int inline_sym19__;
      
      inline_sym19__ = 0;
      for (size_t inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
        current_statement__ = 15;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym12__;
        inline_sym12__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        
        for (size_t inline_sym14__ = 1; inline_sym14__ <= nind;
             ++inline_sym14__) {
          if (logical_gte(n_occasions, 1)) {
            lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
            assign(inline_sym12__,
              cons_list(index_uni(inline_sym14__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
              "assigning variable inline_sym12__");
            for (size_t inline_sym13__ = 2; inline_sym13__ <= n_occasions;
                 ++inline_sym13__) {
              current_statement__ = 15;
              assign(inline_sym12__,
                cons_list(index_uni(inline_sym14__),
                  cons_list(index_uni(inline_sym13__), nil_index_list())),
                lcm_sym141__, "assigning variable inline_sym12__");}
          } 
          if (inline_sym19__) {
            break;
          } }
        if (inline_sym19__) {
          break;
        } 
        for (size_t inline_sym18__ = 1; inline_sym18__ <= nind;
             ++inline_sym18__) {
          current_statement__ = 16;
          assign(inline_sym12__,
            cons_list(index_uni(inline_sym18__),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable inline_sym12__");
          if (logical_gte(lcm_sym116__, 1)) {
            int inline_sym15__;
            
            int inline_sym16__;
            
            lcm_sym120__ = (lcm_sym116__ + 1);
            current_statement__ = 19;
            assign(inline_sym12__,
              cons_list(index_uni(inline_sym18__),
                cons_list(index_uni(lcm_sym116__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym18__),
                     cons_list(index_uni(lcm_sym116__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym18__),
                        cons_list(index_uni((lcm_sym120__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(inline_sym12__,
                  cons_list(index_uni(inline_sym18__),
                    cons_list(index_uni(lcm_sym120__), nil_index_list())),
                  "inline_sym12__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym18__),
                      cons_list(index_uni(lcm_sym116__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym12__");
            for (size_t inline_sym17__ = 2; inline_sym17__ <= lcm_sym116__;
                 ++inline_sym17__) {
              int inline_sym15__;
              
              lcm_sym115__ = (n_occasions - inline_sym17__);
              int inline_sym16__;
              
              lcm_sym119__ = (lcm_sym115__ + 1);
              current_statement__ = 19;
              assign(inline_sym12__,
                cons_list(index_uni(inline_sym18__),
                  cons_list(index_uni(lcm_sym115__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym18__),
                       cons_list(index_uni(lcm_sym115__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym18__),
                          cons_list(index_uni((lcm_sym119__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym12__,
                    cons_list(index_uni(inline_sym18__),
                      cons_list(index_uni(lcm_sym119__), nil_index_list())),
                    "inline_sym12__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym18__),
                        cons_list(index_uni(lcm_sym115__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym12__");}
          } 
          if (inline_sym19__) {
            break;
          } }
        if (inline_sym19__) {
          break;
        } 
        inline_sym19__ = 1;
        assign(inline_sym11__, nil_index_list(), inline_sym12__,
          "assigning variable inline_sym11__");
        break;}
      assign(chi, nil_index_list(), inline_sym11__, "assigning variable chi");
      current_statement__ = 3;
      current_statement__ = 3;
      check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      current_statement__ = 3;
      check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      current_statement__ = 4;
      check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      current_statement__ = 4;
      check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      current_statement__ = 5;
      check_greater_or_equal(function__, "chi", inline_sym11__, 0);
      current_statement__ = 5;
      current_statement__ = 5;
      check_less_or_equal(function__, "chi", inline_sym11__, 1);
      {
        current_statement__ = 29;
        if (lcm_sym105__) {
          lcm_sym147__ = first[(1 - 1)];
          if (logical_gt(lcm_sym147__, 0)) {
            lcm_sym149__ = last[(1 - 1)];
            lcm_sym124__ = (lcm_sym147__ + 1);
            if (logical_gte(lcm_sym149__, lcm_sym124__)) {
              current_statement__ = 23;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym124__ - 1)),
                        nil_index_list())), "phi")));
              lcm_sym122__ = (lcm_sym124__ + 1);
              lp_accum__.add(
                bernoulli_log<propto__>(y[(1 - 1)][(lcm_sym124__ - 1)],
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym124__ - 1)),
                        nil_index_list())), "p")));
              for (size_t t = lcm_sym122__; t <= lcm_sym149__; ++t) {
                current_statement__ = 23;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "phi")));
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(1 - 1)][(t - 1)],
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "p")));}
            } 
            current_statement__ = 26;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                rvalue(inline_sym11__,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym149__), nil_index_list())),
                  "inline_sym11__")));
          } 
          for (size_t i = 2; i <= nind; ++i) {
            lcm_sym146__ = first[(i - 1)];
            if (logical_gt(lcm_sym146__, 0)) {
              lcm_sym148__ = last[(i - 1)];
              lcm_sym123__ = (lcm_sym146__ + 1);
              if (logical_gte(lcm_sym148__, lcm_sym123__)) {
                current_statement__ = 23;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym123__ - 1)),
                          nil_index_list())), "phi")));
                lcm_sym121__ = (lcm_sym123__ + 1);
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(i - 1)][(lcm_sym123__ - 1)],
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym123__ - 1)),
                          nil_index_list())), "p")));
                for (size_t t = lcm_sym121__; t <= lcm_sym148__; ++t) {
                  current_statement__ = 23;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      rvalue(phi,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "phi")));
                  current_statement__ = 24;
                  lp_accum__.add(
                    bernoulli_log<propto__>(y[(i - 1)][(t - 1)],
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "p")));}
              } 
              current_statement__ = 26;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(inline_sym11__,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym148__), nil_index_list())),
                    "inline_sym11__")));
            } }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "copy_fail_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym102__;
      double lcm_sym101__;
      double lcm_sym100__;
      double lcm_sym99__;
      double lcm_sym98__;
      double lcm_sym97__;
      double lcm_sym96__;
      double lcm_sym95__;
      double lcm_sym94__;
      double lcm_sym93__;
      double lcm_sym92__;
      double lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      double lcm_sym88__;
      double lcm_sym87__;
      double lcm_sym86__;
      double lcm_sym85__;
      double lcm_sym84__;
      double lcm_sym83__;
      double lcm_sym82__;
      double lcm_sym79__;
      double lcm_sym78__;
      int lcm_sym77__;
      int lcm_sym76__;
      int lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      int lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      int lcm_sym69__;
      int lcm_sym68__;
      int lcm_sym67__;
      int lcm_sym66__;
      int lcm_sym65__;
      int lcm_sym64__;
      int lcm_sym63__;
      int lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      double mean_p;
      
      current_statement__ = 1;
      mean_p = in__.scalar();
      current_statement__ = 1;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      current_statement__ = 2;
      validate_non_negative_index("beta", "max_age", max_age);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(max_age);
      
      current_statement__ = 2;
      beta = in__.vector(max_age);
      lcm_sym60__ = logical_gte(max_age, 1);
      if (lcm_sym60__) {
        current_statement__ = 2;
        assign(beta, cons_list(index_uni(1), nil_index_list()),
          stan::math::lub_constrain(beta[(1 - 1)], 0, 1),
          "assigning variable beta");
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1),
            "assigning variable beta");}
      } 
      current_statement__ = 3;
      validate_non_negative_index("phi", "nind", nind);
      lcm_sym69__ = (n_occasions - 1);
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym69__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym69__);
      
      lcm_sym62__ = logical_gte(nind, 1);
      if (lcm_sym62__) {
        {
          lcm_sym63__ = logical_gte(lcm_sym69__, 1);
          if (lcm_sym63__) {
            lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
              "assigning variable phi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym69__; ++sym2__) {
              current_statement__ = 3;
              assign(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym82__, "assigning variable phi");}
          } 
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 3;
            if (lcm_sym63__) {
              lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym69__; ++sym2__) {
                current_statement__ = 3;
                assign(phi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym82__, "assigning variable phi");}
            } }
        }
      } else {
        lcm_sym63__ = logical_gte(lcm_sym69__, 1);
      }
      current_statement__ = 4;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 4;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym69__);
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, lcm_sym69__);
      
      current_statement__ = 4;
      if (lcm_sym62__) {
        current_statement__ = 4;
        if (lcm_sym63__) {
          lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym69__; ++sym2__) {
            current_statement__ = 4;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym82__,
              "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym63__) {
            lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym69__; ++sym2__) {
              current_statement__ = 4;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym82__, "assigning variable p");}
          } }
      } 
      current_statement__ = 5;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 5;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      current_statement__ = 5;
      if (lcm_sym62__) {
        {
          lcm_sym61__ = logical_gte(n_occasions, 1);
          if (lcm_sym61__) {
            lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              assign(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym82__, "assigning variable chi");}
          } 
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 5;
            if (lcm_sym61__) {
              lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
                "assigning variable chi");
              for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
                current_statement__ = 5;
                assign(chi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym82__, "assigning variable chi");}
            } }
        }
      } else {
        lcm_sym61__ = logical_gte(n_occasions, 1);
      }
      vars__.push_back(mean_p);
      if (lcm_sym60__) {
        vars__.push_back(beta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          vars__.push_back(beta[(sym1__ - 1)]);}
      } 
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 14;
      if (lcm_sym62__) {
        lcm_sym90__ = first[(1 - 1)];
        lcm_sym71__ = (lcm_sym90__ - 1);
        if (logical_gte(lcm_sym71__, 1)) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable p");
          for (size_t t = 2; t <= lcm_sym71__; ++t) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable p");}
        } 
        current_statement__ = 12;
        if (logical_gte(lcm_sym69__, lcm_sym90__)) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym90__), nil_index_list())),
            beta[(x[(1 - 1)][(lcm_sym90__ - 1)] - 1)],
            "assigning variable phi");
          lcm_sym77__ = (lcm_sym90__ + 1);
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym90__), nil_index_list())), mean_p,
            "assigning variable p");
          for (size_t t = lcm_sym77__; t <= lcm_sym69__; ++t) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())),
              beta[(x[(1 - 1)][(t - 1)] - 1)], "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_p,
              "assigning variable p");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          lcm_sym89__ = first[(i - 1)];
          lcm_sym70__ = (lcm_sym89__ - 1);
          if (logical_gte(lcm_sym70__, 1)) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable p");
            for (size_t t = 2; t <= lcm_sym70__; ++t) {
              current_statement__ = 6;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable phi");
              current_statement__ = 7;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable p");}
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym69__, lcm_sym89__)) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym89__), nil_index_list())),
              beta[(x[(i - 1)][(lcm_sym89__ - 1)] - 1)],
              "assigning variable phi");
            lcm_sym76__ = (lcm_sym89__ + 1);
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym89__), nil_index_list())), mean_p,
              "assigning variable p");
            for (size_t t = lcm_sym76__; t <= lcm_sym69__; ++t) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())),
                beta[(x[(i - 1)][(t - 1)] - 1)], "assigning variable phi");
              current_statement__ = 10;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_p,
                "assigning variable p");}
          } }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym9__;
      
      inline_sym9__ = 0;
      for (size_t inline_sym10__ = 1; inline_sym10__ <= 1; ++inline_sym10__) {
        current_statement__ = 15;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym2__;
        inline_sym2__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        
        for (size_t inline_sym4__ = 1; inline_sym4__ <= nind; ++inline_sym4__) {
          if (lcm_sym61__) {
            lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
            assign(inline_sym2__,
              cons_list(index_uni(inline_sym4__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
              "assigning variable inline_sym2__");
            for (size_t inline_sym3__ = 2; inline_sym3__ <= n_occasions;
                 ++inline_sym3__) {
              current_statement__ = 15;
              assign(inline_sym2__,
                cons_list(index_uni(inline_sym4__),
                  cons_list(index_uni(inline_sym3__), nil_index_list())),
                lcm_sym82__, "assigning variable inline_sym2__");}
          } 
          if (inline_sym9__) {
            break;
          } }
        if (inline_sym9__) {
          break;
        } 
        for (size_t inline_sym8__ = 1; inline_sym8__ <= nind; ++inline_sym8__) {
          current_statement__ = 16;
          assign(inline_sym2__,
            cons_list(index_uni(inline_sym8__),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable inline_sym2__");
          if (lcm_sym63__) {
            int inline_sym5__;
            
            int inline_sym6__;
            
            lcm_sym75__ = (lcm_sym69__ + 1);
            current_statement__ = 19;
            assign(inline_sym2__,
              cons_list(index_uni(inline_sym8__),
                cons_list(index_uni(lcm_sym69__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym8__),
                     cons_list(index_uni(lcm_sym69__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym8__),
                        cons_list(index_uni((lcm_sym75__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(inline_sym2__,
                  cons_list(index_uni(inline_sym8__),
                    cons_list(index_uni(lcm_sym75__), nil_index_list())),
                  "inline_sym2__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym8__),
                      cons_list(index_uni(lcm_sym69__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym2__");
            for (size_t inline_sym7__ = 2; inline_sym7__ <= lcm_sym69__;
                 ++inline_sym7__) {
              int inline_sym5__;
              
              lcm_sym68__ = (n_occasions - inline_sym7__);
              int inline_sym6__;
              
              lcm_sym74__ = (lcm_sym68__ + 1);
              current_statement__ = 19;
              assign(inline_sym2__,
                cons_list(index_uni(inline_sym8__),
                  cons_list(index_uni(lcm_sym68__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym8__),
                       cons_list(index_uni(lcm_sym68__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym8__),
                          cons_list(index_uni((lcm_sym74__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym2__,
                    cons_list(index_uni(inline_sym8__),
                      cons_list(index_uni(lcm_sym74__), nil_index_list())),
                    "inline_sym2__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym8__),
                        cons_list(index_uni(lcm_sym68__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym2__");}
          } 
          if (inline_sym9__) {
            break;
          } }
        if (inline_sym9__) {
          break;
        } 
        inline_sym9__ = 1;
        assign(inline_sym1__, nil_index_list(), inline_sym2__,
          "assigning variable inline_sym1__");
        break;}
      assign(chi, nil_index_list(), inline_sym1__, "assigning variable chi");
      if (lcm_sym63__) {
        if (lcm_sym62__) {
          vars__.push_back(
            rvalue(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "phi"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "phi"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym69__; ++sym1__) {
          if (lcm_sym62__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(phi,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            }
          } }
      } 
      if (lcm_sym63__) {
        if (lcm_sym62__) {
          vars__.push_back(
            rvalue(p,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "p"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "p"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym69__; ++sym1__) {
          if (lcm_sym62__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(p,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "p"));}
          } }
      } 
      if (lcm_sym61__) {
        if (lcm_sym62__) {
          vars__.push_back(
            rvalue(inline_sym1__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "inline_sym1__"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                "inline_sym1__"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym62__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "inline_sym1__"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(inline_sym1__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "inline_sym1__"));}
          } }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym59__;
      double lcm_sym58__;
      double lcm_sym57__;
      double lcm_sym56__;
      int lcm_sym53__;
      int lcm_sym52__;
      int pos__;
      
      pos__ = 1;
      double mean_p;
      
      current_statement__ = 1;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      current_statement__ = 1;
      mean_p = stan::math::lub_free(mean_p, 0, 1);
      current_statement__ = 2;
      validate_non_negative_index("beta", "max_age", max_age);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(max_age);
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        lcm_sym52__ = logical_gte(max_age, 1);
        if (lcm_sym52__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            beta_flat__[(1 - 1)], "assigning variable beta");
          current_statement__ = 2;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
            current_statement__ = 2;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 2;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 2;
      if (lcm_sym52__) {
        current_statement__ = 2;
        assign(beta, cons_list(index_uni(1), nil_index_list()),
          stan::math::lub_free(beta[(1 - 1)], 0, 1),
          "assigning variable beta");
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_free(beta[(sym1__ - 1)], 0, 1),
            "assigning variable beta");}
      } 
      vars__.push_back(mean_p);
      if (lcm_sym52__) {
        vars__.push_back(beta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          vars__.push_back(beta[(sym1__ - 1)]);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mean_p");
    names__.push_back("beta");
    names__.push_back("phi");
    names__.push_back("p");
    names__.push_back("chi");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(max_age);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occ_minus_1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occ_minus_1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_p");
    for (size_t sym181__ = 1; sym181__ <= max_age; ++sym181__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym181__));
      }}
    if (emit_transformed_parameters__) {
      for (size_t sym181__ = 1; sym181__ <= n_occ_minus_1; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
      for (size_t sym181__ = 1; sym181__ <= n_occ_minus_1; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
      for (size_t sym181__ = 1; sym181__ <= n_occasions; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_p");
    for (size_t sym181__ = 1; sym181__ <= max_age; ++sym181__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym181__));
      }}
    if (emit_transformed_parameters__) {
      for (size_t sym181__ = 1; sym181__ <= n_occ_minus_1; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
      for (size_t sym181__ = 1; sym181__ <= n_occ_minus_1; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
      for (size_t sym181__ = 1; sym181__ <= n_occasions; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << max_age << "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << max_age << "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef copy_fail_model_namespace::copy_fail_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp dce-fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace dce_fail_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'dce-fail.stan', line 18, column 2 to column 22)",
                                                      " (in 'dce-fail.stan', line 19, column 2 to column 26)",
                                                      " (in 'dce-fail.stan', line 20, column 2 to column 26)",
                                                      " (in 'dce-fail.stan', line 21, column 2 to column 28)",
                                                      " (in 'dce-fail.stan', line 22, column 2 to column 29)",
                                                      " (in 'dce-fail.stan', line 23, column 2 to column 30)",
                                                      " (in 'dce-fail.stan', line 25, column 2 to column 11)",
                                                      " (in 'dce-fail.stan', line 26, column 2 to column 16)",
                                                      " (in 'dce-fail.stan', line 27, column 2 to column 15)",
                                                      " (in 'dce-fail.stan', line 28, column 2 to column 22)",
                                                      " (in 'dce-fail.stan', line 30, column 2 to column 16)",
                                                      " (in 'dce-fail.stan', line 32, column 2 to column 22)",
                                                      " (in 'dce-fail.stan', line 33, column 2 to column 22)",
                                                      " (in 'dce-fail.stan', line 34, column 2 to column 28)",
                                                      " (in 'dce-fail.stan', line 35, column 2 to column 32)",
                                                      " (in 'dce-fail.stan', line 37, column 2 to column 24)",
                                                      " (in 'dce-fail.stan', line 40, column 2 to column 14)",
                                                      " (in 'dce-fail.stan', line 41, column 2 to column 30)",
                                                      " (in 'dce-fail.stan', line 43, column 2 to column 23)",
                                                      " (in 'dce-fail.stan', line 44, column 2 to column 28)",
                                                      " (in 'dce-fail.stan', line 45, column 2 to column 27)",
                                                      " (in 'dce-fail.stan', line 46, column 2 to column 34)",
                                                      " (in 'dce-fail.stan', line 48, column 2 to column 31)",
                                                      " (in 'dce-fail.stan', line 49, column 2 to column 31)",
                                                      " (in 'dce-fail.stan', line 50, column 2 to column 37)",
                                                      " (in 'dce-fail.stan', line 54, column 6 to column 48)",
                                                      " (in 'dce-fail.stan', line 53, column 4 to line 54, column 48)",
                                                      " (in 'dce-fail.stan', line 52, column 21 to line 55, column 3)",
                                                      " (in 'dce-fail.stan', line 52, column 2 to line 55, column 3)",
                                                      " (in 'dce-fail.stan', line 57, column 2 to column 28)",
                                                      " (in 'dce-fail.stan', line 60, column 4 to column 64)",
                                                      " (in 'dce-fail.stan', line 59, column 2 to line 60, column 64)",
                                                      " (in 'dce-fail.stan', line 62, column 2 to column 43)",
                                                      " (in 'dce-fail.stan', line 65, column 4 to line 68, column 25)",
                                                      " (in 'dce-fail.stan', line 64, column 2 to line 68, column 25)",
                                                      " (in 'dce-fail.stan', line 70, column 2 to column 19)",
                                                      " (in 'dce-fail.stan', line 2, column 2 to column 17)",
                                                      " (in 'dce-fail.stan', line 3, column 2 to column 21)",
                                                      " (in 'dce-fail.stan', line 4, column 2 to column 21)",
                                                      " (in 'dce-fail.stan', line 5, column 2 to column 24)",
                                                      " (in 'dce-fail.stan', line 6, column 2 to column 23)",
                                                      " (in 'dce-fail.stan', line 8, column 2 to column 34)",
                                                      " (in 'dce-fail.stan', line 9, column 2 to column 33)",
                                                      " (in 'dce-fail.stan', line 10, column 2 to column 35)",
                                                      " (in 'dce-fail.stan', line 11, column 2 to column 35)",
                                                      " (in 'dce-fail.stan', line 12, column 2 to column 46)",
                                                      " (in 'dce-fail.stan', line 13, column 2 to column 39)",
                                                      " (in 'dce-fail.stan', line 14, column 2 to column 29)",
                                                      " (in 'dce-fail.stan', line 15, column 2 to column 25)"};



class dce_fail_model : public model_base_crtp<dce_fail_model> {

 private:
  int lcm_sym87__;
  int lcm_sym86__;
  double lcm_sym85__;
  double lcm_sym84__;
  int lcm_sym83__;
  int lcm_sym82__;
  int lcm_sym81__;
  int lcm_sym80__;
  int lcm_sym79__;
  int lcm_sym78__;
  int lcm_sym77__;
  int lcm_sym76__;
  int lcm_sym75__;
  int lcm_sym74__;
  int lcm_sym73__;
  int lcm_sym72__;
  int lcm_sym71__;
  int lcm_sym70__;
  int lcm_sym69__;
  int pos__;
  int N;
  int n_age;
  int n_edu;
  int n_region;
  int n_state;
  std::vector<int> female;
  std::vector<int> black;
  std::vector<int> age;
  std::vector<int> edu;
  std::vector<int> region;
  std::vector<int> state;
  std::vector<int> y;
  Eigen::Matrix<double, -1, 1> v_prev;
 
 public:
  ~dce_fail_model() { }
  
  std::string model_name() const { return "dce_fail_model"; }
  
  dce_fail_model(stan::io::var_context& context__,
                 unsigned int random_seed__ = 0,
                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "dce_fail_model_namespace::dce_fail_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      
      current_statement__ = 37;
      N = context__.vals_i("N")[(1 - 1)];
      context__.validate_dims("data initialization","n_age","int",
          context__.to_vec());
      
      current_statement__ = 38;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      context__.validate_dims("data initialization","n_edu","int",
          context__.to_vec());
      
      current_statement__ = 39;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      context__.validate_dims("data initialization","n_region","int",
          context__.to_vec());
      
      current_statement__ = 40;
      n_region = context__.vals_i("n_region")[(1 - 1)];
      context__.validate_dims("data initialization","n_state","int",
          context__.to_vec());
      
      current_statement__ = 41;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 42;
      validate_non_negative_index("female", "N", N);
      context__.validate_dims("data initialization","female","int",
          context__.to_vec(N));
      female = std::vector<int>(N, 0);
      
      current_statement__ = 42;
      assign(female, nil_index_list(), context__.vals_i("female"),
        "assigning variable female");
      current_statement__ = 43;
      validate_non_negative_index("black", "N", N);
      context__.validate_dims("data initialization","black","int",
          context__.to_vec(N));
      black = std::vector<int>(N, 0);
      
      current_statement__ = 43;
      assign(black, nil_index_list(), context__.vals_i("black"),
        "assigning variable black");
      current_statement__ = 44;
      validate_non_negative_index("age", "N", N);
      context__.validate_dims("data initialization","age","int",
          context__.to_vec(N));
      age = std::vector<int>(N, 0);
      
      current_statement__ = 44;
      assign(age, nil_index_list(), context__.vals_i("age"),
        "assigning variable age");
      current_statement__ = 45;
      validate_non_negative_index("edu", "N", N);
      context__.validate_dims("data initialization","edu","int",
          context__.to_vec(N));
      edu = std::vector<int>(N, 0);
      
      current_statement__ = 45;
      assign(edu, nil_index_list(), context__.vals_i("edu"),
        "assigning variable edu");
      current_statement__ = 46;
      validate_non_negative_index("region", "n_state", n_state);
      context__.validate_dims("data initialization","region","int",
          context__.to_vec(n_state));
      region = std::vector<int>(n_state, 0);
      
      current_statement__ = 46;
      assign(region, nil_index_list(), context__.vals_i("region"),
        "assigning variable region");
      current_statement__ = 47;
      validate_non_negative_index("state", "N", N);
      context__.validate_dims("data initialization","state","int",
          context__.to_vec(N));
      state = std::vector<int>(N, 0);
      
      current_statement__ = 47;
      assign(state, nil_index_list(), context__.vals_i("state"),
        "assigning variable state");
      current_statement__ = 48;
      validate_non_negative_index("y", "N", N);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(N));
      y = std::vector<int>(N, 0);
      
      current_statement__ = 48;
      assign(y, nil_index_list(), context__.vals_i("y"),
        "assigning variable y");
      current_statement__ = 49;
      validate_non_negative_index("v_prev", "n_state", n_state);
      context__.validate_dims("data initialization","v_prev","double",
          context__.to_vec(n_state));
      v_prev = Eigen::Matrix<double, -1, 1>(n_state);
      
      {
        std::vector<double> v_prev_flat__;
        current_statement__ = 49;
        assign(v_prev_flat__, nil_index_list(), context__.vals_r("v_prev"),
          "assigning variable v_prev_flat__");
        current_statement__ = 49;
        pos__ = 1;
        lcm_sym70__ = logical_gte(n_state, 1);
        if (lcm_sym70__) {
          current_statement__ = 49;
          assign(v_prev, cons_list(index_uni(1), nil_index_list()),
            v_prev_flat__[(1 - 1)], "assigning variable v_prev");
          current_statement__ = 49;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
            current_statement__ = 49;
            assign(v_prev, cons_list(index_uni(sym1__), nil_index_list()),
              v_prev_flat__[(pos__ - 1)], "assigning variable v_prev");
            current_statement__ = 49;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 37;
      current_statement__ = 37;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 38;
      current_statement__ = 38;
      check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 39;
      current_statement__ = 39;
      check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 40;
      current_statement__ = 40;
      check_greater_or_equal(function__, "n_region", n_region, 0);
      current_statement__ = 41;
      current_statement__ = 41;
      check_greater_or_equal(function__, "n_state", n_state, 0);
      lcm_sym69__ = logical_gte(N, 1);
      if (lcm_sym69__) {
        current_statement__ = 42;
        current_statement__ = 42;
        check_greater_or_equal(function__, "female[sym1__]", female[(1 - 1)],
                               0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 42;
          current_statement__ = 42;
          check_greater_or_equal(function__, "female[sym1__]",
                                 female[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 42;
      if (lcm_sym69__) {
        current_statement__ = 42;
        current_statement__ = 42;
        check_less_or_equal(function__, "female[sym1__]", female[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 42;
          current_statement__ = 42;
          check_less_or_equal(function__, "female[sym1__]",
                              female[(sym1__ - 1)], 1);}
      } 
      current_statement__ = 43;
      if (lcm_sym69__) {
        current_statement__ = 43;
        current_statement__ = 43;
        check_greater_or_equal(function__, "black[sym1__]", black[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 43;
          current_statement__ = 43;
          check_greater_or_equal(function__, "black[sym1__]",
                                 black[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 43;
      if (lcm_sym69__) {
        current_statement__ = 43;
        current_statement__ = 43;
        check_less_or_equal(function__, "black[sym1__]", black[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 43;
          current_statement__ = 43;
          check_less_or_equal(function__, "black[sym1__]",
                              black[(sym1__ - 1)], 1);}
      } 
      current_statement__ = 44;
      if (lcm_sym69__) {
        current_statement__ = 44;
        current_statement__ = 44;
        check_greater_or_equal(function__, "age[sym1__]", age[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 44;
          current_statement__ = 44;
          check_greater_or_equal(function__, "age[sym1__]",
                                 age[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 44;
      if (lcm_sym69__) {
        current_statement__ = 44;
        current_statement__ = 44;
        check_less_or_equal(function__, "age[sym1__]", age[(1 - 1)], n_age);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 44;
          current_statement__ = 44;
          check_less_or_equal(function__, "age[sym1__]", age[(sym1__ - 1)],
                              n_age);}
      } 
      current_statement__ = 45;
      if (lcm_sym69__) {
        current_statement__ = 45;
        current_statement__ = 45;
        check_greater_or_equal(function__, "edu[sym1__]", edu[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 45;
          current_statement__ = 45;
          check_greater_or_equal(function__, "edu[sym1__]",
                                 edu[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 45;
      if (lcm_sym69__) {
        current_statement__ = 45;
        current_statement__ = 45;
        check_less_or_equal(function__, "edu[sym1__]", edu[(1 - 1)], n_edu);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 45;
          current_statement__ = 45;
          check_less_or_equal(function__, "edu[sym1__]", edu[(sym1__ - 1)],
                              n_edu);}
      } 
      current_statement__ = 46;
      if (lcm_sym70__) {
        current_statement__ = 46;
        current_statement__ = 46;
        check_greater_or_equal(function__, "region[sym1__]", region[(1 - 1)],
                               0);
        for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          current_statement__ = 46;
          current_statement__ = 46;
          check_greater_or_equal(function__, "region[sym1__]",
                                 region[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 46;
      if (lcm_sym70__) {
        current_statement__ = 46;
        current_statement__ = 46;
        check_less_or_equal(function__, "region[sym1__]", region[(1 - 1)],
                            n_state);
        for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          current_statement__ = 46;
          current_statement__ = 46;
          check_less_or_equal(function__, "region[sym1__]",
                              region[(sym1__ - 1)], n_state);}
      } 
      current_statement__ = 47;
      if (lcm_sym69__) {
        current_statement__ = 47;
        current_statement__ = 47;
        check_greater_or_equal(function__, "state[sym1__]", state[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 47;
          current_statement__ = 47;
          check_greater_or_equal(function__, "state[sym1__]",
                                 state[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 47;
      if (lcm_sym69__) {
        current_statement__ = 47;
        current_statement__ = 47;
        check_less_or_equal(function__, "state[sym1__]", state[(1 - 1)],
                            n_state);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 47;
          current_statement__ = 47;
          check_less_or_equal(function__, "state[sym1__]",
                              state[(sym1__ - 1)], n_state);}
      } 
      current_statement__ = 48;
      if (lcm_sym69__) {
        current_statement__ = 48;
        current_statement__ = 48;
        check_greater_or_equal(function__, "y[sym1__]", y[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 48;
          current_statement__ = 48;
          check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 48;
      if (lcm_sym69__) {
        current_statement__ = 48;
        current_statement__ = 48;
        check_less_or_equal(function__, "y[sym1__]", y[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 48;
          current_statement__ = 48;
          check_less_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 1);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 12;
      validate_non_negative_index("b_age", "n_age", n_age);
      num_params_r__ += n_age;
      current_statement__ = 13;
      validate_non_negative_index("b_edu", "n_edu", n_edu);
      num_params_r__ += n_edu;
      current_statement__ = 14;
      validate_non_negative_index("b_region", "n_region", n_region);
      num_params_r__ += n_region;
      current_statement__ = 15;
      validate_non_negative_index("b_age_edu", "n_age", n_age);
      current_statement__ = 15;
      validate_non_negative_index("b_age_edu", "n_edu", n_edu);
      num_params_r__ += n_age * n_edu;
      current_statement__ = 16;
      validate_non_negative_index("b_hat", "n_state", n_state);
      num_params_r__ += n_state;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "dce_fail_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym68__;
      double lcm_sym67__;
      double lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      double lcm_sym62__;
      double lcm_sym61__;
      double lcm_sym60__;
      double lcm_sym59__;
      double lcm_sym58__;
      double lcm_sym57__;
      double lcm_sym56__;
      double lcm_sym55__;
      double lcm_sym54__;
      double lcm_sym53__;
      double lcm_sym52__;
      double lcm_sym51__;
      double lcm_sym50__;
      int lcm_sym49__;
      int lcm_sym48__;
      int lcm_sym47__;
      int lcm_sym46__;
      local_scalar_t__ sigma;
      
      current_statement__ = 1;
      sigma = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        sigma = stan::math::lb_constrain(sigma, 0, lp__);
      } else {
        current_statement__ = 1;
        sigma = stan::math::lb_constrain(sigma, 0);
      }
      local_scalar_t__ sigma_age;
      
      current_statement__ = 2;
      sigma_age = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        sigma_age = stan::math::lb_constrain(sigma_age, 0, lp__);
      } else {
        current_statement__ = 2;
        sigma_age = stan::math::lb_constrain(sigma_age, 0);
      }
      local_scalar_t__ sigma_edu;
      
      current_statement__ = 3;
      sigma_edu = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        sigma_edu = stan::math::lb_constrain(sigma_edu, 0, lp__);
      } else {
        current_statement__ = 3;
        sigma_edu = stan::math::lb_constrain(sigma_edu, 0);
      }
      local_scalar_t__ sigma_state;
      
      current_statement__ = 4;
      sigma_state = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        sigma_state = stan::math::lb_constrain(sigma_state, 0, lp__);
      } else {
        current_statement__ = 4;
        sigma_state = stan::math::lb_constrain(sigma_state, 0);
      }
      local_scalar_t__ sigma_region;
      
      current_statement__ = 5;
      sigma_region = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        sigma_region = stan::math::lb_constrain(sigma_region, 0, lp__);
      } else {
        current_statement__ = 5;
        sigma_region = stan::math::lb_constrain(sigma_region, 0);
      }
      local_scalar_t__ sigma_age_edu;
      
      current_statement__ = 6;
      sigma_age_edu = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        sigma_age_edu = stan::math::lb_constrain(sigma_age_edu, 0, lp__);
      } else {
        current_statement__ = 6;
        sigma_age_edu = stan::math::lb_constrain(sigma_age_edu, 0);
      }
      local_scalar_t__ b_0;
      
      current_statement__ = 7;
      b_0 = in__.scalar();
      local_scalar_t__ b_female;
      
      current_statement__ = 8;
      b_female = in__.scalar();
      local_scalar_t__ b_black;
      
      current_statement__ = 9;
      b_black = in__.scalar();
      local_scalar_t__ b_female_black;
      
      current_statement__ = 10;
      b_female_black = in__.scalar();
      local_scalar_t__ b_v_prev;
      
      current_statement__ = 11;
      b_v_prev = in__.scalar();
      current_statement__ = 12;
      validate_non_negative_index("b_age", "n_age", n_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_age;
      b_age = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age);
      
      current_statement__ = 12;
      b_age = in__.vector(n_age);
      current_statement__ = 13;
      validate_non_negative_index("b_edu", "n_edu", n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_edu;
      b_edu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_edu);
      
      current_statement__ = 13;
      b_edu = in__.vector(n_edu);
      current_statement__ = 14;
      validate_non_negative_index("b_region", "n_region", n_region);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_region;
      b_region = Eigen::Matrix<local_scalar_t__, -1, 1>(n_region);
      
      current_statement__ = 14;
      b_region = in__.vector(n_region);
      current_statement__ = 15;
      validate_non_negative_index("b_age_edu", "n_age", n_age);
      current_statement__ = 15;
      validate_non_negative_index("b_age_edu", "n_edu", n_edu);
      Eigen::Matrix<local_scalar_t__, -1, -1> b_age_edu;
      b_age_edu = Eigen::Matrix<local_scalar_t__, -1, -1>(n_age, n_edu);
      
      current_statement__ = 15;
      b_age_edu = in__.matrix(n_age, n_edu);
      current_statement__ = 16;
      validate_non_negative_index("b_hat", "n_state", n_state);
      Eigen::Matrix<local_scalar_t__, -1, 1> b_hat;
      b_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
      
      current_statement__ = 16;
      b_hat = in__.vector(n_state);
      {
        current_statement__ = 17;
        validate_non_negative_index("p", "N", N);
        Eigen::Matrix<local_scalar_t__, -1, 1> p;
        p = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
        
        lcm_sym46__ = logical_gte(N, 1);
        if (lcm_sym46__) {
          lcm_sym68__ = std::numeric_limits<double>::quiet_NaN();
          assign(p, cons_list(index_uni(1), nil_index_list()), lcm_sym68__,
            "assigning variable p");
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 17;
            assign(p, cons_list(index_uni(sym1__), nil_index_list()),
              lcm_sym68__, "assigning variable p");}
        } 
        current_statement__ = 18;
        validate_non_negative_index("b_state_hat", "n_state", n_state);
        Eigen::Matrix<local_scalar_t__, -1, 1> b_state_hat;
        b_state_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
        
        lcm_sym49__ = logical_gte(n_state, 1);
        if (lcm_sym49__) {
          lcm_sym68__ = std::numeric_limits<double>::quiet_NaN();
          assign(b_state_hat, cons_list(index_uni(1), nil_index_list()),
            lcm_sym68__, "assigning variable b_state_hat");
          for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
            current_statement__ = 18;
            assign(b_state_hat,
              cons_list(index_uni(sym1__), nil_index_list()), lcm_sym68__,
              "assigning variable b_state_hat");}
        } 
        current_statement__ = 19;
        lp_accum__.add(normal_log<propto__>(b_0, 0, 100));
        current_statement__ = 20;
        lp_accum__.add(normal_log<propto__>(b_female, 0, 100));
        current_statement__ = 21;
        lp_accum__.add(normal_log<propto__>(b_black, 0, 100));
        current_statement__ = 22;
        lp_accum__.add(normal_log<propto__>(b_female_black, 0, 100));
        current_statement__ = 23;
        lp_accum__.add(normal_log<propto__>(b_age, 0, sigma_age));
        current_statement__ = 24;
        lp_accum__.add(normal_log<propto__>(b_edu, 0, sigma_edu));
        current_statement__ = 25;
        lp_accum__.add(normal_log<propto__>(b_region, 0, sigma_region));
        current_statement__ = 29;
        if (logical_gte(n_age, 1)) {
          lcm_sym48__ = logical_gte(n_edu, 1);
          if (lcm_sym48__) {
            current_statement__ = 26;
            lp_accum__.add(
              normal_log<propto__>(
                rvalue(b_age_edu,
                  cons_list(index_uni(1),
                    cons_list(index_uni(1), nil_index_list())), "b_age_edu"),
                0, sigma_age_edu));
            for (size_t i = 2; i <= n_edu; ++i) {
              current_statement__ = 26;
              lp_accum__.add(
                normal_log<propto__>(
                  rvalue(b_age_edu,
                    cons_list(index_uni(1),
                      cons_list(index_uni(i), nil_index_list())),
                    "b_age_edu"), 0, sigma_age_edu));}
          } 
          for (size_t j = 2; j <= n_age; ++j) {
            current_statement__ = 27;
            if (lcm_sym48__) {
              current_statement__ = 26;
              lp_accum__.add(
                normal_log<propto__>(
                  rvalue(b_age_edu,
                    cons_list(index_uni(j),
                      cons_list(index_uni(1), nil_index_list())),
                    "b_age_edu"), 0, sigma_age_edu));
              for (size_t i = 2; i <= n_edu; ++i) {
                current_statement__ = 26;
                lp_accum__.add(
                  normal_log<propto__>(
                    rvalue(b_age_edu,
                      cons_list(index_uni(j),
                        cons_list(index_uni(i), nil_index_list())),
                      "b_age_edu"), 0, sigma_age_edu));}
            } }
        } 
        current_statement__ = 30;
        lp_accum__.add(normal_log<propto__>(b_v_prev, 0, 100));
        current_statement__ = 32;
        if (lcm_sym49__) {
          current_statement__ = 31;
          assign(b_state_hat, cons_list(index_uni(1), nil_index_list()),
            stan::math::fma(b_v_prev, v_prev[(1 - 1)],
              b_region[(region[(1 - 1)] - 1)]),
            "assigning variable b_state_hat");
          for (size_t j = 2; j <= n_state; ++j) {
            current_statement__ = 31;
            assign(b_state_hat, cons_list(index_uni(j), nil_index_list()),
              stan::math::fma(b_v_prev, v_prev[(j - 1)],
                b_region[(region[(j - 1)] - 1)]),
              "assigning variable b_state_hat");}
        } 
        current_statement__ = 33;
        lp_accum__.add(normal_log<propto__>(b_hat, b_state_hat, sigma_state));
        current_statement__ = 35;
        if (lcm_sym46__) {
          current_statement__ = 34;
          assign(p, cons_list(index_uni(1), nil_index_list()),
            stan::math::fmax(0,
              stan::math::fmin(1,
                inv_logit(
                  ((((stan::math::fma((b_female_black * female[(1 - 1)]),
                        black[(1 - 1)],
                        stan::math::fma(b_black, black[(1 - 1)],
                          stan::math::fma(b_female, female[(1 - 1)], b_0))) +
                       b_age[(age[(1 - 1)] - 1)]) +
                      b_edu[(edu[(1 - 1)] - 1)]) +
                     rvalue(b_age_edu,
                       cons_list(index_uni(age[(1 - 1)]),
                         cons_list(index_uni(edu[(1 - 1)]), nil_index_list())),
                       "b_age_edu")) + b_hat[(state[(1 - 1)] - 1)])))),
            "assigning variable p");
          for (size_t i = 2; i <= N; ++i) {
            current_statement__ = 34;
            assign(p, cons_list(index_uni(i), nil_index_list()),
              stan::math::fmax(0,
                stan::math::fmin(1,
                  inv_logit(
                    ((((stan::math::fma((b_female_black * female[(i - 1)]),
                          black[(i - 1)],
                          stan::math::fma(b_black, black[(i - 1)],
                            stan::math::fma(b_female, female[(i - 1)], b_0)))
                         + b_age[(age[(i - 1)] - 1)]) +
                        b_edu[(edu[(i - 1)] - 1)]) +
                       rvalue(b_age_edu,
                         cons_list(index_uni(age[(i - 1)]),
                           cons_list(index_uni(edu[(i - 1)]),
                             nil_index_list())), "b_age_edu")) +
                      b_hat[(state[(i - 1)] - 1)])))), "assigning variable p");
          }
        } 
        current_statement__ = 36;
        lp_accum__.add(bernoulli_log<propto__>(y, p));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "dce_fail_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym45__;
      double lcm_sym44__;
      double lcm_sym43__;
      double lcm_sym42__;
      double lcm_sym41__;
      double lcm_sym40__;
      double lcm_sym39__;
      double lcm_sym38__;
      double lcm_sym37__;
      double lcm_sym36__;
      double lcm_sym35__;
      double lcm_sym34__;
      int lcm_sym33__;
      int lcm_sym32__;
      int lcm_sym31__;
      int lcm_sym30__;
      int lcm_sym29__;
      int lcm_sym28__;
      double sigma;
      
      current_statement__ = 1;
      sigma = in__.scalar();
      current_statement__ = 1;
      sigma = stan::math::lb_constrain(sigma, 0);
      double sigma_age;
      
      current_statement__ = 2;
      sigma_age = in__.scalar();
      current_statement__ = 2;
      sigma_age = stan::math::lb_constrain(sigma_age, 0);
      double sigma_edu;
      
      current_statement__ = 3;
      sigma_edu = in__.scalar();
      current_statement__ = 3;
      sigma_edu = stan::math::lb_constrain(sigma_edu, 0);
      double sigma_state;
      
      current_statement__ = 4;
      sigma_state = in__.scalar();
      current_statement__ = 4;
      sigma_state = stan::math::lb_constrain(sigma_state, 0);
      double sigma_region;
      
      current_statement__ = 5;
      sigma_region = in__.scalar();
      current_statement__ = 5;
      sigma_region = stan::math::lb_constrain(sigma_region, 0);
      double sigma_age_edu;
      
      current_statement__ = 6;
      sigma_age_edu = in__.scalar();
      current_statement__ = 6;
      sigma_age_edu = stan::math::lb_constrain(sigma_age_edu, 0);
      double b_0;
      
      current_statement__ = 7;
      b_0 = in__.scalar();
      double b_female;
      
      current_statement__ = 8;
      b_female = in__.scalar();
      double b_black;
      
      current_statement__ = 9;
      b_black = in__.scalar();
      double b_female_black;
      
      current_statement__ = 10;
      b_female_black = in__.scalar();
      double b_v_prev;
      
      current_statement__ = 11;
      b_v_prev = in__.scalar();
      current_statement__ = 12;
      validate_non_negative_index("b_age", "n_age", n_age);
      Eigen::Matrix<double, -1, 1> b_age;
      b_age = Eigen::Matrix<double, -1, 1>(n_age);
      
      current_statement__ = 12;
      b_age = in__.vector(n_age);
      current_statement__ = 13;
      validate_non_negative_index("b_edu", "n_edu", n_edu);
      Eigen::Matrix<double, -1, 1> b_edu;
      b_edu = Eigen::Matrix<double, -1, 1>(n_edu);
      
      current_statement__ = 13;
      b_edu = in__.vector(n_edu);
      current_statement__ = 14;
      validate_non_negative_index("b_region", "n_region", n_region);
      Eigen::Matrix<double, -1, 1> b_region;
      b_region = Eigen::Matrix<double, -1, 1>(n_region);
      
      current_statement__ = 14;
      b_region = in__.vector(n_region);
      current_statement__ = 15;
      validate_non_negative_index("b_age_edu", "n_age", n_age);
      current_statement__ = 15;
      validate_non_negative_index("b_age_edu", "n_edu", n_edu);
      Eigen::Matrix<double, -1, -1> b_age_edu;
      b_age_edu = Eigen::Matrix<double, -1, -1>(n_age, n_edu);
      
      current_statement__ = 15;
      b_age_edu = in__.matrix(n_age, n_edu);
      current_statement__ = 16;
      validate_non_negative_index("b_hat", "n_state", n_state);
      Eigen::Matrix<double, -1, 1> b_hat;
      b_hat = Eigen::Matrix<double, -1, 1>(n_state);
      
      current_statement__ = 16;
      b_hat = in__.vector(n_state);
      vars__.push_back(sigma);
      vars__.push_back(sigma_age);
      vars__.push_back(sigma_edu);
      vars__.push_back(sigma_state);
      vars__.push_back(sigma_region);
      vars__.push_back(sigma_age_edu);
      vars__.push_back(b_0);
      vars__.push_back(b_female);
      vars__.push_back(b_black);
      vars__.push_back(b_female_black);
      vars__.push_back(b_v_prev);
      lcm_sym28__ = logical_gte(n_age, 1);
      if (lcm_sym28__) {
        vars__.push_back(b_age[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_age; ++sym1__) {
          vars__.push_back(b_age[(sym1__ - 1)]);}
      } 
      lcm_sym29__ = logical_gte(n_edu, 1);
      if (lcm_sym29__) {
        vars__.push_back(b_edu[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          vars__.push_back(b_edu[(sym1__ - 1)]);}
      } 
      if (logical_gte(n_region, 1)) {
        vars__.push_back(b_region[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_region; ++sym1__) {
          vars__.push_back(b_region[(sym1__ - 1)]);}
      } 
      if (lcm_sym29__) {
        if (lcm_sym28__) {
          vars__.push_back(
            rvalue(b_age_edu,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "b_age_edu"));
          for (size_t sym2__ = 2; sym2__ <= n_age; ++sym2__) {
            vars__.push_back(
              rvalue(b_age_edu,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "b_age_edu"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          if (lcm_sym28__) {
            vars__.push_back(
              rvalue(b_age_edu,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "b_age_edu"));
            for (size_t sym2__ = 2; sym2__ <= n_age; ++sym2__) {
              vars__.push_back(
                rvalue(b_age_edu,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "b_age_edu"));}
          } }
      } 
      if (logical_gte(n_state, 1)) {
        vars__.push_back(b_hat[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          vars__.push_back(b_hat[(sym1__ - 1)]);}
      } 
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      double sigma;
      
      current_statement__ = 1;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      current_statement__ = 1;
      sigma = stan::math::lb_free(sigma, 0);
      double sigma_age;
      
      current_statement__ = 2;
      sigma_age = context__.vals_r("sigma_age")[(1 - 1)];
      current_statement__ = 2;
      sigma_age = stan::math::lb_free(sigma_age, 0);
      double sigma_edu;
      
      current_statement__ = 3;
      sigma_edu = context__.vals_r("sigma_edu")[(1 - 1)];
      current_statement__ = 3;
      sigma_edu = stan::math::lb_free(sigma_edu, 0);
      double sigma_state;
      
      current_statement__ = 4;
      sigma_state = context__.vals_r("sigma_state")[(1 - 1)];
      current_statement__ = 4;
      sigma_state = stan::math::lb_free(sigma_state, 0);
      double sigma_region;
      
      current_statement__ = 5;
      sigma_region = context__.vals_r("sigma_region")[(1 - 1)];
      current_statement__ = 5;
      sigma_region = stan::math::lb_free(sigma_region, 0);
      double sigma_age_edu;
      
      current_statement__ = 6;
      sigma_age_edu = context__.vals_r("sigma_age_edu")[(1 - 1)];
      current_statement__ = 6;
      sigma_age_edu = stan::math::lb_free(sigma_age_edu, 0);
      double b_0;
      
      current_statement__ = 7;
      b_0 = context__.vals_r("b_0")[(1 - 1)];
      double b_female;
      
      current_statement__ = 8;
      b_female = context__.vals_r("b_female")[(1 - 1)];
      double b_black;
      
      current_statement__ = 9;
      b_black = context__.vals_r("b_black")[(1 - 1)];
      double b_female_black;
      
      current_statement__ = 10;
      b_female_black = context__.vals_r("b_female_black")[(1 - 1)];
      double b_v_prev;
      
      current_statement__ = 11;
      b_v_prev = context__.vals_r("b_v_prev")[(1 - 1)];
      current_statement__ = 12;
      validate_non_negative_index("b_age", "n_age", n_age);
      Eigen::Matrix<double, -1, 1> b_age;
      b_age = Eigen::Matrix<double, -1, 1>(n_age);
      
      {
        std::vector<double> b_age_flat__;
        current_statement__ = 12;
        assign(b_age_flat__, nil_index_list(), context__.vals_r("b_age"),
          "assigning variable b_age_flat__");
        current_statement__ = 12;
        pos__ = 1;
        lcm_sym1__ = logical_gte(n_age, 1);
        if (lcm_sym1__) {
          current_statement__ = 12;
          assign(b_age, cons_list(index_uni(1), nil_index_list()),
            b_age_flat__[(1 - 1)], "assigning variable b_age");
          current_statement__ = 12;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_age; ++sym1__) {
            current_statement__ = 12;
            assign(b_age, cons_list(index_uni(sym1__), nil_index_list()),
              b_age_flat__[(pos__ - 1)], "assigning variable b_age");
            current_statement__ = 12;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 13;
      validate_non_negative_index("b_edu", "n_edu", n_edu);
      Eigen::Matrix<double, -1, 1> b_edu;
      b_edu = Eigen::Matrix<double, -1, 1>(n_edu);
      
      {
        std::vector<double> b_edu_flat__;
        current_statement__ = 13;
        assign(b_edu_flat__, nil_index_list(), context__.vals_r("b_edu"),
          "assigning variable b_edu_flat__");
        current_statement__ = 13;
        pos__ = 1;
        lcm_sym2__ = logical_gte(n_edu, 1);
        if (lcm_sym2__) {
          current_statement__ = 13;
          assign(b_edu, cons_list(index_uni(1), nil_index_list()),
            b_edu_flat__[(1 - 1)], "assigning variable b_edu");
          current_statement__ = 13;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
            current_statement__ = 13;
            assign(b_edu, cons_list(index_uni(sym1__), nil_index_list()),
              b_edu_flat__[(pos__ - 1)], "assigning variable b_edu");
            current_statement__ = 13;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 14;
      validate_non_negative_index("b_region", "n_region", n_region);
      Eigen::Matrix<double, -1, 1> b_region;
      b_region = Eigen::Matrix<double, -1, 1>(n_region);
      
      {
        std::vector<double> b_region_flat__;
        current_statement__ = 14;
        assign(b_region_flat__, nil_index_list(),
          context__.vals_r("b_region"), "assigning variable b_region_flat__");
        current_statement__ = 14;
        pos__ = 1;
        lcm_sym3__ = logical_gte(n_region, 1);
        if (lcm_sym3__) {
          current_statement__ = 14;
          assign(b_region, cons_list(index_uni(1), nil_index_list()),
            b_region_flat__[(1 - 1)], "assigning variable b_region");
          current_statement__ = 14;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_region; ++sym1__) {
            current_statement__ = 14;
            assign(b_region, cons_list(index_uni(sym1__), nil_index_list()),
              b_region_flat__[(pos__ - 1)], "assigning variable b_region");
            current_statement__ = 14;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 15;
      validate_non_negative_index("b_age_edu", "n_age", n_age);
      current_statement__ = 15;
      validate_non_negative_index("b_age_edu", "n_edu", n_edu);
      Eigen::Matrix<double, -1, -1> b_age_edu;
      b_age_edu = Eigen::Matrix<double, -1, -1>(n_age, n_edu);
      
      {
        std::vector<double> b_age_edu_flat__;
        current_statement__ = 15;
        assign(b_age_edu_flat__, nil_index_list(),
          context__.vals_r("b_age_edu"),
          "assigning variable b_age_edu_flat__");
        current_statement__ = 15;
        pos__ = 1;
        current_statement__ = 15;
        if (lcm_sym2__) {
          current_statement__ = 15;
          if (lcm_sym1__) {
            current_statement__ = 15;
            assign(b_age_edu,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              b_age_edu_flat__[(1 - 1)], "assigning variable b_age_edu");
            current_statement__ = 15;
            pos__ = 2;
            for (size_t sym2__ = 2; sym2__ <= n_age; ++sym2__) {
              current_statement__ = 15;
              assign(b_age_edu,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                b_age_edu_flat__[(pos__ - 1)], "assigning variable b_age_edu");
              current_statement__ = 15;
              pos__ = (pos__ + 1);}
          } 
          for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
            current_statement__ = 15;
            if (lcm_sym1__) {
              current_statement__ = 15;
              assign(b_age_edu,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                b_age_edu_flat__[(pos__ - 1)], "assigning variable b_age_edu");
              current_statement__ = 15;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= n_age; ++sym2__) {
                current_statement__ = 15;
                assign(b_age_edu,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  b_age_edu_flat__[(pos__ - 1)],
                  "assigning variable b_age_edu");
                current_statement__ = 15;
                pos__ = (pos__ + 1);}
            } }
        } 
      }
      current_statement__ = 16;
      validate_non_negative_index("b_hat", "n_state", n_state);
      Eigen::Matrix<double, -1, 1> b_hat;
      b_hat = Eigen::Matrix<double, -1, 1>(n_state);
      
      {
        std::vector<double> b_hat_flat__;
        current_statement__ = 16;
        assign(b_hat_flat__, nil_index_list(), context__.vals_r("b_hat"),
          "assigning variable b_hat_flat__");
        current_statement__ = 16;
        pos__ = 1;
        lcm_sym4__ = logical_gte(n_state, 1);
        if (lcm_sym4__) {
          current_statement__ = 16;
          assign(b_hat, cons_list(index_uni(1), nil_index_list()),
            b_hat_flat__[(1 - 1)], "assigning variable b_hat");
          current_statement__ = 16;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
            current_statement__ = 16;
            assign(b_hat, cons_list(index_uni(sym1__), nil_index_list()),
              b_hat_flat__[(pos__ - 1)], "assigning variable b_hat");
            current_statement__ = 16;
            pos__ = (pos__ + 1);}
        } 
      }
      vars__.push_back(sigma);
      vars__.push_back(sigma_age);
      vars__.push_back(sigma_edu);
      vars__.push_back(sigma_state);
      vars__.push_back(sigma_region);
      vars__.push_back(sigma_age_edu);
      vars__.push_back(b_0);
      vars__.push_back(b_female);
      vars__.push_back(b_black);
      vars__.push_back(b_female_black);
      vars__.push_back(b_v_prev);
      if (lcm_sym1__) {
        vars__.push_back(b_age[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_age; ++sym1__) {
          vars__.push_back(b_age[(sym1__ - 1)]);}
      } 
      if (lcm_sym2__) {
        vars__.push_back(b_edu[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          vars__.push_back(b_edu[(sym1__ - 1)]);}
      } 
      if (lcm_sym3__) {
        vars__.push_back(b_region[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_region; ++sym1__) {
          vars__.push_back(b_region[(sym1__ - 1)]);}
      } 
      if (lcm_sym2__) {
        if (lcm_sym1__) {
          vars__.push_back(
            rvalue(b_age_edu,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "b_age_edu"));
          for (size_t sym2__ = 2; sym2__ <= n_age; ++sym2__) {
            vars__.push_back(
              rvalue(b_age_edu,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "b_age_edu"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          if (lcm_sym1__) {
            vars__.push_back(
              rvalue(b_age_edu,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "b_age_edu"));
            for (size_t sym2__ = 2; sym2__ <= n_age; ++sym2__) {
              vars__.push_back(
                rvalue(b_age_edu,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "b_age_edu"));}
          } }
      } 
      if (lcm_sym4__) {
        vars__.push_back(b_hat[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          vars__.push_back(b_hat[(sym1__ - 1)]);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("sigma");
    names__.push_back("sigma_age");
    names__.push_back("sigma_edu");
    names__.push_back("sigma_state");
    names__.push_back("sigma_region");
    names__.push_back("sigma_age_edu");
    names__.push_back("b_0");
    names__.push_back("b_female");
    names__.push_back("b_black");
    names__.push_back("b_female_black");
    names__.push_back("b_v_prev");
    names__.push_back("b_age");
    names__.push_back("b_edu");
    names__.push_back("b_region");
    names__.push_back("b_age_edu");
    names__.push_back("b_hat");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_age);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_edu);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_region);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_age);
    
    dims__.push_back(n_edu);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_state);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "sigma");
    param_names__.push_back(std::string() + "sigma_age");
    param_names__.push_back(std::string() + "sigma_edu");
    param_names__.push_back(std::string() + "sigma_state");
    param_names__.push_back(std::string() + "sigma_region");
    param_names__.push_back(std::string() + "sigma_age_edu");
    param_names__.push_back(std::string() + "b_0");
    param_names__.push_back(std::string() + "b_female");
    param_names__.push_back(std::string() + "b_black");
    param_names__.push_back(std::string() + "b_female_black");
    param_names__.push_back(std::string() + "b_v_prev");
    for (size_t sym88__ = 1; sym88__ <= n_age; ++sym88__) {
      {
        param_names__.push_back(std::string() + "b_age" + '.' + std::to_string(sym88__));
      }}
    for (size_t sym88__ = 1; sym88__ <= n_edu; ++sym88__) {
      {
        param_names__.push_back(std::string() + "b_edu" + '.' + std::to_string(sym88__));
      }}
    for (size_t sym88__ = 1; sym88__ <= n_region; ++sym88__) {
      {
        param_names__.push_back(std::string() + "b_region" + '.' + std::to_string(sym88__));
      }}
    for (size_t sym88__ = 1; sym88__ <= n_edu; ++sym88__) {
      {
        for (size_t sym89__ = 1; sym89__ <= n_age; ++sym89__) {
          {
            param_names__.push_back(std::string() + "b_age_edu" + '.' + std::to_string(sym89__) + '.' + std::to_string(sym88__));
          }}
      }}
    for (size_t sym88__ = 1; sym88__ <= n_state; ++sym88__) {
      {
        param_names__.push_back(std::string() + "b_hat" + '.' + std::to_string(sym88__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "sigma");
    param_names__.push_back(std::string() + "sigma_age");
    param_names__.push_back(std::string() + "sigma_edu");
    param_names__.push_back(std::string() + "sigma_state");
    param_names__.push_back(std::string() + "sigma_region");
    param_names__.push_back(std::string() + "sigma_age_edu");
    param_names__.push_back(std::string() + "b_0");
    param_names__.push_back(std::string() + "b_female");
    param_names__.push_back(std::string() + "b_black");
    param_names__.push_back(std::string() + "b_female_black");
    param_names__.push_back(std::string() + "b_v_prev");
    for (size_t sym88__ = 1; sym88__ <= n_age; ++sym88__) {
      {
        param_names__.push_back(std::string() + "b_age" + '.' + std::to_string(sym88__));
      }}
    for (size_t sym88__ = 1; sym88__ <= n_edu; ++sym88__) {
      {
        param_names__.push_back(std::string() + "b_edu" + '.' + std::to_string(sym88__));
      }}
    for (size_t sym88__ = 1; sym88__ <= n_region; ++sym88__) {
      {
        param_names__.push_back(std::string() + "b_region" + '.' + std::to_string(sym88__));
      }}
    for (size_t sym88__ = 1; sym88__ <= n_edu; ++sym88__) {
      {
        for (size_t sym89__ = 1; sym89__ <= n_age; ++sym89__) {
          {
            param_names__.push_back(std::string() + "b_age_edu" + '.' + std::to_string(sym89__) + '.' + std::to_string(sym88__));
          }}
      }}
    for (size_t sym88__ = 1; sym88__ <= n_state; ++sym88__) {
      {
        param_names__.push_back(std::string() + "b_hat" + '.' + std::to_string(sym88__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" << n_age << "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" << n_region << "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_age << ",\"cols\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" << n_state << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_state\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_region\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_age_edu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_female_black\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_v_prev\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b_age\",\"type\":{\"name\":\"vector\",\"length\":" << n_age << "},\"block\":\"parameters\"},{\"name\":\"b_edu\",\"type\":{\"name\":\"vector\",\"length\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"b_region\",\"type\":{\"name\":\"vector\",\"length\":" << n_region << "},\"block\":\"parameters\"},{\"name\":\"b_age_edu\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_age << ",\"cols\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"b_hat\",\"type\":{\"name\":\"vector\",\"length\":" << n_state << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef dce_fail_model_namespace::dce_fail_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-experiment.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-experiment.stan', line 2, column 2 to column 8)",
                                                      " (in 'expr-prop-experiment.stan', line 5, column 2 to column 9)",
                                                      " (in 'expr-prop-experiment.stan', line 6, column 2 to column 9)",
                                                      " (in 'expr-prop-experiment.stan', line 7, column 2 to column 9)",
                                                      " (in 'expr-prop-experiment.stan', line 8, column 2 to column 28)",
                                                      " (in 'expr-prop-experiment.stan', line 10, column 2 to column 23)",
                                                      " (in 'expr-prop-experiment.stan', line 11, column 2 to column 23)",
                                                      " (in 'expr-prop-experiment.stan', line 12, column 2 to column 23)"};



class expr_prop_experiment_model : public model_base_crtp<expr_prop_experiment_model> {

 private:
  double lcm_sym5__;
  double lcm_sym4__;
  int pos__;
  int j;
  double z;
  double x;
  double y;
  double i;
 
 public:
  ~expr_prop_experiment_model() { }
  
  std::string model_name() const { return "expr_prop_experiment_model"; }
  
  expr_prop_experiment_model(stan::io::var_context& context__,
                             unsigned int random_seed__ = 0,
                             std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_experiment_model_namespace::expr_prop_experiment_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","j","int",
          context__.to_vec());
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      
      lcm_sym5__ = std::numeric_limits<double>::quiet_NaN();
      z = lcm_sym5__;
      
      current_statement__ = 3;
      x = lcm_sym5__;
      
      current_statement__ = 4;
      y = lcm_sym5__;
      
      current_statement__ = 5;
      i = lcm_sym5__;
      current_statement__ = 5;
      i = normal_rng(5, 1, base_rng__);
      lcm_sym4__ = (i * j);
      z = lcm_sym4__;
      current_statement__ = 6;
      x = normal_rng(lcm_sym4__, 1, base_rng__);
      current_statement__ = 7;
      i = normal_rng(5, 1, base_rng__);
      current_statement__ = 8;
      y = normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_experiment_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_experiment_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}

typedef expr_prop_experiment_model_namespace::expr_prop_experiment_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-experiment2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_experiment2_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-experiment2.stan', line 2, column 2 to column 8)",
                                                      " (in 'expr-prop-experiment2.stan', line 5, column 2 to column 13)",
                                                      " (in 'expr-prop-experiment2.stan', line 6, column 2 to column 9)",
                                                      " (in 'expr-prop-experiment2.stan', line 8, column 4 to column 32)",
                                                      " (in 'expr-prop-experiment2.stan', line 10, column 4 to column 25)",
                                                      " (in 'expr-prop-experiment2.stan', line 7, column 2 to line 11, column 3)",
                                                      " (in 'expr-prop-experiment2.stan', line 12, column 2 to column 23)"};



class expr_prop_experiment2_model : public model_base_crtp<expr_prop_experiment2_model> {

 private:
  double lcm_sym5__;
  double lcm_sym4__;
  int pos__;
  int j;
  double z;
  double y;
 
 public:
  ~expr_prop_experiment2_model() { }
  
  std::string model_name() const { return "expr_prop_experiment2_model"; }
  
  expr_prop_experiment2_model(stan::io::var_context& context__,
                              unsigned int random_seed__ = 0,
                              std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_experiment2_model_namespace::expr_prop_experiment2_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","j","int",
          context__.to_vec());
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      
      lcm_sym5__ = std::numeric_limits<double>::quiet_NaN();
      z = lcm_sym5__;
      current_statement__ = 2;
      z = 1;
      
      current_statement__ = 3;
      y = lcm_sym5__;
      {
        double x;
        
        current_statement__ = 4;
        x = lcm_sym5__;
        current_statement__ = 4;
        x = normal_rng(123, 1, base_rng__);
        lcm_sym4__ = (x * 2);
        z = lcm_sym4__;
        current_statement__ = 5;
        y = normal_rng(lcm_sym4__, 1, base_rng__);
      }
      current_statement__ = 7;
      y = normal_rng(z, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_experiment2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_experiment2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}

typedef expr_prop_experiment2_model_namespace::expr_prop_experiment2_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-fail.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail.stan', line 7, column 2 to column 16)",
                                                      " (in 'expr-prop-fail.stan', line 8, column 2 to column 25)",
                                                      " (in 'expr-prop-fail.stan', line 9, column 2 to column 31)",
                                                      " (in 'expr-prop-fail.stan', line 13, column 1 to column 22)",
                                                      " (in 'expr-prop-fail.stan', line 14, column 1 to column 19)",
                                                      " (in 'expr-prop-fail.stan', line 15, column 1 to column 20)",
                                                      " (in 'expr-prop-fail.stan', line 17, column 3 to line 19, column 58)",
                                                      " (in 'expr-prop-fail.stan', line 16, column 1 to line 19, column 58)",
                                                      " (in 'expr-prop-fail.stan', line 2, column 1 to column 18)",
                                                      " (in 'expr-prop-fail.stan', line 3, column 1 to column 13)"};



class expr_prop_fail_model : public model_base_crtp<expr_prop_fail_model> {

 private:
  double lcm_sym31__;
  double lcm_sym30__;
  int lcm_sym29__;
  int lcm_sym28__;
  int pos__;
  int N;
  Eigen::Matrix<double, -1, 1> y;
 
 public:
  ~expr_prop_fail_model() { }
  
  std::string model_name() const { return "expr_prop_fail_model"; }
  
  expr_prop_fail_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail_model_namespace::expr_prop_fail_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      
      current_statement__ = 9;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 10;
      validate_non_negative_index("y", "N", N);
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(N));
      y = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 10;
        assign(y_flat__, nil_index_list(), context__.vals_r("y"),
          "assigning variable y_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        if (logical_gte(N, 1)) {
          current_statement__ = 10;
          assign(y, cons_list(index_uni(1), nil_index_list()),
            y_flat__[(1 - 1)], "assigning variable y");
          current_statement__ = 10;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 10;
            assign(y, cons_list(index_uni(sym1__), nil_index_list()),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 10;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 9;
      current_statement__ = 9;
      check_greater_or_equal(function__, "N", N, 0);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("mu", "2", 2);
      num_params_r__ += 2;
      current_statement__ = 2;
      validate_non_negative_index("sigma", "2", 2);
      num_params_r__ += 2;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      local_scalar_t__ lcm_sym27__;
      double lcm_sym25__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      int lcm_sym18__;
      current_statement__ = 1;
      validate_non_negative_index("mu", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> mu;
      mu = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      
      current_statement__ = 1;
      mu = in__.vector(2);
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        assign(mu, nil_index_list(), stan::math::ordered_constrain(mu, lp__),
          "assigning variable mu");
      } else {
        current_statement__ = 1;
        assign(mu, nil_index_list(), stan::math::ordered_constrain(mu),
          "assigning variable mu");
      }
      current_statement__ = 2;
      validate_non_negative_index("sigma", "2", 2);
      std::vector<local_scalar_t__> sigma;
      sigma = std::vector<local_scalar_t__>(2, 0);
      
      {
        current_statement__ = 2;
        assign(sigma, cons_list(index_uni(1), nil_index_list()),
          in__.scalar(), "assigning variable sigma");
        {
          current_statement__ = 2;
          assign(sigma, cons_list(index_uni(2), nil_index_list()),
            in__.scalar(), "assigning variable sigma");
        }
      }
      {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(sigma, cons_list(index_uni(1), nil_index_list()),
            stan::math::lb_constrain(sigma[(1 - 1)], 0, lp__),
            "assigning variable sigma");
        } else {
          current_statement__ = 2;
          assign(sigma, cons_list(index_uni(1), nil_index_list()),
            stan::math::lb_constrain(sigma[(1 - 1)], 0),
            "assigning variable sigma");
        }
        {
          current_statement__ = 2;
          if (jacobian__) {
            current_statement__ = 2;
            assign(sigma, cons_list(index_uni(2), nil_index_list()),
              stan::math::lb_constrain(sigma[(2 - 1)], 0, lp__),
              "assigning variable sigma");
          } else {
            current_statement__ = 2;
            assign(sigma, cons_list(index_uni(2), nil_index_list()),
              stan::math::lb_constrain(sigma[(2 - 1)], 0),
              "assigning variable sigma");
          }
        }
      }
      local_scalar_t__ theta;
      
      current_statement__ = 3;
      theta = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        theta = stan::math::lub_constrain(theta, 0, 1, lp__);
      } else {
        current_statement__ = 3;
        theta = stan::math::lub_constrain(theta, 0, 1);
      }
      {
        current_statement__ = 4;
        lp_accum__.add(normal_log<propto__>(sigma, 0, 2));
        current_statement__ = 5;
        lp_accum__.add(normal_log<propto__>(mu, 0, 2));
        current_statement__ = 6;
        lp_accum__.add(beta_log<propto__>(theta, 5, 5));
        current_statement__ = 8;
        if (logical_gte(N, 1)) {
          lcm_sym27__ = sigma[(1 - 1)];
          lp_accum__.add(
            log_mix(theta,
              normal_lpdf<false>(y[(1 - 1)], mu[(1 - 1)], lcm_sym27__),
              normal_lpdf<false>(y[(1 - 1)], mu[(2 - 1)], sigma[(2 - 1)])));
          for (size_t n = 2; n <= N; ++n) {
            current_statement__ = 7;
            lp_accum__.add(
              log_mix(theta,
                normal_lpdf<false>(y[(n - 1)], mu[(1 - 1)], lcm_sym27__),
                normal_lpdf<false>(y[(n - 1)], mu[(2 - 1)], sigma[(2 - 1)])));
          }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      int lcm_sym11__;
      int lcm_sym10__;
      current_statement__ = 1;
      validate_non_negative_index("mu", "2", 2);
      Eigen::Matrix<double, -1, 1> mu;
      mu = Eigen::Matrix<double, -1, 1>(2);
      
      current_statement__ = 1;
      mu = in__.vector(2);
      current_statement__ = 1;
      assign(mu, nil_index_list(), stan::math::ordered_constrain(mu),
        "assigning variable mu");
      current_statement__ = 2;
      validate_non_negative_index("sigma", "2", 2);
      std::vector<double> sigma;
      sigma = std::vector<double>(2, 0);
      
      {
        current_statement__ = 2;
        assign(sigma, cons_list(index_uni(1), nil_index_list()),
          in__.scalar(), "assigning variable sigma");
        {
          current_statement__ = 2;
          assign(sigma, cons_list(index_uni(2), nil_index_list()),
            in__.scalar(), "assigning variable sigma");
        }
      }
      {
        current_statement__ = 2;
        assign(sigma, cons_list(index_uni(1), nil_index_list()),
          stan::math::lb_constrain(sigma[(1 - 1)], 0),
          "assigning variable sigma");
        {
          current_statement__ = 2;
          assign(sigma, cons_list(index_uni(2), nil_index_list()),
            stan::math::lb_constrain(sigma[(2 - 1)], 0),
            "assigning variable sigma");
        }
      }
      double theta;
      
      current_statement__ = 3;
      theta = in__.scalar();
      current_statement__ = 3;
      theta = stan::math::lub_constrain(theta, 0, 1);
      {
        vars__.push_back(mu[(1 - 1)]);
        {
          vars__.push_back(mu[(2 - 1)]);
        }
      }
      {
        vars__.push_back(sigma[(1 - 1)]);
        {
          vars__.push_back(sigma[(2 - 1)]);
        }
      }
      vars__.push_back(theta);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("mu", "2", 2);
      Eigen::Matrix<double, -1, 1> mu;
      mu = Eigen::Matrix<double, -1, 1>(2);
      
      {
        std::vector<double> mu_flat__;
        current_statement__ = 1;
        assign(mu_flat__, nil_index_list(), context__.vals_r("mu"),
          "assigning variable mu_flat__");
        current_statement__ = 1;
        pos__ = 1;
        {
          current_statement__ = 1;
          assign(mu, cons_list(index_uni(1), nil_index_list()),
            mu_flat__[(1 - 1)], "assigning variable mu");
          current_statement__ = 1;
          pos__ = 2;
          {
            current_statement__ = 1;
            assign(mu, cons_list(index_uni(2), nil_index_list()),
              mu_flat__[(pos__ - 1)], "assigning variable mu");
            current_statement__ = 1;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 1;
      assign(mu, nil_index_list(), stan::math::ordered_free(mu),
        "assigning variable mu");
      current_statement__ = 2;
      validate_non_negative_index("sigma", "2", 2);
      std::vector<double> sigma;
      sigma = std::vector<double>(2, 0);
      
      current_statement__ = 2;
      assign(sigma, nil_index_list(), context__.vals_r("sigma"),
        "assigning variable sigma");
      {
        current_statement__ = 2;
        assign(sigma, cons_list(index_uni(1), nil_index_list()),
          stan::math::lb_free(sigma[(1 - 1)], 0), "assigning variable sigma");
        {
          current_statement__ = 2;
          assign(sigma, cons_list(index_uni(2), nil_index_list()),
            stan::math::lb_free(sigma[(2 - 1)], 0),
            "assigning variable sigma");
        }
      }
      double theta;
      
      current_statement__ = 3;
      theta = context__.vals_r("theta")[(1 - 1)];
      current_statement__ = 3;
      theta = stan::math::lub_free(theta, 0, 1);
      {
        vars__.push_back(mu[(1 - 1)]);
        {
          vars__.push_back(mu[(2 - 1)]);
        }
      }
      {
        vars__.push_back(sigma[(1 - 1)]);
        {
          vars__.push_back(sigma[(2 - 1)]);
        }
      }
      vars__.push_back(theta);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mu");
    names__.push_back("sigma");
    names__.push_back("theta");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    for (size_t sym32__ = 1; sym32__ <= 2; ++sym32__) {
      {
        param_names__.push_back(std::string() + "mu" + '.' + std::to_string(sym32__));
      }}
    for (size_t sym32__ = 1; sym32__ <= 2; ++sym32__) {
      {
        param_names__.push_back(std::string() + "sigma" + '.' + std::to_string(sym32__));
      }}
    param_names__.push_back(std::string() + "theta");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    for (size_t sym32__ = 1; sym32__ <= 2; ++sym32__) {
      {
        param_names__.push_back(std::string() + "mu" + '.' + std::to_string(sym32__));
      }}
    for (size_t sym32__ = 1; sym32__ <= 2; ++sym32__) {
      {
        param_names__.push_back(std::string() + "sigma" + '.' + std::to_string(sym32__));
      }}
    param_names__.push_back(std::string() + "theta");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"array\",\"length\":" << 2 << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef expr_prop_fail_model_namespace::expr_prop_fail_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-fail2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail2_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail2.stan', line 7, column 2 to column 10)",
                                                      " (in 'expr-prop-fail2.stan', line 8, column 2 to column 16)",
                                                      " (in 'expr-prop-fail2.stan', line 9, column 2 to column 20)",
                                                      " (in 'expr-prop-fail2.stan', line 12, column 2 to column 26)",
                                                      " (in 'expr-prop-fail2.stan', line 13, column 2 to column 26)",
                                                      " (in 'expr-prop-fail2.stan', line 2, column 2 to column 17)",
                                                      " (in 'expr-prop-fail2.stan', line 3, column 2 to column 12)",
                                                      " (in 'expr-prop-fail2.stan', line 4, column 2 to column 25)"};



class expr_prop_fail2_model : public model_base_crtp<expr_prop_fail2_model> {

 private:
  double lcm_sym14__;
  double lcm_sym13__;
  int lcm_sym12__;
  int pos__;
  int J;
  std::vector<double> y;
  std::vector<double> sigma;
 
 public:
  ~expr_prop_fail2_model() { }
  
  std::string model_name() const { return "expr_prop_fail2_model"; }
  
  expr_prop_fail2_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail2_model_namespace::expr_prop_fail2_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      
      current_statement__ = 6;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 7;
      validate_non_negative_index("y", "J", J);
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(J));
      y = std::vector<double>(J, 0);
      
      current_statement__ = 7;
      assign(y, nil_index_list(), context__.vals_r("y"),
        "assigning variable y");
      current_statement__ = 8;
      validate_non_negative_index("sigma", "J", J);
      context__.validate_dims("data initialization","sigma","double",
          context__.to_vec(J));
      sigma = std::vector<double>(J, 0);
      
      current_statement__ = 8;
      assign(sigma, nil_index_list(), context__.vals_r("sigma"),
        "assigning variable sigma");
      current_statement__ = 6;
      current_statement__ = 6;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 8;
      if (logical_gte(J, 1)) {
        current_statement__ = 8;
        current_statement__ = 8;
        check_greater_or_equal(function__, "sigma[sym1__]", sigma[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 8;
          current_statement__ = 8;
          check_greater_or_equal(function__, "sigma[sym1__]",
                                 sigma[(sym1__ - 1)], 0);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      current_statement__ = 2;
      validate_non_negative_index("theta", "J", J);
      num_params_r__ += J;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym11__;
      double lcm_sym10__;
      int lcm_sym9__;
      local_scalar_t__ mu;
      
      current_statement__ = 1;
      mu = in__.scalar();
      current_statement__ = 2;
      validate_non_negative_index("theta", "J", J);
      std::vector<local_scalar_t__> theta;
      theta = std::vector<local_scalar_t__>(J, 0);
      
      current_statement__ = 2;
      if (logical_gte(J, 1)) {
        current_statement__ = 2;
        assign(theta, cons_list(index_uni(1), nil_index_list()),
          in__.scalar(), "assigning variable theta");
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 2;
          assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
            in__.scalar(), "assigning variable theta");}
      } 
      local_scalar_t__ tau;
      
      current_statement__ = 3;
      tau = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        tau = stan::math::lb_constrain(tau, 0, lp__);
      } else {
        current_statement__ = 3;
        tau = stan::math::lb_constrain(tau, 0);
      }
      {
        current_statement__ = 4;
        lp_accum__.add(normal_log<propto__>(theta, mu, tau));
        current_statement__ = 5;
        lp_accum__.add(normal_log<propto__>(y, theta, sigma));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym8__;
      double lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      double mu;
      
      current_statement__ = 1;
      mu = in__.scalar();
      current_statement__ = 2;
      validate_non_negative_index("theta", "J", J);
      std::vector<double> theta;
      theta = std::vector<double>(J, 0);
      
      lcm_sym4__ = logical_gte(J, 1);
      if (lcm_sym4__) {
        current_statement__ = 2;
        assign(theta, cons_list(index_uni(1), nil_index_list()),
          in__.scalar(), "assigning variable theta");
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 2;
          assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
            in__.scalar(), "assigning variable theta");}
      } 
      double tau;
      
      current_statement__ = 3;
      tau = in__.scalar();
      current_statement__ = 3;
      tau = stan::math::lb_constrain(tau, 0);
      vars__.push_back(mu);
      if (lcm_sym4__) {
        vars__.push_back(theta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(theta[(sym1__ - 1)]);}
      } 
      vars__.push_back(tau);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym3__;
      double lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      double mu;
      
      current_statement__ = 1;
      mu = context__.vals_r("mu")[(1 - 1)];
      current_statement__ = 2;
      validate_non_negative_index("theta", "J", J);
      std::vector<double> theta;
      theta = std::vector<double>(J, 0);
      
      current_statement__ = 2;
      assign(theta, nil_index_list(), context__.vals_r("theta"),
        "assigning variable theta");
      double tau;
      
      current_statement__ = 3;
      tau = context__.vals_r("tau")[(1 - 1)];
      current_statement__ = 3;
      tau = stan::math::lb_free(tau, 0);
      vars__.push_back(mu);
      if (logical_gte(J, 1)) {
        vars__.push_back(theta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(theta[(sym1__ - 1)]);}
      } 
      vars__.push_back(tau);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mu");
    names__.push_back("theta");
    names__.push_back("tau");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(J);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mu");
    for (size_t sym15__ = 1; sym15__ <= J; ++sym15__) {
      {
        param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym15__));
      }}
    param_names__.push_back(std::string() + "tau");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mu");
    for (size_t sym15__ = 1; sym15__ <= J; ++sym15__) {
      {
        param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym15__));
      }}
    param_names__.push_back(std::string() + "tau");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef expr_prop_fail2_model_namespace::expr_prop_fail2_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-fail3.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail3_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail3.stan', line 19, column 2 to column 18)",
                                                      " (in 'expr-prop-fail3.stan', line 20, column 2 to column 18)",
                                                      " (in 'expr-prop-fail3.stan', line 21, column 2 to column 22)",
                                                      " (in 'expr-prop-fail3.stan', line 22, column 2 to column 20)",
                                                      " (in 'expr-prop-fail3.stan', line 23, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 24, column 2 to column 17)",
                                                      " (in 'expr-prop-fail3.stan', line 25, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 26, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 27, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 28, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 29, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 32, column 2 to column 18)",
                                                      " (in 'expr-prop-fail3.stan', line 35, column 4 to line 38, column 66)",
                                                      " (in 'expr-prop-fail3.stan', line 34, column 2 to line 38, column 66)",
                                                      " (in 'expr-prop-fail3.stan', line 41, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 42, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 43, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 44, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 45, column 2 to column 26)",
                                                      " (in 'expr-prop-fail3.stan', line 46, column 2 to column 24)",
                                                      " (in 'expr-prop-fail3.stan', line 47, column 2 to column 29)",
                                                      " (in 'expr-prop-fail3.stan', line 2, column 2 to column 17)",
                                                      " (in 'expr-prop-fail3.stan', line 3, column 2 to column 21)",
                                                      " (in 'expr-prop-fail3.stan', line 4, column 2 to column 25)",
                                                      " (in 'expr-prop-fail3.stan', line 5, column 2 to column 21)",
                                                      " (in 'expr-prop-fail3.stan', line 6, column 2 to column 29)",
                                                      " (in 'expr-prop-fail3.stan', line 7, column 2 to column 23)",
                                                      " (in 'expr-prop-fail3.stan', line 8, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 9, column 2 to column 42)",
                                                      " (in 'expr-prop-fail3.stan', line 10, column 2 to column 35)",
                                                      " (in 'expr-prop-fail3.stan', line 11, column 2 to column 34)",
                                                      " (in 'expr-prop-fail3.stan', line 12, column 2 to column 36)",
                                                      " (in 'expr-prop-fail3.stan', line 13, column 2 to column 50)",
                                                      " (in 'expr-prop-fail3.stan', line 14, column 2 to column 38)",
                                                      " (in 'expr-prop-fail3.stan', line 15, column 2 to column 24)",
                                                      " (in 'expr-prop-fail3.stan', line 16, column 2 to column 28)"};



class expr_prop_fail3_model : public model_base_crtp<expr_prop_fail3_model> {

 private:
  int lcm_sym86__;
  int lcm_sym85__;
  double lcm_sym84__;
  double lcm_sym83__;
  int lcm_sym82__;
  int lcm_sym81__;
  int lcm_sym80__;
  int lcm_sym79__;
  double lcm_sym78__;
  double lcm_sym77__;
  int lcm_sym76__;
  int lcm_sym75__;
  double lcm_sym74__;
  double lcm_sym73__;
  int lcm_sym72__;
  int lcm_sym71__;
  int lcm_sym70__;
  int lcm_sym69__;
  int lcm_sym68__;
  int lcm_sym67__;
  int pos__;
  int N;
  int n_age;
  int n_age_edu;
  int n_edu;
  int n_region_full;
  int n_state;
  std::vector<int> age;
  std::vector<int> age_edu;
  Eigen::Matrix<double, -1, 1> black;
  std::vector<int> edu;
  Eigen::Matrix<double, -1, 1> female;
  std::vector<int> region_full;
  std::vector<int> state;
  Eigen::Matrix<double, -1, 1> v_prev_full;
  std::vector<int> y;
 
 public:
  ~expr_prop_fail3_model() { }
  
  std::string model_name() const { return "expr_prop_fail3_model"; }
  
  expr_prop_fail3_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail3_model_namespace::expr_prop_fail3_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      
      current_statement__ = 22;
      N = context__.vals_i("N")[(1 - 1)];
      context__.validate_dims("data initialization","n_age","int",
          context__.to_vec());
      
      current_statement__ = 23;
      n_age = context__.vals_i("n_age")[(1 - 1)];
      context__.validate_dims("data initialization","n_age_edu","int",
          context__.to_vec());
      
      current_statement__ = 24;
      n_age_edu = context__.vals_i("n_age_edu")[(1 - 1)];
      context__.validate_dims("data initialization","n_edu","int",
          context__.to_vec());
      
      current_statement__ = 25;
      n_edu = context__.vals_i("n_edu")[(1 - 1)];
      context__.validate_dims("data initialization","n_region_full","int",
          context__.to_vec());
      
      current_statement__ = 26;
      n_region_full = context__.vals_i("n_region_full")[(1 - 1)];
      context__.validate_dims("data initialization","n_state","int",
          context__.to_vec());
      
      current_statement__ = 27;
      n_state = context__.vals_i("n_state")[(1 - 1)];
      current_statement__ = 28;
      validate_non_negative_index("age", "N", N);
      context__.validate_dims("data initialization","age","int",
          context__.to_vec(N));
      age = std::vector<int>(N, 0);
      
      current_statement__ = 28;
      assign(age, nil_index_list(), context__.vals_i("age"),
        "assigning variable age");
      current_statement__ = 29;
      validate_non_negative_index("age_edu", "N", N);
      context__.validate_dims("data initialization","age_edu","int",
          context__.to_vec(N));
      age_edu = std::vector<int>(N, 0);
      
      current_statement__ = 29;
      assign(age_edu, nil_index_list(), context__.vals_i("age_edu"),
        "assigning variable age_edu");
      current_statement__ = 30;
      validate_non_negative_index("black", "N", N);
      context__.validate_dims("data initialization","black","double",
          context__.to_vec(N));
      black = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> black_flat__;
        current_statement__ = 30;
        assign(black_flat__, nil_index_list(), context__.vals_r("black"),
          "assigning variable black_flat__");
        current_statement__ = 30;
        pos__ = 1;
        lcm_sym67__ = logical_gte(N, 1);
        if (lcm_sym67__) {
          current_statement__ = 30;
          assign(black, cons_list(index_uni(1), nil_index_list()),
            black_flat__[(1 - 1)], "assigning variable black");
          current_statement__ = 30;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 30;
            assign(black, cons_list(index_uni(sym1__), nil_index_list()),
              black_flat__[(pos__ - 1)], "assigning variable black");
            current_statement__ = 30;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 31;
      validate_non_negative_index("edu", "N", N);
      context__.validate_dims("data initialization","edu","int",
          context__.to_vec(N));
      edu = std::vector<int>(N, 0);
      
      current_statement__ = 31;
      assign(edu, nil_index_list(), context__.vals_i("edu"),
        "assigning variable edu");
      current_statement__ = 32;
      validate_non_negative_index("female", "N", N);
      context__.validate_dims("data initialization","female","double",
          context__.to_vec(N));
      female = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> female_flat__;
        current_statement__ = 32;
        assign(female_flat__, nil_index_list(), context__.vals_r("female"),
          "assigning variable female_flat__");
        current_statement__ = 32;
        pos__ = 1;
        current_statement__ = 32;
        if (lcm_sym67__) {
          current_statement__ = 32;
          assign(female, cons_list(index_uni(1), nil_index_list()),
            female_flat__[(1 - 1)], "assigning variable female");
          current_statement__ = 32;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 32;
            assign(female, cons_list(index_uni(sym1__), nil_index_list()),
              female_flat__[(pos__ - 1)], "assigning variable female");
            current_statement__ = 32;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 33;
      validate_non_negative_index("region_full", "N", N);
      context__.validate_dims("data initialization","region_full","int",
          context__.to_vec(N));
      region_full = std::vector<int>(N, 0);
      
      current_statement__ = 33;
      assign(region_full, nil_index_list(), context__.vals_i("region_full"),
        "assigning variable region_full");
      current_statement__ = 34;
      validate_non_negative_index("state", "N", N);
      context__.validate_dims("data initialization","state","int",
          context__.to_vec(N));
      state = std::vector<int>(N, 0);
      
      current_statement__ = 34;
      assign(state, nil_index_list(), context__.vals_i("state"),
        "assigning variable state");
      current_statement__ = 35;
      validate_non_negative_index("v_prev_full", "N", N);
      context__.validate_dims("data initialization","v_prev_full","double",
          context__.to_vec(N));
      v_prev_full = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> v_prev_full_flat__;
        current_statement__ = 35;
        assign(v_prev_full_flat__, nil_index_list(),
          context__.vals_r("v_prev_full"),
          "assigning variable v_prev_full_flat__");
        current_statement__ = 35;
        pos__ = 1;
        current_statement__ = 35;
        if (lcm_sym67__) {
          current_statement__ = 35;
          assign(v_prev_full, cons_list(index_uni(1), nil_index_list()),
            v_prev_full_flat__[(1 - 1)], "assigning variable v_prev_full");
          current_statement__ = 35;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 35;
            assign(v_prev_full,
              cons_list(index_uni(sym1__), nil_index_list()),
              v_prev_full_flat__[(pos__ - 1)],
              "assigning variable v_prev_full");
            current_statement__ = 35;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 36;
      validate_non_negative_index("y", "N", N);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(N));
      y = std::vector<int>(N, 0);
      
      current_statement__ = 36;
      assign(y, nil_index_list(), context__.vals_i("y"),
        "assigning variable y");
      current_statement__ = 22;
      current_statement__ = 22;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 23;
      current_statement__ = 23;
      check_greater_or_equal(function__, "n_age", n_age, 0);
      current_statement__ = 24;
      current_statement__ = 24;
      check_greater_or_equal(function__, "n_age_edu", n_age_edu, 0);
      current_statement__ = 25;
      current_statement__ = 25;
      check_greater_or_equal(function__, "n_edu", n_edu, 0);
      current_statement__ = 26;
      current_statement__ = 26;
      check_greater_or_equal(function__, "n_region_full", n_region_full, 0);
      current_statement__ = 27;
      current_statement__ = 27;
      check_greater_or_equal(function__, "n_state", n_state, 0);
      current_statement__ = 28;
      if (lcm_sym67__) {
        current_statement__ = 28;
        current_statement__ = 28;
        check_greater_or_equal(function__, "age[sym1__]", age[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 28;
          current_statement__ = 28;
          check_greater_or_equal(function__, "age[sym1__]",
                                 age[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 28;
      if (lcm_sym67__) {
        current_statement__ = 28;
        current_statement__ = 28;
        check_less_or_equal(function__, "age[sym1__]", age[(1 - 1)], n_age);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 28;
          current_statement__ = 28;
          check_less_or_equal(function__, "age[sym1__]", age[(sym1__ - 1)],
                              n_age);}
      } 
      current_statement__ = 29;
      if (lcm_sym67__) {
        current_statement__ = 29;
        current_statement__ = 29;
        check_greater_or_equal(function__, "age_edu[sym1__]",
                               age_edu[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 29;
          current_statement__ = 29;
          check_greater_or_equal(function__, "age_edu[sym1__]",
                                 age_edu[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 29;
      if (lcm_sym67__) {
        current_statement__ = 29;
        current_statement__ = 29;
        check_less_or_equal(function__, "age_edu[sym1__]", age_edu[(1 - 1)],
                            n_age_edu);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 29;
          current_statement__ = 29;
          check_less_or_equal(function__, "age_edu[sym1__]",
                              age_edu[(sym1__ - 1)], n_age_edu);}
      } 
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "black", black, 0);
      current_statement__ = 30;
      current_statement__ = 30;
      check_less_or_equal(function__, "black", black, 1);
      current_statement__ = 31;
      if (lcm_sym67__) {
        current_statement__ = 31;
        current_statement__ = 31;
        check_greater_or_equal(function__, "edu[sym1__]", edu[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 31;
          current_statement__ = 31;
          check_greater_or_equal(function__, "edu[sym1__]",
                                 edu[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 31;
      if (lcm_sym67__) {
        current_statement__ = 31;
        current_statement__ = 31;
        check_less_or_equal(function__, "edu[sym1__]", edu[(1 - 1)], n_edu);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 31;
          current_statement__ = 31;
          check_less_or_equal(function__, "edu[sym1__]", edu[(sym1__ - 1)],
                              n_edu);}
      } 
      current_statement__ = 32;
      current_statement__ = 32;
      check_greater_or_equal(function__, "female", female, 0);
      current_statement__ = 32;
      current_statement__ = 32;
      check_less_or_equal(function__, "female", female, 1);
      current_statement__ = 33;
      if (lcm_sym67__) {
        current_statement__ = 33;
        current_statement__ = 33;
        check_greater_or_equal(function__, "region_full[sym1__]",
                               region_full[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 33;
          current_statement__ = 33;
          check_greater_or_equal(function__, "region_full[sym1__]",
                                 region_full[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 33;
      if (lcm_sym67__) {
        current_statement__ = 33;
        current_statement__ = 33;
        check_less_or_equal(function__, "region_full[sym1__]",
                            region_full[(1 - 1)], n_region_full);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 33;
          current_statement__ = 33;
          check_less_or_equal(function__, "region_full[sym1__]",
                              region_full[(sym1__ - 1)], n_region_full);}
      } 
      current_statement__ = 34;
      if (lcm_sym67__) {
        current_statement__ = 34;
        current_statement__ = 34;
        check_greater_or_equal(function__, "state[sym1__]", state[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_greater_or_equal(function__, "state[sym1__]",
                                 state[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 34;
      if (lcm_sym67__) {
        current_statement__ = 34;
        current_statement__ = 34;
        check_less_or_equal(function__, "state[sym1__]", state[(1 - 1)],
                            n_state);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_less_or_equal(function__, "state[sym1__]",
                              state[(sym1__ - 1)], n_state);}
      } 
      current_statement__ = 36;
      if (lcm_sym67__) {
        current_statement__ = 36;
        current_statement__ = 36;
        check_greater_or_equal(function__, "y[sym1__]", y[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 36;
          current_statement__ = 36;
          check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 36;
      if (lcm_sym67__) {
        current_statement__ = 36;
        current_statement__ = 36;
        check_less_or_equal(function__, "y[sym1__]", y[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 36;
          current_statement__ = 36;
          check_less_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 1);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("a", "n_age", n_age);
      num_params_r__ += n_age;
      current_statement__ = 2;
      validate_non_negative_index("b", "n_edu", n_edu);
      num_params_r__ += n_edu;
      current_statement__ = 3;
      validate_non_negative_index("c", "n_age_edu", n_age_edu);
      num_params_r__ += n_age_edu;
      current_statement__ = 4;
      validate_non_negative_index("d", "n_state", n_state);
      num_params_r__ += n_state;
      current_statement__ = 5;
      validate_non_negative_index("e", "n_region_full", n_region_full);
      num_params_r__ += n_region_full;
      current_statement__ = 6;
      validate_non_negative_index("beta", "5", 5);
      num_params_r__ += 5;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail3_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      double lcm_sym62__;
      double lcm_sym61__;
      double lcm_sym60__;
      double lcm_sym59__;
      double lcm_sym58__;
      double lcm_sym57__;
      int lcm_sym56__;
      current_statement__ = 1;
      validate_non_negative_index("a", "n_age", n_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> a;
      a = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age);
      
      current_statement__ = 1;
      a = in__.vector(n_age);
      current_statement__ = 2;
      validate_non_negative_index("b", "n_edu", n_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(n_edu);
      
      current_statement__ = 2;
      b = in__.vector(n_edu);
      current_statement__ = 3;
      validate_non_negative_index("c", "n_age_edu", n_age_edu);
      Eigen::Matrix<local_scalar_t__, -1, 1> c;
      c = Eigen::Matrix<local_scalar_t__, -1, 1>(n_age_edu);
      
      current_statement__ = 3;
      c = in__.vector(n_age_edu);
      current_statement__ = 4;
      validate_non_negative_index("d", "n_state", n_state);
      Eigen::Matrix<local_scalar_t__, -1, 1> d;
      d = Eigen::Matrix<local_scalar_t__, -1, 1>(n_state);
      
      current_statement__ = 4;
      d = in__.vector(n_state);
      current_statement__ = 5;
      validate_non_negative_index("e", "n_region_full", n_region_full);
      Eigen::Matrix<local_scalar_t__, -1, 1> e;
      e = Eigen::Matrix<local_scalar_t__, -1, 1>(n_region_full);
      
      current_statement__ = 5;
      e = in__.vector(n_region_full);
      current_statement__ = 6;
      validate_non_negative_index("beta", "5", 5);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(5);
      
      current_statement__ = 6;
      beta = in__.vector(5);
      local_scalar_t__ sigma_a;
      
      current_statement__ = 7;
      sigma_a = in__.scalar();
      current_statement__ = 7;
      if (jacobian__) {
        current_statement__ = 7;
        sigma_a = stan::math::lub_constrain(sigma_a, 0, 100, lp__);
      } else {
        current_statement__ = 7;
        sigma_a = stan::math::lub_constrain(sigma_a, 0, 100);
      }
      local_scalar_t__ sigma_b;
      
      current_statement__ = 8;
      sigma_b = in__.scalar();
      current_statement__ = 8;
      if (jacobian__) {
        current_statement__ = 8;
        sigma_b = stan::math::lub_constrain(sigma_b, 0, 100, lp__);
      } else {
        current_statement__ = 8;
        sigma_b = stan::math::lub_constrain(sigma_b, 0, 100);
      }
      local_scalar_t__ sigma_c;
      
      current_statement__ = 9;
      sigma_c = in__.scalar();
      current_statement__ = 9;
      if (jacobian__) {
        current_statement__ = 9;
        sigma_c = stan::math::lub_constrain(sigma_c, 0, 100, lp__);
      } else {
        current_statement__ = 9;
        sigma_c = stan::math::lub_constrain(sigma_c, 0, 100);
      }
      local_scalar_t__ sigma_d;
      
      current_statement__ = 10;
      sigma_d = in__.scalar();
      current_statement__ = 10;
      if (jacobian__) {
        current_statement__ = 10;
        sigma_d = stan::math::lub_constrain(sigma_d, 0, 100, lp__);
      } else {
        current_statement__ = 10;
        sigma_d = stan::math::lub_constrain(sigma_d, 0, 100);
      }
      local_scalar_t__ sigma_e;
      
      current_statement__ = 11;
      sigma_e = in__.scalar();
      current_statement__ = 11;
      if (jacobian__) {
        current_statement__ = 11;
        sigma_e = stan::math::lub_constrain(sigma_e, 0, 100, lp__);
      } else {
        current_statement__ = 11;
        sigma_e = stan::math::lub_constrain(sigma_e, 0, 100);
      }
      current_statement__ = 12;
      validate_non_negative_index("y_hat", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      lcm_sym56__ = logical_gte(N, 1);
      if (lcm_sym56__) {
        lcm_sym66__ = std::numeric_limits<double>::quiet_NaN();
        assign(y_hat, cons_list(index_uni(1), nil_index_list()), lcm_sym66__,
          "assigning variable y_hat");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 12;
          assign(y_hat, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym66__, "assigning variable y_hat");}
      } 
      current_statement__ = 14;
      if (lcm_sym56__) {
        current_statement__ = 13;
        assign(y_hat, cons_list(index_uni(1), nil_index_list()),
          (((((stan::math::fma(beta[(4 - 1)], v_prev_full[(1 - 1)],
                 stan::math::fma((beta[(5 - 1)] * female[(1 - 1)]),
                   black[(1 - 1)],
                   stan::math::fma(beta[(3 - 1)], female[(1 - 1)],
                     stan::math::fma(beta[(2 - 1)], black[(1 - 1)],
                       beta[(1 - 1)])))) + a[(age[(1 - 1)] - 1)]) +
               b[(edu[(1 - 1)] - 1)]) + c[(age_edu[(1 - 1)] - 1)]) +
             d[(state[(1 - 1)] - 1)]) + e[(region_full[(1 - 1)] - 1)]),
          "assigning variable y_hat");
        for (size_t i = 2; i <= N; ++i) {
          current_statement__ = 13;
          assign(y_hat, cons_list(index_uni(i), nil_index_list()),
            (((((stan::math::fma(beta[(4 - 1)], v_prev_full[(i - 1)],
                   stan::math::fma((beta[(5 - 1)] * female[(i - 1)]),
                     black[(i - 1)],
                     stan::math::fma(beta[(3 - 1)], female[(i - 1)],
                       stan::math::fma(beta[(2 - 1)], black[(i - 1)],
                         beta[(1 - 1)])))) + a[(age[(i - 1)] - 1)]) +
                 b[(edu[(i - 1)] - 1)]) + c[(age_edu[(i - 1)] - 1)]) +
               d[(state[(i - 1)] - 1)]) + e[(region_full[(i - 1)] - 1)]),
            "assigning variable y_hat");}
      } 
      {
        current_statement__ = 15;
        lp_accum__.add(normal_log<propto__>(a, 0, sigma_a));
        current_statement__ = 16;
        lp_accum__.add(normal_log<propto__>(b, 0, sigma_b));
        current_statement__ = 17;
        lp_accum__.add(normal_log<propto__>(c, 0, sigma_c));
        current_statement__ = 18;
        lp_accum__.add(normal_log<propto__>(d, 0, sigma_d));
        current_statement__ = 19;
        lp_accum__.add(normal_log<propto__>(e, 0, sigma_e));
        current_statement__ = 20;
        lp_accum__.add(normal_log<propto__>(beta, 0, 100));
        current_statement__ = 21;
        lp_accum__.add(bernoulli_logit_log<propto__>(y, y_hat));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail3_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym55__;
      double lcm_sym54__;
      double lcm_sym53__;
      double lcm_sym52__;
      double lcm_sym51__;
      double lcm_sym50__;
      double lcm_sym49__;
      double lcm_sym48__;
      double lcm_sym47__;
      double lcm_sym46__;
      double lcm_sym45__;
      double lcm_sym44__;
      double lcm_sym43__;
      double lcm_sym42__;
      double lcm_sym41__;
      double lcm_sym40__;
      double lcm_sym39__;
      int lcm_sym38__;
      int lcm_sym37__;
      int lcm_sym36__;
      int lcm_sym35__;
      int lcm_sym34__;
      int lcm_sym33__;
      int lcm_sym32__;
      int lcm_sym31__;
      current_statement__ = 1;
      validate_non_negative_index("a", "n_age", n_age);
      Eigen::Matrix<double, -1, 1> a;
      a = Eigen::Matrix<double, -1, 1>(n_age);
      
      current_statement__ = 1;
      a = in__.vector(n_age);
      current_statement__ = 2;
      validate_non_negative_index("b", "n_edu", n_edu);
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(n_edu);
      
      current_statement__ = 2;
      b = in__.vector(n_edu);
      current_statement__ = 3;
      validate_non_negative_index("c", "n_age_edu", n_age_edu);
      Eigen::Matrix<double, -1, 1> c;
      c = Eigen::Matrix<double, -1, 1>(n_age_edu);
      
      current_statement__ = 3;
      c = in__.vector(n_age_edu);
      current_statement__ = 4;
      validate_non_negative_index("d", "n_state", n_state);
      Eigen::Matrix<double, -1, 1> d;
      d = Eigen::Matrix<double, -1, 1>(n_state);
      
      current_statement__ = 4;
      d = in__.vector(n_state);
      current_statement__ = 5;
      validate_non_negative_index("e", "n_region_full", n_region_full);
      Eigen::Matrix<double, -1, 1> e;
      e = Eigen::Matrix<double, -1, 1>(n_region_full);
      
      current_statement__ = 5;
      e = in__.vector(n_region_full);
      current_statement__ = 6;
      validate_non_negative_index("beta", "5", 5);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(5);
      
      current_statement__ = 6;
      beta = in__.vector(5);
      double sigma_a;
      
      current_statement__ = 7;
      sigma_a = in__.scalar();
      current_statement__ = 7;
      sigma_a = stan::math::lub_constrain(sigma_a, 0, 100);
      double sigma_b;
      
      current_statement__ = 8;
      sigma_b = in__.scalar();
      current_statement__ = 8;
      sigma_b = stan::math::lub_constrain(sigma_b, 0, 100);
      double sigma_c;
      
      current_statement__ = 9;
      sigma_c = in__.scalar();
      current_statement__ = 9;
      sigma_c = stan::math::lub_constrain(sigma_c, 0, 100);
      double sigma_d;
      
      current_statement__ = 10;
      sigma_d = in__.scalar();
      current_statement__ = 10;
      sigma_d = stan::math::lub_constrain(sigma_d, 0, 100);
      double sigma_e;
      
      current_statement__ = 11;
      sigma_e = in__.scalar();
      current_statement__ = 11;
      sigma_e = stan::math::lub_constrain(sigma_e, 0, 100);
      current_statement__ = 12;
      validate_non_negative_index("y_hat", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      lcm_sym31__ = logical_gte(N, 1);
      if (lcm_sym31__) {
        lcm_sym41__ = std::numeric_limits<double>::quiet_NaN();
        assign(y_hat, cons_list(index_uni(1), nil_index_list()), lcm_sym41__,
          "assigning variable y_hat");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 12;
          assign(y_hat, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym41__, "assigning variable y_hat");}
      } 
      if (logical_gte(n_age, 1)) {
        vars__.push_back(a[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_age; ++sym1__) {
          vars__.push_back(a[(sym1__ - 1)]);}
      } 
      if (logical_gte(n_edu, 1)) {
        vars__.push_back(b[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          vars__.push_back(b[(sym1__ - 1)]);}
      } 
      if (logical_gte(n_age_edu, 1)) {
        vars__.push_back(c[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_age_edu; ++sym1__) {
          vars__.push_back(c[(sym1__ - 1)]);}
      } 
      if (logical_gte(n_state, 1)) {
        vars__.push_back(d[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          vars__.push_back(d[(sym1__ - 1)]);}
      } 
      if (logical_gte(n_region_full, 1)) {
        vars__.push_back(e[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_region_full; ++sym1__) {
          vars__.push_back(e[(sym1__ - 1)]);}
      } 
      {
        vars__.push_back(beta[(1 - 1)]);
        {
          vars__.push_back(beta[(2 - 1)]);
        }
        {
          vars__.push_back(beta[(3 - 1)]);
        }
        {
          vars__.push_back(beta[(4 - 1)]);
        }
        {
          vars__.push_back(beta[(5 - 1)]);
        }
      }
      vars__.push_back(sigma_a);
      vars__.push_back(sigma_b);
      vars__.push_back(sigma_c);
      vars__.push_back(sigma_d);
      vars__.push_back(sigma_e);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 14;
      if (lcm_sym31__) {
        current_statement__ = 13;
        assign(y_hat, cons_list(index_uni(1), nil_index_list()),
          (((((stan::math::fma(beta[(4 - 1)], v_prev_full[(1 - 1)],
                 stan::math::fma((beta[(5 - 1)] * female[(1 - 1)]),
                   black[(1 - 1)],
                   stan::math::fma(beta[(3 - 1)], female[(1 - 1)],
                     stan::math::fma(beta[(2 - 1)], black[(1 - 1)],
                       beta[(1 - 1)])))) + a[(age[(1 - 1)] - 1)]) +
               b[(edu[(1 - 1)] - 1)]) + c[(age_edu[(1 - 1)] - 1)]) +
             d[(state[(1 - 1)] - 1)]) + e[(region_full[(1 - 1)] - 1)]),
          "assigning variable y_hat");
        for (size_t i = 2; i <= N; ++i) {
          current_statement__ = 13;
          assign(y_hat, cons_list(index_uni(i), nil_index_list()),
            (((((stan::math::fma(beta[(4 - 1)], v_prev_full[(i - 1)],
                   stan::math::fma((beta[(5 - 1)] * female[(i - 1)]),
                     black[(i - 1)],
                     stan::math::fma(beta[(3 - 1)], female[(i - 1)],
                       stan::math::fma(beta[(2 - 1)], black[(i - 1)],
                         beta[(1 - 1)])))) + a[(age[(i - 1)] - 1)]) +
                 b[(edu[(i - 1)] - 1)]) + c[(age_edu[(i - 1)] - 1)]) +
               d[(state[(i - 1)] - 1)]) + e[(region_full[(i - 1)] - 1)]),
            "assigning variable y_hat");}
      } 
      if (lcm_sym31__) {
        vars__.push_back(y_hat[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(y_hat[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("a", "n_age", n_age);
      Eigen::Matrix<double, -1, 1> a;
      a = Eigen::Matrix<double, -1, 1>(n_age);
      
      {
        std::vector<double> a_flat__;
        current_statement__ = 1;
        assign(a_flat__, nil_index_list(), context__.vals_r("a"),
          "assigning variable a_flat__");
        current_statement__ = 1;
        pos__ = 1;
        lcm_sym1__ = logical_gte(n_age, 1);
        if (lcm_sym1__) {
          current_statement__ = 1;
          assign(a, cons_list(index_uni(1), nil_index_list()),
            a_flat__[(1 - 1)], "assigning variable a");
          current_statement__ = 1;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_age; ++sym1__) {
            current_statement__ = 1;
            assign(a, cons_list(index_uni(sym1__), nil_index_list()),
              a_flat__[(pos__ - 1)], "assigning variable a");
            current_statement__ = 1;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 2;
      validate_non_negative_index("b", "n_edu", n_edu);
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(n_edu);
      
      {
        std::vector<double> b_flat__;
        current_statement__ = 2;
        assign(b_flat__, nil_index_list(), context__.vals_r("b"),
          "assigning variable b_flat__");
        current_statement__ = 2;
        pos__ = 1;
        lcm_sym3__ = logical_gte(n_edu, 1);
        if (lcm_sym3__) {
          current_statement__ = 2;
          assign(b, cons_list(index_uni(1), nil_index_list()),
            b_flat__[(1 - 1)], "assigning variable b");
          current_statement__ = 2;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
            current_statement__ = 2;
            assign(b, cons_list(index_uni(sym1__), nil_index_list()),
              b_flat__[(pos__ - 1)], "assigning variable b");
            current_statement__ = 2;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 3;
      validate_non_negative_index("c", "n_age_edu", n_age_edu);
      Eigen::Matrix<double, -1, 1> c;
      c = Eigen::Matrix<double, -1, 1>(n_age_edu);
      
      {
        std::vector<double> c_flat__;
        current_statement__ = 3;
        assign(c_flat__, nil_index_list(), context__.vals_r("c"),
          "assigning variable c_flat__");
        current_statement__ = 3;
        pos__ = 1;
        lcm_sym2__ = logical_gte(n_age_edu, 1);
        if (lcm_sym2__) {
          current_statement__ = 3;
          assign(c, cons_list(index_uni(1), nil_index_list()),
            c_flat__[(1 - 1)], "assigning variable c");
          current_statement__ = 3;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_age_edu; ++sym1__) {
            current_statement__ = 3;
            assign(c, cons_list(index_uni(sym1__), nil_index_list()),
              c_flat__[(pos__ - 1)], "assigning variable c");
            current_statement__ = 3;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 4;
      validate_non_negative_index("d", "n_state", n_state);
      Eigen::Matrix<double, -1, 1> d;
      d = Eigen::Matrix<double, -1, 1>(n_state);
      
      {
        std::vector<double> d_flat__;
        current_statement__ = 4;
        assign(d_flat__, nil_index_list(), context__.vals_r("d"),
          "assigning variable d_flat__");
        current_statement__ = 4;
        pos__ = 1;
        lcm_sym5__ = logical_gte(n_state, 1);
        if (lcm_sym5__) {
          current_statement__ = 4;
          assign(d, cons_list(index_uni(1), nil_index_list()),
            d_flat__[(1 - 1)], "assigning variable d");
          current_statement__ = 4;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
            current_statement__ = 4;
            assign(d, cons_list(index_uni(sym1__), nil_index_list()),
              d_flat__[(pos__ - 1)], "assigning variable d");
            current_statement__ = 4;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 5;
      validate_non_negative_index("e", "n_region_full", n_region_full);
      Eigen::Matrix<double, -1, 1> e;
      e = Eigen::Matrix<double, -1, 1>(n_region_full);
      
      {
        std::vector<double> e_flat__;
        current_statement__ = 5;
        assign(e_flat__, nil_index_list(), context__.vals_r("e"),
          "assigning variable e_flat__");
        current_statement__ = 5;
        pos__ = 1;
        lcm_sym4__ = logical_gte(n_region_full, 1);
        if (lcm_sym4__) {
          current_statement__ = 5;
          assign(e, cons_list(index_uni(1), nil_index_list()),
            e_flat__[(1 - 1)], "assigning variable e");
          current_statement__ = 5;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_region_full; ++sym1__) {
            current_statement__ = 5;
            assign(e, cons_list(index_uni(sym1__), nil_index_list()),
              e_flat__[(pos__ - 1)], "assigning variable e");
            current_statement__ = 5;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 6;
      validate_non_negative_index("beta", "5", 5);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(5);
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 6;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 6;
        pos__ = 1;
        {
          current_statement__ = 6;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            beta_flat__[(1 - 1)], "assigning variable beta");
          current_statement__ = 6;
          pos__ = 2;
          {
            current_statement__ = 6;
            assign(beta, cons_list(index_uni(2), nil_index_list()),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 6;
            pos__ = (pos__ + 1);
          }
          {
            current_statement__ = 6;
            assign(beta, cons_list(index_uni(3), nil_index_list()),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 6;
            pos__ = (pos__ + 1);
          }
          {
            current_statement__ = 6;
            assign(beta, cons_list(index_uni(4), nil_index_list()),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 6;
            pos__ = (pos__ + 1);
          }
          {
            current_statement__ = 6;
            assign(beta, cons_list(index_uni(5), nil_index_list()),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 6;
            pos__ = (pos__ + 1);
          }
        }
      }
      double sigma_a;
      
      current_statement__ = 7;
      sigma_a = context__.vals_r("sigma_a")[(1 - 1)];
      current_statement__ = 7;
      sigma_a = stan::math::lub_free(sigma_a, 0, 100);
      double sigma_b;
      
      current_statement__ = 8;
      sigma_b = context__.vals_r("sigma_b")[(1 - 1)];
      current_statement__ = 8;
      sigma_b = stan::math::lub_free(sigma_b, 0, 100);
      double sigma_c;
      
      current_statement__ = 9;
      sigma_c = context__.vals_r("sigma_c")[(1 - 1)];
      current_statement__ = 9;
      sigma_c = stan::math::lub_free(sigma_c, 0, 100);
      double sigma_d;
      
      current_statement__ = 10;
      sigma_d = context__.vals_r("sigma_d")[(1 - 1)];
      current_statement__ = 10;
      sigma_d = stan::math::lub_free(sigma_d, 0, 100);
      double sigma_e;
      
      current_statement__ = 11;
      sigma_e = context__.vals_r("sigma_e")[(1 - 1)];
      current_statement__ = 11;
      sigma_e = stan::math::lub_free(sigma_e, 0, 100);
      if (lcm_sym1__) {
        vars__.push_back(a[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_age; ++sym1__) {
          vars__.push_back(a[(sym1__ - 1)]);}
      } 
      if (lcm_sym3__) {
        vars__.push_back(b[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_edu; ++sym1__) {
          vars__.push_back(b[(sym1__ - 1)]);}
      } 
      if (lcm_sym2__) {
        vars__.push_back(c[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_age_edu; ++sym1__) {
          vars__.push_back(c[(sym1__ - 1)]);}
      } 
      if (lcm_sym5__) {
        vars__.push_back(d[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_state; ++sym1__) {
          vars__.push_back(d[(sym1__ - 1)]);}
      } 
      if (lcm_sym4__) {
        vars__.push_back(e[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_region_full; ++sym1__) {
          vars__.push_back(e[(sym1__ - 1)]);}
      } 
      {
        vars__.push_back(beta[(1 - 1)]);
        {
          vars__.push_back(beta[(2 - 1)]);
        }
        {
          vars__.push_back(beta[(3 - 1)]);
        }
        {
          vars__.push_back(beta[(4 - 1)]);
        }
        {
          vars__.push_back(beta[(5 - 1)]);
        }
      }
      vars__.push_back(sigma_a);
      vars__.push_back(sigma_b);
      vars__.push_back(sigma_c);
      vars__.push_back(sigma_d);
      vars__.push_back(sigma_e);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("a");
    names__.push_back("b");
    names__.push_back("c");
    names__.push_back("d");
    names__.push_back("e");
    names__.push_back("beta");
    names__.push_back("sigma_a");
    names__.push_back("sigma_b");
    names__.push_back("sigma_c");
    names__.push_back("sigma_d");
    names__.push_back("sigma_e");
    names__.push_back("y_hat");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(n_age);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_edu);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_age_edu);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_state);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_region_full);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(5);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    for (size_t sym87__ = 1; sym87__ <= n_age; ++sym87__) {
      {
        param_names__.push_back(std::string() + "a" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= n_edu; ++sym87__) {
      {
        param_names__.push_back(std::string() + "b" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= n_age_edu; ++sym87__) {
      {
        param_names__.push_back(std::string() + "c" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= n_state; ++sym87__) {
      {
        param_names__.push_back(std::string() + "d" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= n_region_full; ++sym87__) {
      {
        param_names__.push_back(std::string() + "e" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= 5; ++sym87__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym87__));
      }}
    param_names__.push_back(std::string() + "sigma_a");
    param_names__.push_back(std::string() + "sigma_b");
    param_names__.push_back(std::string() + "sigma_c");
    param_names__.push_back(std::string() + "sigma_d");
    param_names__.push_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (size_t sym87__ = 1; sym87__ <= N; ++sym87__) {
        {
          param_names__.push_back(std::string() + "y_hat" + '.' + std::to_string(sym87__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    for (size_t sym87__ = 1; sym87__ <= n_age; ++sym87__) {
      {
        param_names__.push_back(std::string() + "a" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= n_edu; ++sym87__) {
      {
        param_names__.push_back(std::string() + "b" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= n_age_edu; ++sym87__) {
      {
        param_names__.push_back(std::string() + "c" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= n_state; ++sym87__) {
      {
        param_names__.push_back(std::string() + "d" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= n_region_full; ++sym87__) {
      {
        param_names__.push_back(std::string() + "e" + '.' + std::to_string(sym87__));
      }}
    for (size_t sym87__ = 1; sym87__ <= 5; ++sym87__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym87__));
      }}
    param_names__.push_back(std::string() + "sigma_a");
    param_names__.push_back(std::string() + "sigma_b");
    param_names__.push_back(std::string() + "sigma_c");
    param_names__.push_back(std::string() + "sigma_d");
    param_names__.push_back(std::string() + "sigma_e");
    if (emit_transformed_parameters__) {
      for (size_t sym87__ = 1; sym87__ <= N; ++sym87__) {
        {
          param_names__.push_back(std::string() + "y_hat" + '.' + std::to_string(sym87__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" << n_age << "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" << n_age_edu << "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" << n_state << "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" << n_region_full << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << 5 << "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" << n_age << "},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_edu << "},\"block\":\"parameters\"},{\"name\":\"c\",\"type\":{\"name\":\"vector\",\"length\":" << n_age_edu << "},\"block\":\"parameters\"},{\"name\":\"d\",\"type\":{\"name\":\"vector\",\"length\":" << n_state << "},\"block\":\"parameters\"},{\"name\":\"e\",\"type\":{\"name\":\"vector\",\"length\":" << n_region_full << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << 5 << "},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_b\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_c\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_d\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_e\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef expr_prop_fail3_model_namespace::expr_prop_fail3_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-fail4.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail4_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail4.stan', line 12, column 2 to column 24)",
                                                      " (in 'expr-prop-fail4.stan', line 13, column 2 to column 28)",
                                                      " (in 'expr-prop-fail4.stan', line 16, column 2 to column 47)",
                                                      " (in 'expr-prop-fail4.stan', line 17, column 2 to column 16)",
                                                      " (in 'expr-prop-fail4.stan', line 18, column 2 to column 31)",
                                                      " (in 'expr-prop-fail4.stan', line 19, column 2 to column 29)",
                                                      " (in 'expr-prop-fail4.stan', line 20, column 2 to column 24)",
                                                      " (in 'expr-prop-fail4.stan', line 27, column 2 to column 13)",
                                                      " (in 'expr-prop-fail4.stan', line 28, column 2 to column 13)",
                                                      " (in 'expr-prop-fail4.stan', line 29, column 2 to column 26)",
                                                      " (in 'expr-prop-fail4.stan', line 30, column 2 to column 28)",
                                                      " (in 'expr-prop-fail4.stan', line 31, column 2 to column 18)",
                                                      " (in 'expr-prop-fail4.stan', line 32, column 2 to column 22)",
                                                      " (in 'expr-prop-fail4.stan', line 34, column 2 to column 14)",
                                                      " (in 'expr-prop-fail4.stan', line 35, column 2 to column 11)",
                                                      " (in 'expr-prop-fail4.stan', line 37, column 2 to column 27)",
                                                      " (in 'expr-prop-fail4.stan', line 38, column 2 to column 27)",
                                                      " (in 'expr-prop-fail4.stan', line 40, column 4 to column 36)",
                                                      " (in 'expr-prop-fail4.stan', line 39, column 17 to line 41, column 3)",
                                                      " (in 'expr-prop-fail4.stan', line 39, column 2 to line 41, column 3)",
                                                      " (in 'expr-prop-fail4.stan', line 42, column 2 to column 38)",
                                                      " (in 'expr-prop-fail4.stan', line 47, column 4 to column 28)",
                                                      " (in 'expr-prop-fail4.stan', line 48, column 4 to column 80)",
                                                      " (in 'expr-prop-fail4.stan', line 46, column 17 to line 49, column 3)",
                                                      " (in 'expr-prop-fail4.stan', line 46, column 2 to line 49, column 3)",
                                                      " (in 'expr-prop-fail4.stan', line 23, column 2 to column 53)",
                                                      " (in 'expr-prop-fail4.stan', line 24, column 2 to column 24)",
                                                      " (in 'expr-prop-fail4.stan', line 2, column 2 to column 17)",
                                                      " (in 'expr-prop-fail4.stan', line 3, column 2 to column 23)",
                                                      " (in 'expr-prop-fail4.stan', line 4, column 2 to column 39)",
                                                      " (in 'expr-prop-fail4.stan', line 5, column 2 to column 39)",
                                                      " (in 'expr-prop-fail4.stan', line 6, column 2 to column 23)",
                                                      " (in 'expr-prop-fail4.stan', line 9, column 2 to column 27)"};



class expr_prop_fail4_model : public model_base_crtp<expr_prop_fail4_model> {

 private:
  int lcm_sym53__;
  int lcm_sym52__;
  int lcm_sym51__;
  int lcm_sym50__;
  double lcm_sym49__;
  double lcm_sym48__;
  double lcm_sym47__;
  Eigen::Matrix<double, -1, 1> lcm_sym46__;
  int lcm_sym45__;
  int lcm_sym44__;
  int lcm_sym43__;
  int pos__;
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  Eigen::Matrix<double, -1, 1> E;
  Eigen::Matrix<double, -1, 1> log_E;
 
 public:
  ~expr_prop_fail4_model() { }
  
  std::string model_name() const { return "expr_prop_fail4_model"; }
  
  expr_prop_fail4_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail4_model_namespace::expr_prop_fail4_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      
      current_statement__ = 28;
      N = context__.vals_i("N")[(1 - 1)];
      context__.validate_dims("data initialization","N_edges","int",
          context__.to_vec());
      
      current_statement__ = 29;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 30;
      validate_non_negative_index("node1", "N_edges", N_edges);
      context__.validate_dims("data initialization","node1","int",
          context__.to_vec(N_edges));
      node1 = std::vector<int>(N_edges, 0);
      
      current_statement__ = 30;
      assign(node1, nil_index_list(), context__.vals_i("node1"),
        "assigning variable node1");
      current_statement__ = 31;
      validate_non_negative_index("node2", "N_edges", N_edges);
      context__.validate_dims("data initialization","node2","int",
          context__.to_vec(N_edges));
      node2 = std::vector<int>(N_edges, 0);
      
      current_statement__ = 31;
      assign(node2, nil_index_list(), context__.vals_i("node2"),
        "assigning variable node2");
      current_statement__ = 32;
      validate_non_negative_index("E", "N", N);
      context__.validate_dims("data initialization","E","double",
          context__.to_vec(N));
      E = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> E_flat__;
        current_statement__ = 32;
        assign(E_flat__, nil_index_list(), context__.vals_r("E"),
          "assigning variable E_flat__");
        current_statement__ = 32;
        pos__ = 1;
        lcm_sym43__ = logical_gte(N, 1);
        if (lcm_sym43__) {
          current_statement__ = 32;
          assign(E, cons_list(index_uni(1), nil_index_list()),
            E_flat__[(1 - 1)], "assigning variable E");
          current_statement__ = 32;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 32;
            assign(E, cons_list(index_uni(sym1__), nil_index_list()),
              E_flat__[(pos__ - 1)], "assigning variable E");
            current_statement__ = 32;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 33;
      validate_non_negative_index("log_E", "N", N);
      log_E = Eigen::Matrix<double, -1, 1>(N);
      
      current_statement__ = 33;
      if (lcm_sym43__) {
        lcm_sym47__ = std::numeric_limits<double>::quiet_NaN();
        assign(log_E, cons_list(index_uni(1), nil_index_list()), lcm_sym47__,
          "assigning variable log_E");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 33;
          assign(log_E, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym47__, "assigning variable log_E");}
      } 
      current_statement__ = 33;
      assign(log_E, nil_index_list(), stan::math::log(E),
        "assigning variable log_E");
      current_statement__ = 28;
      current_statement__ = 28;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 29;
      current_statement__ = 29;
      check_greater_or_equal(function__, "N_edges", N_edges, 0);
      lcm_sym44__ = logical_gte(N_edges, 1);
      if (lcm_sym44__) {
        current_statement__ = 30;
        current_statement__ = 30;
        check_greater_or_equal(function__, "node1[sym1__]", node1[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_greater_or_equal(function__, "node1[sym1__]",
                                 node1[(sym1__ - 1)], 1);}
      } 
      current_statement__ = 30;
      if (lcm_sym44__) {
        current_statement__ = 30;
        current_statement__ = 30;
        check_less_or_equal(function__, "node1[sym1__]", node1[(1 - 1)], N);
        for (size_t sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 30;
          current_statement__ = 30;
          check_less_or_equal(function__, "node1[sym1__]",
                              node1[(sym1__ - 1)], N);}
      } 
      current_statement__ = 31;
      if (lcm_sym44__) {
        current_statement__ = 31;
        current_statement__ = 31;
        check_greater_or_equal(function__, "node2[sym1__]", node2[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 31;
          current_statement__ = 31;
          check_greater_or_equal(function__, "node2[sym1__]",
                                 node2[(sym1__ - 1)], 1);}
      } 
      current_statement__ = 31;
      if (lcm_sym44__) {
        current_statement__ = 31;
        current_statement__ = 31;
        check_less_or_equal(function__, "node2[sym1__]", node2[(1 - 1)], N);
        for (size_t sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 31;
          current_statement__ = 31;
          check_less_or_equal(function__, "node2[sym1__]",
                              node2[(sym1__ - 1)], N);}
      } 
      current_statement__ = 32;
      current_statement__ = 32;
      check_greater_or_equal(function__, "E", E, 0);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      current_statement__ = 2;
      validate_non_negative_index("phi_std_raw", "(N - 1)", (N - 1));
      num_params_r__ += (N - 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail4_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym41__;
      local_scalar_t__ lcm_sym40__;
      double lcm_sym39__;
      double lcm_sym38__;
      Eigen::Matrix<double, -1, 1> lcm_sym37__;
      double lcm_sym36__;
      int lcm_sym42__;
      int lcm_sym34__;
      local_scalar_t__ tau_phi;
      
      current_statement__ = 1;
      tau_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        tau_phi = stan::math::lb_constrain(tau_phi, 0, lp__);
      } else {
        current_statement__ = 1;
        tau_phi = stan::math::lb_constrain(tau_phi, 0);
      }
      lcm_sym42__ = (N - 1);
      validate_non_negative_index("phi_std_raw", "(N - 1)", lcm_sym42__);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym42__);
      
      current_statement__ = 2;
      phi_std_raw = in__.vector(lcm_sym42__);
      local_scalar_t__ sigma_phi;
      
      lcm_sym41__ = std::numeric_limits<double>::quiet_NaN();
      sigma_phi = lcm_sym41__;
      lcm_sym40__ = inv_sqrt(tau_phi);
      sigma_phi = lcm_sym40__;
      current_statement__ = 4;
      validate_non_negative_index("phi", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      current_statement__ = 4;
      if (logical_gte(N, 1)) {
        current_statement__ = 4;
        assign(phi, cons_list(index_uni(1), nil_index_list()), lcm_sym41__,
          "assigning variable phi");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 4;
          assign(phi, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym41__, "assigning variable phi");}
      } 
      current_statement__ = 5;
      assign(phi, cons_list(index_min_max(1, lcm_sym42__), nil_index_list()),
        phi_std_raw, "assigning variable phi");
      current_statement__ = 6;
      assign(phi, cons_list(index_uni(N), nil_index_list()),
        -sum(phi_std_raw), "assigning variable phi");
      current_statement__ = 7;
      assign(phi, nil_index_list(),
        multiply(stan::model::deep_copy(phi), lcm_sym40__),
        "assigning variable phi");
      current_statement__ = 3;
      current_statement__ = 3;
      check_greater_or_equal(function__, "sigma_phi", lcm_sym40__, 0);
      {
        current_statement__ = 26;
        lp_accum__.add(
          (-0.5 *
            dot_self(
              subtract(
                rvalue(phi, cons_list(index_multi(node1), nil_index_list()),
                  "phi"),
                rvalue(phi, cons_list(index_multi(node2), nil_index_list()),
                  "phi")))));
        current_statement__ = 27;
        lp_accum__.add(gamma_log<propto__>(tau_phi, 1, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail4_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym33__;
      double lcm_sym32__;
      int lcm_sym31__;
      int lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym20__;
      double lcm_sym17__;
      double lcm_sym16__;
      Eigen::Matrix<double, -1, 1> lcm_sym15__;
      Eigen::Matrix<double, -1, 1> lcm_sym14__;
      double lcm_sym19__;
      double lcm_sym18__;
      int lcm_sym13__;
      int lcm_sym12__;
      double lcm_sym11__;
      int lcm_sym21__;
      int lcm_sym9__;
      int lcm_sym8__;
      double tau_phi;
      
      current_statement__ = 1;
      tau_phi = in__.scalar();
      current_statement__ = 1;
      tau_phi = stan::math::lb_constrain(tau_phi, 0);
      lcm_sym21__ = (N - 1);
      validate_non_negative_index("phi_std_raw", "(N - 1)", lcm_sym21__);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<double, -1, 1>(lcm_sym21__);
      
      current_statement__ = 2;
      phi_std_raw = in__.vector(lcm_sym21__);
      double sigma_phi;
      
      lcm_sym20__ = std::numeric_limits<double>::quiet_NaN();
      sigma_phi = lcm_sym20__;
      current_statement__ = 4;
      validate_non_negative_index("phi", "N", N);
      Eigen::Matrix<double, -1, 1> phi;
      phi = Eigen::Matrix<double, -1, 1>(N);
      
      lcm_sym8__ = logical_gte(N, 1);
      if (lcm_sym8__) {
        current_statement__ = 4;
        assign(phi, cons_list(index_uni(1), nil_index_list()), lcm_sym20__,
          "assigning variable phi");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 4;
          assign(phi, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym20__, "assigning variable phi");}
      } 
      vars__.push_back(tau_phi);
      if (logical_gte(lcm_sym21__, 1)) {
        vars__.push_back(phi_std_raw[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= lcm_sym21__; ++sym1__) {
          vars__.push_back(phi_std_raw[(sym1__ - 1)]);}
      } 
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym16__ = inv_sqrt(tau_phi);
      sigma_phi = lcm_sym16__;
      current_statement__ = 5;
      assign(phi, cons_list(index_min_max(1, lcm_sym21__), nil_index_list()),
        phi_std_raw, "assigning variable phi");
      current_statement__ = 6;
      assign(phi, cons_list(index_uni(N), nil_index_list()),
        -sum(phi_std_raw), "assigning variable phi");
      current_statement__ = 7;
      assign(phi, nil_index_list(),
        multiply(stan::model::deep_copy(phi), lcm_sym16__),
        "assigning variable phi");
      vars__.push_back(lcm_sym16__);
      if (lcm_sym8__) {
        vars__.push_back(phi[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(phi[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double beta0;
      
      current_statement__ = 8;
      beta0 = lcm_sym20__;
      double beta1;
      
      current_statement__ = 9;
      beta1 = lcm_sym20__;
      double tau_theta;
      
      current_statement__ = 10;
      tau_theta = lcm_sym20__;
      double sigma_theta;
      
      current_statement__ = 11;
      sigma_theta = lcm_sym20__;
      current_statement__ = 12;
      validate_non_negative_index("theta", "N", N);
      Eigen::Matrix<double, -1, 1> theta;
      theta = Eigen::Matrix<double, -1, 1>(N);
      
      current_statement__ = 12;
      if (lcm_sym8__) {
        current_statement__ = 12;
        assign(theta, cons_list(index_uni(1), nil_index_list()), lcm_sym20__,
          "assigning variable theta");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 12;
          assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym20__, "assigning variable theta");}
      } 
      current_statement__ = 13;
      validate_non_negative_index("theta_std", "N", N);
      Eigen::Matrix<double, -1, 1> theta_std;
      theta_std = Eigen::Matrix<double, -1, 1>(N);
      
      current_statement__ = 13;
      if (lcm_sym8__) {
        current_statement__ = 13;
        assign(theta_std, cons_list(index_uni(1), nil_index_list()),
          lcm_sym20__, "assigning variable theta_std");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 13;
          assign(theta_std, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym20__, "assigning variable theta_std");}
      } 
      current_statement__ = 14;
      validate_non_negative_index("x", "N", N);
      Eigen::Matrix<double, -1, 1> x;
      x = Eigen::Matrix<double, -1, 1>(N);
      
      current_statement__ = 14;
      if (lcm_sym8__) {
        current_statement__ = 14;
        assign(x, cons_list(index_uni(1), nil_index_list()), lcm_sym20__,
          "assigning variable x");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 14;
          assign(x, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym20__, "assigning variable x");}
      } 
      current_statement__ = 15;
      validate_non_negative_index("y", "N", N);
      std::vector<int> y;
      y = std::vector<int>(N, 0);
      
      current_statement__ = 16;
      beta0 = normal_rng(0, 1, base_rng__);
      current_statement__ = 17;
      beta1 = normal_rng(0, 1, base_rng__);
      current_statement__ = 20;
      if (lcm_sym8__) {
        current_statement__ = 18;
        assign(theta_std, cons_list(index_uni(1), nil_index_list()),
          normal_rng(0, 1, base_rng__), "assigning variable theta_std");
        for (size_t i = 2; i <= N; ++i) {
          current_statement__ = 18;
          assign(theta_std, cons_list(index_uni(i), nil_index_list()),
            normal_rng(0, 1, base_rng__), "assigning variable theta_std");}
      } 
      current_statement__ = 21;
      tau_theta = gamma_rng(3.2761, 1.81, base_rng__);
      lcm_sym17__ = inv_sqrt(tau_theta);
      sigma_theta = lcm_sym17__;
      assign(lcm_sym15__, nil_index_list(), multiply(theta_std, lcm_sym17__),
        "assigning variable lcm_sym15__");
      assign(theta, nil_index_list(), lcm_sym15__, "assigning variable theta");
      current_statement__ = 25;
      if (lcm_sym8__) {
        current_statement__ = 22;
        assign(x, cons_list(index_uni(1), nil_index_list()),
          normal_rng(0, 1, base_rng__), "assigning variable x");
        current_statement__ = 23;
        assign(y, cons_list(index_uni(1), nil_index_list()),
          poisson_log_rng(
            ((stan::math::fma(beta1, x[(1 - 1)],
                (stan::math::log(E)[(1 - 1)] + beta0)) + phi[(1 - 1)]) +
              lcm_sym15__[(1 - 1)]), base_rng__), "assigning variable y");
        for (size_t i = 2; i <= N; ++i) {
          current_statement__ = 22;
          assign(x, cons_list(index_uni(i), nil_index_list()),
            normal_rng(0, 1, base_rng__), "assigning variable x");
          current_statement__ = 23;
          assign(y, cons_list(index_uni(i), nil_index_list()),
            poisson_log_rng(
              ((stan::math::fma(beta1, x[(i - 1)],
                  (stan::math::log(E)[(i - 1)] + beta0)) + phi[(i - 1)]) +
                lcm_sym15__[(i - 1)]), base_rng__), "assigning variable y");}
      } 
      current_statement__ = 10;
      current_statement__ = 10;
      check_greater_or_equal(function__, "tau_theta", tau_theta, 0);
      current_statement__ = 11;
      current_statement__ = 11;
      check_greater_or_equal(function__, "sigma_theta", lcm_sym17__, 0);
      vars__.push_back(beta0);
      vars__.push_back(beta1);
      vars__.push_back(tau_theta);
      vars__.push_back(lcm_sym17__);
      if (lcm_sym8__) {
        vars__.push_back(lcm_sym15__[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(lcm_sym15__[(sym1__ - 1)]);}
      } 
      if (lcm_sym8__) {
        vars__.push_back(theta_std[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(theta_std[(sym1__ - 1)]);}
      } 
      if (lcm_sym8__) {
        vars__.push_back(x[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(x[(sym1__ - 1)]);}
      } 
      if (lcm_sym8__) {
        vars__.push_back(y[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(y[(sym1__ - 1)]);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      double tau_phi;
      
      current_statement__ = 1;
      tau_phi = context__.vals_r("tau_phi")[(1 - 1)];
      current_statement__ = 1;
      tau_phi = stan::math::lb_free(tau_phi, 0);
      lcm_sym2__ = (N - 1);
      validate_non_negative_index("phi_std_raw", "(N - 1)", lcm_sym2__);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<double, -1, 1>(lcm_sym2__);
      
      {
        std::vector<double> phi_std_raw_flat__;
        current_statement__ = 2;
        assign(phi_std_raw_flat__, nil_index_list(),
          context__.vals_r("phi_std_raw"),
          "assigning variable phi_std_raw_flat__");
        current_statement__ = 2;
        pos__ = 1;
        lcm_sym1__ = logical_gte(lcm_sym2__, 1);
        if (lcm_sym1__) {
          current_statement__ = 2;
          assign(phi_std_raw, cons_list(index_uni(1), nil_index_list()),
            phi_std_raw_flat__[(1 - 1)], "assigning variable phi_std_raw");
          current_statement__ = 2;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= lcm_sym2__; ++sym1__) {
            current_statement__ = 2;
            assign(phi_std_raw,
              cons_list(index_uni(sym1__), nil_index_list()),
              phi_std_raw_flat__[(pos__ - 1)],
              "assigning variable phi_std_raw");
            current_statement__ = 2;
            pos__ = (pos__ + 1);}
        } 
      }
      vars__.push_back(tau_phi);
      if (lcm_sym1__) {
        vars__.push_back(phi_std_raw[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= lcm_sym2__; ++sym1__) {
          vars__.push_back(phi_std_raw[(sym1__ - 1)]);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("tau_phi");
    names__.push_back("phi_std_raw");
    names__.push_back("sigma_phi");
    names__.push_back("phi");
    names__.push_back("beta0");
    names__.push_back("beta1");
    names__.push_back("tau_theta");
    names__.push_back("sigma_theta");
    names__.push_back("theta");
    names__.push_back("theta_std");
    names__.push_back("x");
    names__.push_back("y");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back((N - 1));
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "tau_phi");
    for (size_t sym54__ = 1; sym54__ <= (N - 1); ++sym54__) {
      {
        param_names__.push_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym54__));
      }}
    if (emit_transformed_parameters__) {
      param_names__.push_back(std::string() + "sigma_phi");
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym54__));
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "beta0");
      param_names__.push_back(std::string() + "beta1");
      param_names__.push_back(std::string() + "tau_theta");
      param_names__.push_back(std::string() + "sigma_theta");
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym54__));
        }}
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "theta_std" + '.' + std::to_string(sym54__));
        }}
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "x" + '.' + std::to_string(sym54__));
        }}
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "y" + '.' + std::to_string(sym54__));
        }}
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "tau_phi");
    for (size_t sym54__ = 1; sym54__ <= (N - 1); ++sym54__) {
      {
        param_names__.push_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym54__));
      }}
    if (emit_transformed_parameters__) {
      param_names__.push_back(std::string() + "sigma_phi");
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym54__));
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "beta0");
      param_names__.push_back(std::string() + "beta1");
      param_names__.push_back(std::string() + "tau_theta");
      param_names__.push_back(std::string() + "sigma_theta");
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym54__));
        }}
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "theta_std" + '.' + std::to_string(sym54__));
        }}
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "x" + '.' + std::to_string(sym54__));
        }}
      for (size_t sym54__ = 1; sym54__ <= N; ++sym54__) {
        {
          param_names__.push_back(std::string() + "y" + '.' + std::to_string(sym54__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" << (N - 1) << "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"sigma_theta\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"theta\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"x\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"generated_quantities\"},{\"name\":\"y\",\"type\":{\"name\":\"array\",\"length\":" << N << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef expr_prop_fail4_model_namespace::expr_prop_fail4_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-fail5.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail5_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail5.stan', line 71, column 2 to column 33)",
                                                      " (in 'expr-prop-fail5.stan', line 72, column 2 to column 31)",
                                                      " (in 'expr-prop-fail5.stan', line 73, column 2 to column 23)",
                                                      " (in 'expr-prop-fail5.stan', line 74, column 2 to column 30)",
                                                      " (in 'expr-prop-fail5.stan', line 80, column 2 to column 51)",
                                                      " (in 'expr-prop-fail5.stan', line 81, column 2 to column 49)",
                                                      " (in 'expr-prop-fail5.stan', line 82, column 2 to column 49)",
                                                      " (in 'expr-prop-fail5.stan', line 83, column 2 to column 10)",
                                                      " (in 'expr-prop-fail5.stan', line 89, column 6 to column 20)",
                                                      " (in 'expr-prop-fail5.stan', line 90, column 6 to column 18)",
                                                      " (in 'expr-prop-fail5.stan', line 88, column 32 to line 91, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 93, column 6 to column 45)",
                                                      " (in 'expr-prop-fail5.stan', line 94, column 6 to column 23)",
                                                      " (in 'expr-prop-fail5.stan', line 92, column 38 to line 95, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 92, column 4 to line 95, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 87, column 20 to line 96, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 87, column 2 to line 96, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 26, column 4 to column 34)",
                                                      " (in 'expr-prop-fail5.stan', line 29, column 6 to column 32)",
                                                      " (in 'expr-prop-fail5.stan', line 32, column 8 to column 37)",
                                                      " (in 'expr-prop-fail5.stan', line 33, column 8 to column 32)",
                                                      " (in 'expr-prop-fail5.stan', line 43, column 8 to line 44, column 83)",
                                                      " (in 'expr-prop-fail5.stan', line 30, column 37 to line 45, column 7)",
                                                      " (in 'expr-prop-fail5.stan', line 28, column 22 to line 46, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 25, column 47 to line 48, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 124, column 2 to column 23)",
                                                      " (in 'expr-prop-fail5.stan', line 109, column 2 to column 29)",
                                                      " (in 'expr-prop-fail5.stan', line 115, column 8 to column 37)",
                                                      " (in 'expr-prop-fail5.stan', line 116, column 8 to column 41)",
                                                      " (in 'expr-prop-fail5.stan', line 114, column 40 to line 117, column 7)",
                                                      " (in 'expr-prop-fail5.stan', line 118, column 6 to column 37)",
                                                      " (in 'expr-prop-fail5.stan', line 113, column 22 to line 119, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 112, column 20 to line 120, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 112, column 2 to line 120, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 52, column 2 to column 20)",
                                                      " (in 'expr-prop-fail5.stan', line 53, column 2 to column 27)",
                                                      " (in 'expr-prop-fail5.stan', line 54, column 2 to column 44)",
                                                      " (in 'expr-prop-fail5.stan', line 58, column 2 to column 38)",
                                                      " (in 'expr-prop-fail5.stan', line 60, column 2 to column 45)",
                                                      " (in 'expr-prop-fail5.stan', line 61, column 2 to column 44)",
                                                      " (in 'expr-prop-fail5.stan', line 8, column 8 to column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 7, column 6 to line 8, column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 5, column 31 to line 10, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 65, column 4 to column 35)",
                                                      " (in 'expr-prop-fail5.stan', line 64, column 2 to line 65, column 35)",
                                                      " (in 'expr-prop-fail5.stan', line 15, column 6 to column 32)",
                                                      " (in 'expr-prop-fail5.stan', line 19, column 8 to column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 18, column 6 to line 19, column 17)",
                                                      " (in 'expr-prop-fail5.stan', line 13, column 37 to line 20, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 12, column 30 to line 22, column 3)",
                                                      " (in 'expr-prop-fail5.stan', line 67, column 4 to column 33)",
                                                      " (in 'expr-prop-fail5.stan', line 66, column 2 to line 67, column 33)",
                                                      " (in 'expr-prop-fail5.stan', line 9, column 4 to column 13)",
                                                      " (in 'expr-prop-fail5.stan', line 21, column 4 to column 13)",
                                                      " (in 'expr-prop-fail5.stan', line 30, column 6 to line 45, column 7)",
                                                      " (in 'expr-prop-fail5.stan', line 28, column 4 to line 46, column 5)",
                                                      " (in 'expr-prop-fail5.stan', line 47, column 4 to column 15)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym33__;
    int lcm_sym32__;
    int lcm_sym31__;
    int lcm_sym30__;
    {
      lcm_sym31__ = size(y_i);
      if (logical_gte(lcm_sym31__, 1)) {
        current_statement__ = 42;
        if (y_i[(1 - 1)]) {
          current_statement__ = 41;
          return 1;
        } 
        for (size_t k = 2; k <= lcm_sym31__; ++k) {
          current_statement__ = 42;
          if (y_i[(k - 1)]) {
            current_statement__ = 41;
            return k;
          } }
      } 
      current_statement__ = 53;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym39__;
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    int lcm_sym35__;
    int lcm_sym34__;
    {
      lcm_sym37__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym37__, 0)) {
        int k;
        
        lcm_sym36__ = (size(y_i) - 0);
        current_statement__ = 48;
        if (y_i[(lcm_sym36__ - 1)]) {
          current_statement__ = 47;
          return lcm_sym36__;
        } 
        for (size_t k_rev = 1; k_rev <= lcm_sym37__; ++k_rev) {
          int k;
          
          lcm_sym35__ = (size(y_i) - k_rev);
          current_statement__ = 48;
          if (y_i[(lcm_sym35__ - 1)]) {
            current_statement__ = 47;
            return lcm_sym35__;
          } }
      } 
      current_statement__ = 54;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__,
T3__>::type, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions,
                const Eigen::Matrix<T2__, -1, -1>& p,
                const Eigen::Matrix<T3__, -1, -1>& phi,
                std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T2__,
          T3__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    double lcm_sym51__;
    double lcm_sym50__;
    double lcm_sym49__;
    double lcm_sym48__;
    double lcm_sym47__;
    int lcm_sym46__;
    int lcm_sym45__;
    int lcm_sym44__;
    int lcm_sym43__;
    int lcm_sym42__;
    int lcm_sym41__;
    int lcm_sym40__;
    {
      current_statement__ = 18;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 18;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      lcm_sym41__ = logical_gte(nind, 1);
      if (lcm_sym41__) {
        lcm_sym40__ = logical_gte(n_occasions, 1);
        if (lcm_sym40__) {
          lcm_sym51__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym51__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 18;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym51__,
              "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 18;
          if (lcm_sym40__) {
            lcm_sym51__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym51__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 18;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym51__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 56;
      if (lcm_sym41__) {
        current_statement__ = 19;
        assign(chi,
          cons_list(index_uni(1),
            cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
          "assigning variable chi");
        lcm_sym44__ = (n_occasions - 1);
        lcm_sym42__ = logical_gte(lcm_sym44__, 1);
        if (lcm_sym42__) {
          int t_curr;
          
          int t_next;
          
          lcm_sym46__ = (lcm_sym44__ + 1);
          current_statement__ = 22;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym44__), nil_index_list())),
            stan::math::fma(
              (rvalue(phi,
                 cons_list(index_uni(1),
                   cons_list(index_uni(lcm_sym44__), nil_index_list())),
                 "phi") *
                (1 -
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym46__ - 1)),
                        nil_index_list())), "p"))),
              rvalue(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(lcm_sym46__), nil_index_list())),
                "chi"),
              (1 -
                rvalue(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym44__), nil_index_list())),
                  "phi"))), "assigning variable chi");
          for (size_t t = 2; t <= lcm_sym44__; ++t) {
            int t_curr;
            
            lcm_sym43__ = (n_occasions - t);
            int t_next;
            
            lcm_sym45__ = (lcm_sym43__ + 1);
            current_statement__ = 22;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(lcm_sym43__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(1),
                     cons_list(index_uni(lcm_sym43__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((lcm_sym45__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(chi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym45__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym43__), nil_index_list())),
                    "phi"))), "assigning variable chi");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          current_statement__ = 19;
          assign(chi,
            cons_list(index_uni(i),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable chi");
          current_statement__ = 55;
          if (lcm_sym42__) {
            int t_curr;
            
            int t_next;
            
            lcm_sym46__ = (lcm_sym44__ + 1);
            current_statement__ = 22;
            assign(chi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym44__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(i),
                     cons_list(index_uni(lcm_sym44__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym46__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(lcm_sym46__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym44__), nil_index_list())),
                    "phi"))), "assigning variable chi");
            for (size_t t = 2; t <= lcm_sym44__; ++t) {
              int t_curr;
              
              lcm_sym43__ = (n_occasions - t);
              int t_next;
              
              lcm_sym45__ = (lcm_sym43__ + 1);
              current_statement__ = 22;
              assign(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(lcm_sym43__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_uni(lcm_sym43__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni((lcm_sym45__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(chi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym45__), nil_index_list())),
                    "chi"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym43__), nil_index_list())),
                      "phi"))), "assigning variable chi");}
          } }
      } 
      current_statement__ = 57;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__,
T3__>::type, -1, -1>
operator()(const int& nind, const int& n_occasions,
           const Eigen::Matrix<T2__, -1, -1>& p,
           const Eigen::Matrix<T3__, -1, -1>& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

class expr_prop_fail5_model : public model_base_crtp<expr_prop_fail5_model> {

 private:
  int lcm_sym163__;
  int lcm_sym162__;
  int lcm_sym161__;
  int lcm_sym160__;
  int lcm_sym159__;
  int lcm_sym158__;
  int lcm_sym157__;
  int lcm_sym156__;
  int lcm_sym155__;
  int lcm_sym154__;
  int lcm_sym153__;
  int lcm_sym152__;
  int lcm_sym151__;
  int lcm_sym150__;
  int lcm_sym149__;
  int lcm_sym148__;
  int lcm_sym147__;
  int lcm_sym146__;
  int lcm_sym145__;
  int lcm_sym144__;
  int lcm_sym143__;
  int lcm_sym142__;
  int lcm_sym141__;
  int lcm_sym140__;
  int pos__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~expr_prop_fail5_model() { }
  
  std::string model_name() const { return "expr_prop_fail5_model"; }
  
  expr_prop_fail5_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail5_model_namespace::expr_prop_fail5_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","nind","int",
          context__.to_vec());
      
      current_statement__ = 35;
      nind = context__.vals_i("nind")[(1 - 1)];
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      
      current_statement__ = 36;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 37;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 37;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(nind, n_occasions));
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, 0));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 37;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 37;
        pos__ = 1;
        lcm_sym140__ = logical_gte(n_occasions, 1);
        if (lcm_sym140__) {
          {
            lcm_sym141__ = logical_gte(nind, 1);
            if (lcm_sym141__) {
              current_statement__ = 37;
              assign(y,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())),
                y_flat__[(1 - 1)], "assigning variable y");
              current_statement__ = 37;
              pos__ = 2;
              for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 37;
                assign(y,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(1), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 37;
                pos__ = (pos__ + 1);}
            } 
            for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 37;
              if (lcm_sym141__) {
                current_statement__ = 37;
                assign(y,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 37;
                pos__ = (pos__ + 1);
                for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                  current_statement__ = 37;
                  assign(y,
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list())),
                    y_flat__[(pos__ - 1)], "assigning variable y");
                  current_statement__ = 37;
                  pos__ = (pos__ + 1);}
              } }
          }
        } else {
          lcm_sym141__ = logical_gte(nind, 1);
        }
      }
      
      current_statement__ = 38;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 39;
      validate_non_negative_index("first", "nind", nind);
      first = std::vector<int>(nind, 0);
      
      current_statement__ = 40;
      validate_non_negative_index("last", "nind", nind);
      last = std::vector<int>(nind, 0);
      
      current_statement__ = 45;
      if (lcm_sym141__) {
        int inline_sym21__;
        int inline_sym23__;
        
        inline_sym23__ = 0;
        for (size_t inline_sym24__ = 1; inline_sym24__ <= 1; ++inline_sym24__) {
          lcm_sym149__ = size(y[(1 - 1)]);
          for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym149__;
               ++inline_sym22__) {
            current_statement__ = 42;
            if (y[(1 - 1)][(inline_sym22__ - 1)]) {
              inline_sym23__ = 1;
              inline_sym21__ = inline_sym22__;
              break;
            } }
          if (inline_sym23__) {
            break;
          } 
          inline_sym23__ = 1;
          inline_sym21__ = 0;
          break;}
        assign(first, cons_list(index_uni(1), nil_index_list()),
          inline_sym21__, "assigning variable first");
        for (size_t i = 2; i <= nind; ++i) {
          int inline_sym21__;
          int inline_sym23__;
          
          inline_sym23__ = 0;
          for (size_t inline_sym24__ = 1; inline_sym24__ <= 1;
               ++inline_sym24__) {
            lcm_sym148__ = size(y[(i - 1)]);
            for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym148__;
                 ++inline_sym22__) {
              current_statement__ = 42;
              if (y[(i - 1)][(inline_sym22__ - 1)]) {
                inline_sym23__ = 1;
                inline_sym21__ = inline_sym22__;
                break;
              } }
            if (inline_sym23__) {
              break;
            } 
            inline_sym23__ = 1;
            inline_sym21__ = 0;
            break;}
          assign(first, cons_list(index_uni(i), nil_index_list()),
            inline_sym21__, "assigning variable first");}
      } 
      current_statement__ = 52;
      if (lcm_sym141__) {
        int inline_sym25__;
        int inline_sym28__;
        
        inline_sym28__ = 0;
        for (size_t inline_sym29__ = 1; inline_sym29__ <= 1; ++inline_sym29__) {
          lcm_sym149__ = size(y[(1 - 1)]);
          lcm_sym146__ = (lcm_sym149__ - 1);
          for (size_t inline_sym27__ = 0; inline_sym27__ <= lcm_sym146__;
               ++inline_sym27__) {
            int inline_sym26__;
            
            lcm_sym145__ = (lcm_sym149__ - inline_sym27__);
            inline_sym26__ = lcm_sym145__;
            current_statement__ = 48;
            if (y[(1 - 1)][(lcm_sym145__ - 1)]) {
              inline_sym28__ = 1;
              inline_sym25__ = lcm_sym145__;
              break;
            } }
          if (inline_sym28__) {
            break;
          } 
          inline_sym28__ = 1;
          inline_sym25__ = 0;
          break;}
        assign(last, cons_list(index_uni(1), nil_index_list()),
          inline_sym25__, "assigning variable last");
        for (size_t i = 2; i <= nind; ++i) {
          int inline_sym25__;
          int inline_sym28__;
          
          inline_sym28__ = 0;
          for (size_t inline_sym29__ = 1; inline_sym29__ <= 1;
               ++inline_sym29__) {
            lcm_sym148__ = size(y[(i - 1)]);
            lcm_sym144__ = (lcm_sym148__ - 1);
            for (size_t inline_sym27__ = 0; inline_sym27__ <= lcm_sym144__;
                 ++inline_sym27__) {
              int inline_sym26__;
              
              lcm_sym143__ = (lcm_sym148__ - inline_sym27__);
              inline_sym26__ = lcm_sym143__;
              current_statement__ = 48;
              if (y[(i - 1)][(lcm_sym143__ - 1)]) {
                inline_sym28__ = 1;
                inline_sym25__ = lcm_sym143__;
                break;
              } }
            if (inline_sym28__) {
              break;
            } 
            inline_sym28__ = 1;
            inline_sym25__ = 0;
            break;}
          assign(last, cons_list(index_uni(i), nil_index_list()),
            inline_sym25__, "assigning variable last");}
      } 
      current_statement__ = 35;
      current_statement__ = 35;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 36;
      current_statement__ = 36;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 37;
      if (lcm_sym141__) {
        current_statement__ = 37;
        if (lcm_sym140__) {
          current_statement__ = 37;
          current_statement__ = 37;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 37;
            current_statement__ = 37;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 37;
          if (lcm_sym140__) {
            current_statement__ = 37;
            current_statement__ = 37;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 37;
              current_statement__ = 37;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 37;
      if (lcm_sym141__) {
        current_statement__ = 37;
        if (lcm_sym140__) {
          current_statement__ = 37;
          current_statement__ = 37;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 37;
            current_statement__ = 37;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 37;
          if (lcm_sym140__) {
            current_statement__ = 37;
            current_statement__ = 37;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 37;
              current_statement__ = 37;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      current_statement__ = 39;
      if (lcm_sym141__) {
        current_statement__ = 39;
        current_statement__ = 39;
        check_greater_or_equal(function__, "first[sym1__]", first[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 39;
          current_statement__ = 39;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 39;
      if (lcm_sym141__) {
        current_statement__ = 39;
        current_statement__ = 39;
        check_less_or_equal(function__, "first[sym1__]", first[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 39;
          current_statement__ = 39;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);}
      } 
      current_statement__ = 40;
      if (lcm_sym141__) {
        current_statement__ = 40;
        current_statement__ = 40;
        check_greater_or_equal(function__, "last[sym1__]", last[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 40;
          current_statement__ = 40;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 40;
      if (lcm_sym141__) {
        current_statement__ = 40;
        current_statement__ = 40;
        check_less_or_equal(function__, "last[sym1__]", last[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 40;
          current_statement__ = 40;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 3;
      validate_non_negative_index("epsilon", "nind", nind);
      num_params_r__ += nind;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail5_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      int lcm_sym139__;
      int lcm_sym138__;
      int lcm_sym137__;
      int lcm_sym136__;
      double lcm_sym135__;
      double lcm_sym134__;
      local_scalar_t__ lcm_sym133__;
      local_scalar_t__ lcm_sym132__;
      local_scalar_t__ lcm_sym131__;
      double lcm_sym130__;
      double lcm_sym129__;
      double lcm_sym128__;
      double lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      double lcm_sym124__;
      double lcm_sym123__;
      double lcm_sym122__;
      double lcm_sym121__;
      double lcm_sym120__;
      double lcm_sym119__;
      int lcm_sym118__;
      int lcm_sym117__;
      int lcm_sym116__;
      int lcm_sym115__;
      int lcm_sym114__;
      int lcm_sym113__;
      int lcm_sym112__;
      int lcm_sym111__;
      int lcm_sym110__;
      int lcm_sym109__;
      int lcm_sym108__;
      int lcm_sym107__;
      int lcm_sym106__;
      int lcm_sym105__;
      int lcm_sym104__;
      int lcm_sym103__;
      int lcm_sym102__;
      int lcm_sym101__;
      int lcm_sym100__;
      int lcm_sym99__;
      int lcm_sym98__;
      local_scalar_t__ mean_phi;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      }
      local_scalar_t__ mean_p;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      current_statement__ = 3;
      validate_non_negative_index("epsilon", "nind", nind);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>(nind);
      
      current_statement__ = 3;
      epsilon = in__.vector(nind);
      local_scalar_t__ sigma;
      
      current_statement__ = 4;
      sigma = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        sigma = stan::math::lub_constrain(sigma, 0, 5, lp__);
      } else {
        current_statement__ = 4;
        sigma = stan::math::lub_constrain(sigma, 0, 5);
      }
      current_statement__ = 5;
      validate_non_negative_index("phi", "nind", nind);
      lcm_sym110__ = (n_occasions - 1);
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym110__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym110__);
      
      lcm_sym99__ = logical_gte(nind, 1);
      if (lcm_sym99__) {
        {
          lcm_sym100__ = logical_gte(lcm_sym110__, 1);
          if (lcm_sym100__) {
            {
              lcm_sym135__ = std::numeric_limits<double>::quiet_NaN();
              assign(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym135__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym110__; ++sym2__) {
                current_statement__ = 5;
                assign(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym135__, "assigning variable phi");}
            }
          } else {
            lcm_sym135__ = std::numeric_limits<double>::quiet_NaN();
          }
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 5;
            if (lcm_sym100__) {
              current_statement__ = 5;
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym135__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym110__; ++sym2__) {
                current_statement__ = 5;
                assign(phi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym135__, "assigning variable phi");}
            } }
        }
      } else {
        lcm_sym135__ = std::numeric_limits<double>::quiet_NaN();
      }
      current_statement__ = 6;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 6;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym110__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym110__);
      
      current_statement__ = 6;
      if (lcm_sym99__) {
        lcm_sym100__ = logical_gte(lcm_sym110__, 1);
        if (lcm_sym100__) {
          current_statement__ = 6;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym135__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym110__; ++sym2__) {
            current_statement__ = 6;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym135__, "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym100__) {
            current_statement__ = 6;
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym135__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym110__; ++sym2__) {
              current_statement__ = 6;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym135__, "assigning variable p");}
          } }
      } 
      current_statement__ = 7;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 7;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      current_statement__ = 7;
      if (lcm_sym99__) {
        lcm_sym98__ = logical_gte(n_occasions, 1);
        if (lcm_sym98__) {
          current_statement__ = 7;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym135__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym135__, "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym98__) {
            current_statement__ = 7;
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym135__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym135__, "assigning variable chi");}
          } }
      } 
      local_scalar_t__ mu;
      
      current_statement__ = 8;
      mu = lcm_sym135__;
      lcm_sym133__ = logit(mean_phi);
      mu = lcm_sym133__;
      current_statement__ = 17;
      if (lcm_sym99__) {
        lcm_sym137__ = first[(1 - 1)];
        lcm_sym112__ = (lcm_sym137__ - 1);
        if (logical_gte(lcm_sym112__, 1)) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 10;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable p");
          for (size_t t = 2; t <= lcm_sym112__; ++t) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable p");}
        } 
        current_statement__ = 15;
        if (logical_gte(lcm_sym110__, lcm_sym137__)) {
          lcm_sym132__ = inv_logit((lcm_sym133__ + epsilon[(1 - 1)]));
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym137__), nil_index_list())),
            lcm_sym132__, "assigning variable phi");
          lcm_sym118__ = (lcm_sym137__ + 1);
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym137__), nil_index_list())), mean_p,
            "assigning variable p");
          for (size_t t = lcm_sym118__; t <= lcm_sym110__; ++t) {
            current_statement__ = 12;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), lcm_sym132__,
              "assigning variable phi");
            current_statement__ = 13;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_p,
              "assigning variable p");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          lcm_sym136__ = first[(i - 1)];
          lcm_sym111__ = (lcm_sym136__ - 1);
          if (logical_gte(lcm_sym111__, 1)) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable p");
            for (size_t t = 2; t <= lcm_sym111__; ++t) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable phi");
              current_statement__ = 10;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable p");}
          } 
          current_statement__ = 15;
          if (logical_gte(lcm_sym110__, lcm_sym136__)) {
            lcm_sym131__ = inv_logit((lcm_sym133__ + epsilon[(i - 1)]));
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym136__), nil_index_list())),
              lcm_sym131__, "assigning variable phi");
            lcm_sym117__ = (lcm_sym136__ + 1);
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym136__), nil_index_list())),
              mean_p, "assigning variable p");
            for (size_t t = lcm_sym117__; t <= lcm_sym110__; ++t) {
              current_statement__ = 12;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), lcm_sym131__,
                "assigning variable phi");
              current_statement__ = 13;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_p,
                "assigning variable p");}
          } }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym11__;
      int inline_sym19__;
      
      inline_sym19__ = 0;
      for (size_t inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
        current_statement__ = 18;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 18;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym12__;
        inline_sym12__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        
        for (size_t inline_sym14__ = 1; inline_sym14__ <= nind;
             ++inline_sym14__) {
          if (logical_gte(n_occasions, 1)) {
            current_statement__ = 18;
            assign(inline_sym12__,
              cons_list(index_uni(inline_sym14__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym135__,
              "assigning variable inline_sym12__");
            for (size_t inline_sym13__ = 2; inline_sym13__ <= n_occasions;
                 ++inline_sym13__) {
              current_statement__ = 18;
              assign(inline_sym12__,
                cons_list(index_uni(inline_sym14__),
                  cons_list(index_uni(inline_sym13__), nil_index_list())),
                lcm_sym135__, "assigning variable inline_sym12__");}
          } 
          if (inline_sym19__) {
            break;
          } }
        if (inline_sym19__) {
          break;
        } 
        for (size_t inline_sym18__ = 1; inline_sym18__ <= nind;
             ++inline_sym18__) {
          current_statement__ = 19;
          assign(inline_sym12__,
            cons_list(index_uni(inline_sym18__),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable inline_sym12__");
          if (logical_gte(lcm_sym110__, 1)) {
            int inline_sym15__;
            
            int inline_sym16__;
            
            lcm_sym114__ = (lcm_sym110__ + 1);
            current_statement__ = 22;
            assign(inline_sym12__,
              cons_list(index_uni(inline_sym18__),
                cons_list(index_uni(lcm_sym110__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym18__),
                     cons_list(index_uni(lcm_sym110__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym18__),
                        cons_list(index_uni((lcm_sym114__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(inline_sym12__,
                  cons_list(index_uni(inline_sym18__),
                    cons_list(index_uni(lcm_sym114__), nil_index_list())),
                  "inline_sym12__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym18__),
                      cons_list(index_uni(lcm_sym110__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym12__");
            for (size_t inline_sym17__ = 2; inline_sym17__ <= lcm_sym110__;
                 ++inline_sym17__) {
              int inline_sym15__;
              
              int inline_sym16__;
              
              lcm_sym109__ = (n_occasions - inline_sym17__);
              lcm_sym113__ = (lcm_sym109__ + 1);
              current_statement__ = 22;
              assign(inline_sym12__,
                cons_list(index_uni(inline_sym18__),
                  cons_list(index_uni(lcm_sym109__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym18__),
                       cons_list(index_uni(lcm_sym109__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym18__),
                          cons_list(index_uni((lcm_sym113__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym12__,
                    cons_list(index_uni(inline_sym18__),
                      cons_list(index_uni(lcm_sym113__), nil_index_list())),
                    "inline_sym12__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym18__),
                        cons_list(index_uni(lcm_sym109__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym12__");}
          } 
          if (inline_sym19__) {
            break;
          } }
        if (inline_sym19__) {
          break;
        } 
        inline_sym19__ = 1;
        assign(inline_sym11__, nil_index_list(), inline_sym12__,
          "assigning variable inline_sym11__");
        break;}
      assign(chi, nil_index_list(), inline_sym11__, "assigning variable chi");
      current_statement__ = 5;
      current_statement__ = 5;
      check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 5;
      current_statement__ = 5;
      check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 6;
      current_statement__ = 6;
      check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 6;
      current_statement__ = 6;
      check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 7;
      current_statement__ = 7;
      check_greater_or_equal(function__, "chi", inline_sym11__, 0);
      current_statement__ = 7;
      current_statement__ = 7;
      check_less_or_equal(function__, "chi", inline_sym11__, 1);
      {
        current_statement__ = 27;
        lp_accum__.add(normal_log<propto__>(epsilon, 0, sigma));
        current_statement__ = 34;
        if (lcm_sym99__) {
          lcm_sym137__ = first[(1 - 1)];
          if (logical_gt(lcm_sym137__, 0)) {
            lcm_sym139__ = last[(1 - 1)];
            lcm_sym118__ = (lcm_sym137__ + 1);
            if (logical_gte(lcm_sym139__, lcm_sym118__)) {
              current_statement__ = 28;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym118__ - 1)),
                        nil_index_list())), "phi")));
              lcm_sym116__ = (lcm_sym118__ + 1);
              lp_accum__.add(
                bernoulli_log<propto__>(y[(1 - 1)][(lcm_sym118__ - 1)],
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym118__ - 1)),
                        nil_index_list())), "p")));
              for (size_t t = lcm_sym116__; t <= lcm_sym139__; ++t) {
                current_statement__ = 28;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "phi")));
                current_statement__ = 29;
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(1 - 1)][(t - 1)],
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "p")));}
            } 
            current_statement__ = 31;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                rvalue(inline_sym11__,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym139__), nil_index_list())),
                  "inline_sym11__")));
          } 
          for (size_t i = 2; i <= nind; ++i) {
            lcm_sym136__ = first[(i - 1)];
            if (logical_gt(lcm_sym136__, 0)) {
              lcm_sym138__ = last[(i - 1)];
              lcm_sym117__ = (lcm_sym136__ + 1);
              if (logical_gte(lcm_sym138__, lcm_sym117__)) {
                current_statement__ = 28;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym117__ - 1)),
                          nil_index_list())), "phi")));
                lcm_sym115__ = (lcm_sym117__ + 1);
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(i - 1)][(lcm_sym117__ - 1)],
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym117__ - 1)),
                          nil_index_list())), "p")));
                for (size_t t = lcm_sym115__; t <= lcm_sym138__; ++t) {
                  current_statement__ = 28;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      rvalue(phi,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "phi")));
                  current_statement__ = 29;
                  lp_accum__.add(
                    bernoulli_log<propto__>(y[(i - 1)][(t - 1)],
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "p")));}
              } 
              current_statement__ = 31;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(inline_sym11__,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym138__), nil_index_list())),
                    "inline_sym11__")));
            } }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail5_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym97__;
      double lcm_sym96__;
      double lcm_sym95__;
      double lcm_sym94__;
      double lcm_sym93__;
      double lcm_sym92__;
      double lcm_sym91__;
      double lcm_sym90__;
      double lcm_sym89__;
      double lcm_sym88__;
      double lcm_sym87__;
      double lcm_sym86__;
      int lcm_sym85__;
      int lcm_sym84__;
      double lcm_sym83__;
      double lcm_sym82__;
      double lcm_sym81__;
      double lcm_sym80__;
      double lcm_sym79__;
      local_scalar_t__ lcm_sym78__;
      local_scalar_t__ lcm_sym77__;
      double lcm_sym76__;
      double lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      int lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      int lcm_sym69__;
      int lcm_sym68__;
      int lcm_sym67__;
      int lcm_sym66__;
      int lcm_sym65__;
      int lcm_sym64__;
      int lcm_sym63__;
      int lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      double mean_phi;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      double mean_p;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      current_statement__ = 3;
      validate_non_negative_index("epsilon", "nind", nind);
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(nind);
      
      current_statement__ = 3;
      epsilon = in__.vector(nind);
      double sigma;
      
      current_statement__ = 4;
      sigma = in__.scalar();
      current_statement__ = 4;
      sigma = stan::math::lub_constrain(sigma, 0, 5);
      current_statement__ = 5;
      validate_non_negative_index("phi", "nind", nind);
      lcm_sym66__ = (n_occasions - 1);
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym66__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym66__);
      
      lcm_sym59__ = logical_gte(nind, 1);
      if (lcm_sym59__) {
        {
          lcm_sym60__ = logical_gte(lcm_sym66__, 1);
          if (lcm_sym60__) {
            {
              lcm_sym81__ = std::numeric_limits<double>::quiet_NaN();
              assign(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym81__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym66__; ++sym2__) {
                current_statement__ = 5;
                assign(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym81__, "assigning variable phi");}
            }
          } else {
            lcm_sym81__ = std::numeric_limits<double>::quiet_NaN();
          }
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 5;
            if (lcm_sym60__) {
              current_statement__ = 5;
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym81__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym66__; ++sym2__) {
                current_statement__ = 5;
                assign(phi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym81__, "assigning variable phi");}
            } }
        }
      } else {
        lcm_sym81__ = std::numeric_limits<double>::quiet_NaN();
        lcm_sym60__ = logical_gte(lcm_sym66__, 1);
      }
      current_statement__ = 6;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 6;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym66__);
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, lcm_sym66__);
      
      current_statement__ = 6;
      if (lcm_sym59__) {
        current_statement__ = 6;
        if (lcm_sym60__) {
          current_statement__ = 6;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym81__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym66__; ++sym2__) {
            current_statement__ = 6;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym81__,
              "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym60__) {
            current_statement__ = 6;
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym81__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym66__; ++sym2__) {
              current_statement__ = 6;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym81__, "assigning variable p");}
          } }
      } 
      current_statement__ = 7;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 7;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      current_statement__ = 7;
      if (lcm_sym59__) {
        {
          lcm_sym58__ = logical_gte(n_occasions, 1);
          if (lcm_sym58__) {
            current_statement__ = 7;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym81__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              assign(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym81__, "assigning variable chi");}
          } 
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 7;
            if (lcm_sym58__) {
              current_statement__ = 7;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym81__,
                "assigning variable chi");
              for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
                current_statement__ = 7;
                assign(chi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym81__, "assigning variable chi");}
            } }
        }
      } else {
        lcm_sym58__ = logical_gte(n_occasions, 1);
      }
      double mu;
      
      current_statement__ = 8;
      mu = lcm_sym81__;
      vars__.push_back(mean_phi);
      vars__.push_back(mean_p);
      if (lcm_sym59__) {
        vars__.push_back(epsilon[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          vars__.push_back(epsilon[(sym1__ - 1)]);}
      } 
      vars__.push_back(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym79__ = logit(mean_phi);
      mu = lcm_sym79__;
      current_statement__ = 17;
      if (lcm_sym59__) {
        lcm_sym85__ = first[(1 - 1)];
        lcm_sym68__ = (lcm_sym85__ - 1);
        if (logical_gte(lcm_sym68__, 1)) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 10;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable p");
          for (size_t t = 2; t <= lcm_sym68__; ++t) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable p");}
        } 
        current_statement__ = 15;
        if (logical_gte(lcm_sym66__, lcm_sym85__)) {
          lcm_sym78__ = inv_logit((lcm_sym79__ + epsilon[(1 - 1)]));
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym85__), nil_index_list())),
            lcm_sym78__, "assigning variable phi");
          lcm_sym74__ = (lcm_sym85__ + 1);
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym85__), nil_index_list())), mean_p,
            "assigning variable p");
          for (size_t t = lcm_sym74__; t <= lcm_sym66__; ++t) {
            current_statement__ = 12;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), lcm_sym78__,
              "assigning variable phi");
            current_statement__ = 13;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_p,
              "assigning variable p");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          lcm_sym84__ = first[(i - 1)];
          lcm_sym67__ = (lcm_sym84__ - 1);
          if (logical_gte(lcm_sym67__, 1)) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable p");
            for (size_t t = 2; t <= lcm_sym67__; ++t) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable phi");
              current_statement__ = 10;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable p");}
          } 
          current_statement__ = 15;
          if (logical_gte(lcm_sym66__, lcm_sym84__)) {
            lcm_sym77__ = inv_logit((lcm_sym79__ + epsilon[(i - 1)]));
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym84__), nil_index_list())),
              lcm_sym77__, "assigning variable phi");
            lcm_sym73__ = (lcm_sym84__ + 1);
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym84__), nil_index_list())), mean_p,
              "assigning variable p");
            for (size_t t = lcm_sym73__; t <= lcm_sym66__; ++t) {
              current_statement__ = 12;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), lcm_sym77__,
                "assigning variable phi");
              current_statement__ = 13;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_p,
                "assigning variable p");}
          } }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym9__;
      
      inline_sym9__ = 0;
      for (size_t inline_sym10__ = 1; inline_sym10__ <= 1; ++inline_sym10__) {
        current_statement__ = 18;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 18;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym2__;
        inline_sym2__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        
        for (size_t inline_sym4__ = 1; inline_sym4__ <= nind; ++inline_sym4__) {
          if (lcm_sym58__) {
            current_statement__ = 18;
            assign(inline_sym2__,
              cons_list(index_uni(inline_sym4__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym81__,
              "assigning variable inline_sym2__");
            for (size_t inline_sym3__ = 2; inline_sym3__ <= n_occasions;
                 ++inline_sym3__) {
              current_statement__ = 18;
              assign(inline_sym2__,
                cons_list(index_uni(inline_sym4__),
                  cons_list(index_uni(inline_sym3__), nil_index_list())),
                lcm_sym81__, "assigning variable inline_sym2__");}
          } 
          if (inline_sym9__) {
            break;
          } }
        if (inline_sym9__) {
          break;
        } 
        for (size_t inline_sym8__ = 1; inline_sym8__ <= nind; ++inline_sym8__) {
          current_statement__ = 19;
          assign(inline_sym2__,
            cons_list(index_uni(inline_sym8__),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable inline_sym2__");
          if (lcm_sym60__) {
            int inline_sym5__;
            
            int inline_sym6__;
            
            lcm_sym72__ = (lcm_sym66__ + 1);
            current_statement__ = 22;
            assign(inline_sym2__,
              cons_list(index_uni(inline_sym8__),
                cons_list(index_uni(lcm_sym66__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym8__),
                     cons_list(index_uni(lcm_sym66__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym8__),
                        cons_list(index_uni((lcm_sym72__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(inline_sym2__,
                  cons_list(index_uni(inline_sym8__),
                    cons_list(index_uni(lcm_sym72__), nil_index_list())),
                  "inline_sym2__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym8__),
                      cons_list(index_uni(lcm_sym66__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym2__");
            for (size_t inline_sym7__ = 2; inline_sym7__ <= lcm_sym66__;
                 ++inline_sym7__) {
              int inline_sym5__;
              
              int inline_sym6__;
              
              lcm_sym65__ = (n_occasions - inline_sym7__);
              lcm_sym71__ = (lcm_sym65__ + 1);
              current_statement__ = 22;
              assign(inline_sym2__,
                cons_list(index_uni(inline_sym8__),
                  cons_list(index_uni(lcm_sym65__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym8__),
                       cons_list(index_uni(lcm_sym65__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym8__),
                          cons_list(index_uni((lcm_sym71__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym2__,
                    cons_list(index_uni(inline_sym8__),
                      cons_list(index_uni(lcm_sym71__), nil_index_list())),
                    "inline_sym2__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym8__),
                        cons_list(index_uni(lcm_sym65__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym2__");}
          } 
          if (inline_sym9__) {
            break;
          } }
        if (inline_sym9__) {
          break;
        } 
        inline_sym9__ = 1;
        assign(inline_sym1__, nil_index_list(), inline_sym2__,
          "assigning variable inline_sym1__");
        break;}
      assign(chi, nil_index_list(), inline_sym1__, "assigning variable chi");
      if (lcm_sym60__) {
        if (lcm_sym59__) {
          vars__.push_back(
            rvalue(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "phi"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "phi"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym66__; ++sym1__) {
          if (lcm_sym59__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(phi,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            }
          } }
      } 
      if (lcm_sym60__) {
        if (lcm_sym59__) {
          vars__.push_back(
            rvalue(p,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "p"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "p"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym66__; ++sym1__) {
          if (lcm_sym59__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(p,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "p"));}
          } }
      } 
      if (lcm_sym58__) {
        if (lcm_sym59__) {
          vars__.push_back(
            rvalue(inline_sym1__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "inline_sym1__"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                "inline_sym1__"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym59__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "inline_sym1__"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(inline_sym1__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "inline_sym1__"));}
          } }
      } 
      vars__.push_back(lcm_sym79__);
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      
      current_statement__ = 26;
      sigma2 = lcm_sym81__;
      lcm_sym80__ = square(sigma);
      sigma2 = lcm_sym80__;
      current_statement__ = 26;
      current_statement__ = 26;
      check_greater_or_equal(function__, "sigma2", lcm_sym80__, 0);
      vars__.push_back(lcm_sym80__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym57__;
      double lcm_sym56__;
      double lcm_sym55__;
      double lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      int pos__;
      
      pos__ = 1;
      double mean_phi;
      
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      current_statement__ = 1;
      mean_phi = stan::math::lub_free(mean_phi, 0, 1);
      double mean_p;
      
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      current_statement__ = 2;
      mean_p = stan::math::lub_free(mean_p, 0, 1);
      current_statement__ = 3;
      validate_non_negative_index("epsilon", "nind", nind);
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(nind);
      
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 3;
        assign(epsilon_flat__, nil_index_list(), context__.vals_r("epsilon"),
          "assigning variable epsilon_flat__");
        current_statement__ = 3;
        pos__ = 1;
        lcm_sym52__ = logical_gte(nind, 1);
        if (lcm_sym52__) {
          current_statement__ = 3;
          assign(epsilon, cons_list(index_uni(1), nil_index_list()),
            epsilon_flat__[(1 - 1)], "assigning variable epsilon");
          current_statement__ = 3;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 3;
            assign(epsilon, cons_list(index_uni(sym1__), nil_index_list()),
              epsilon_flat__[(pos__ - 1)], "assigning variable epsilon");
            current_statement__ = 3;
            pos__ = (pos__ + 1);}
        } 
      }
      double sigma;
      
      current_statement__ = 4;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      current_statement__ = 4;
      sigma = stan::math::lub_free(sigma, 0, 5);
      vars__.push_back(mean_phi);
      vars__.push_back(mean_p);
      if (lcm_sym52__) {
        vars__.push_back(epsilon[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          vars__.push_back(epsilon[(sym1__ - 1)]);}
      } 
      vars__.push_back(sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mean_phi");
    names__.push_back("mean_p");
    names__.push_back("epsilon");
    names__.push_back("sigma");
    names__.push_back("phi");
    names__.push_back("p");
    names__.push_back("chi");
    names__.push_back("mu");
    names__.push_back("sigma2");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occ_minus_1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occ_minus_1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_phi");
    param_names__.push_back(std::string() + "mean_p");
    for (size_t sym164__ = 1; sym164__ <= nind; ++sym164__) {
      {
        param_names__.push_back(std::string() + "epsilon" + '.' + std::to_string(sym164__));
      }}
    param_names__.push_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (size_t sym164__ = 1; sym164__ <= n_occ_minus_1; ++sym164__) {
        {
          for (size_t sym165__ = 1; sym165__ <= nind; ++sym165__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym165__) + '.' + std::to_string(sym164__));
            }}
        }}
      for (size_t sym164__ = 1; sym164__ <= n_occ_minus_1; ++sym164__) {
        {
          for (size_t sym165__ = 1; sym165__ <= nind; ++sym165__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym165__) + '.' + std::to_string(sym164__));
            }}
        }}
      for (size_t sym164__ = 1; sym164__ <= n_occasions; ++sym164__) {
        {
          for (size_t sym165__ = 1; sym165__ <= nind; ++sym165__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym165__) + '.' + std::to_string(sym164__));
            }}
        }}
      param_names__.push_back(std::string() + "mu");
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "sigma2");
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_phi");
    param_names__.push_back(std::string() + "mean_p");
    for (size_t sym164__ = 1; sym164__ <= nind; ++sym164__) {
      {
        param_names__.push_back(std::string() + "epsilon" + '.' + std::to_string(sym164__));
      }}
    param_names__.push_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (size_t sym164__ = 1; sym164__ <= n_occ_minus_1; ++sym164__) {
        {
          for (size_t sym165__ = 1; sym165__ <= nind; ++sym165__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym165__) + '.' + std::to_string(sym164__));
            }}
        }}
      for (size_t sym164__ = 1; sym164__ <= n_occ_minus_1; ++sym164__) {
        {
          for (size_t sym165__ = 1; sym165__ <= nind; ++sym165__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym165__) + '.' + std::to_string(sym164__));
            }}
        }}
      for (size_t sym164__ = 1; sym164__ <= n_occasions; ++sym164__) {
        {
          for (size_t sym165__ = 1; sym165__ <= nind; ++sym165__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym165__) + '.' + std::to_string(sym164__));
            }}
        }}
      param_names__.push_back(std::string() + "mu");
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "sigma2");
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << nind << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << nind << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef expr_prop_fail5_model_namespace::expr_prop_fail5_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-fail6.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail6_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail6.stan', line 163, column 2 to column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 164, column 2 to column 31)",
                                                      " (in 'expr-prop-fail6.stan', line 165, column 2 to column 28)",
                                                      " (in 'expr-prop-fail6.stan', line 166, column 2 to column 36)",
                                                      " (in 'expr-prop-fail6.stan', line 167, column 2 to column 20)",
                                                      " (in 'expr-prop-fail6.stan', line 168, column 2 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 174, column 2 to column 50)",
                                                      " (in 'expr-prop-fail6.stan', line 175, column 2 to column 44)",
                                                      " (in 'expr-prop-fail6.stan', line 176, column 2 to column 25)",
                                                      " (in 'expr-prop-fail6.stan', line 177, column 2 to column 42)",
                                                      " (in 'expr-prop-fail6.stan', line 178, column 2 to column 46)",
                                                      " (in 'expr-prop-fail6.stan', line 183, column 4 to column 48)",
                                                      " (in 'expr-prop-fail6.stan', line 182, column 2 to line 183, column 48)",
                                                      " (in 'expr-prop-fail6.stan', line 192, column 4 to column 22)",
                                                      " (in 'expr-prop-fail6.stan', line 194, column 4 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 196, column 6 to column 35)",
                                                      " (in 'expr-prop-fail6.stan', line 197, column 6 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 195, column 35 to line 198, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 195, column 4 to line 198, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 199, column 4 to column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 191, column 2 to line 200, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 49, column 4 to column 24)",
                                                      " (in 'expr-prop-fail6.stan', line 50, column 4 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 51, column 4 to column 35)",
                                                      " (in 'expr-prop-fail6.stan', line 54, column 6 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 56, column 8 to column 37)",
                                                      " (in 'expr-prop-fail6.stan', line 57, column 8 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 59, column 8 to line 60, column 65)",
                                                      " (in 'expr-prop-fail6.stan', line 55, column 37 to line 61, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 53, column 23 to line 62, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 48, column 47 to line 64, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 219, column 2 to column 23)",
                                                      " (in 'expr-prop-fail6.stan', line 220, column 2 to column 22)",
                                                      " (in 'expr-prop-fail6.stan', line 221, column 2 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 222, column 2 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 223, column 2 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 229, column 4 to column 14)",
                                                      " (in 'expr-prop-fail6.stan', line 238, column 6 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 237, column 11 to line 239, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 231, column 6 to column 37)",
                                                      " (in 'expr-prop-fail6.stan', line 234, column 8 to line 235, column 46)",
                                                      " (in 'expr-prop-fail6.stan', line 233, column 8 to column 34)",
                                                      " (in 'expr-prop-fail6.stan', line 232, column 31 to line 236, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 232, column 6 to line 236, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 230, column 28 to line 237, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 230, column 4 to line 239, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 228, column 17 to line 240, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 228, column 2 to line 240, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 244, column 4 to column 63)",
                                                      " (in 'expr-prop-fail6.stan', line 245, column 4 to column 16)",
                                                      " (in 'expr-prop-fail6.stan', line 246, column 4 to column 18)",
                                                      " (in 'expr-prop-fail6.stan', line 249, column 6 to column 36)",
                                                      " (in 'expr-prop-fail6.stan', line 17, column 8 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 16, column 6 to line 17, column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 14, column 31 to line 19, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 252, column 8 to column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 251, column 6 to line 252, column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 248, column 19 to line 253, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 248, column 4 to line 253, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 255, column 6 to column 25)",
                                                      " (in 'expr-prop-fail6.stan', line 256, column 6 to column 31)",
                                                      " (in 'expr-prop-fail6.stan', line 254, column 29 to line 257, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 254, column 4 to line 257, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 259, column 6 to column 26)",
                                                      " (in 'expr-prop-fail6.stan', line 260, column 6 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 258, column 19 to line 261, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 258, column 4 to line 261, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 262, column 4 to column 25)",
                                                      " (in 'expr-prop-fail6.stan', line 243, column 2 to line 263, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 211, column 2 to column 29)",
                                                      " (in 'expr-prop-fail6.stan', line 212, column 2 to column 21)",
                                                      " (in 'expr-prop-fail6.stan', line 82, column 4 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 83, column 4 to column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 84, column 4 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 87, column 6 to column 43)",
                                                      " (in 'expr-prop-fail6.stan', line 124, column 8 to column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 127, column 8 to line 130, column 47)",
                                                      " (in 'expr-prop-fail6.stan', line 133, column 10 to line 137, column 49)",
                                                      " (in 'expr-prop-fail6.stan', line 139, column 8 to column 54)",
                                                      " (in 'expr-prop-fail6.stan', line 140, column 8 to column 34)",
                                                      " (in 'expr-prop-fail6.stan', line 123, column 13 to line 141, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 91, column 8 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 97, column 10 to column 30)",
                                                      " (in 'expr-prop-fail6.stan', line 106, column 12 to line 110, column 56)",
                                                      " (in 'expr-prop-fail6.stan', line 111, column 10 to line 113, column 61)",
                                                      " (in 'expr-prop-fail6.stan', line 114, column 10 to column 36)",
                                                      " (in 'expr-prop-fail6.stan', line 96, column 15 to line 115, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 95, column 10 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 94, column 27 to line 96, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 94, column 8 to line 115, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 118, column 10 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 119, column 10 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 117, column 42 to line 120, column 9)",
                                                      " (in 'expr-prop-fail6.stan', line 122, column 8 to column 39)",
                                                      " (in 'expr-prop-fail6.stan', line 89, column 20 to line 123, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 86, column 23 to line 142, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 147, column 2 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 148, column 2 to column 27)",
                                                      " (in 'expr-prop-fail6.stan', line 149, column 2 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 153, column 2 to column 42)",
                                                      " (in 'expr-prop-fail6.stan', line 154, column 2 to column 41)",
                                                      " (in 'expr-prop-fail6.stan', line 157, column 4 to column 35)",
                                                      " (in 'expr-prop-fail6.stan', line 156, column 2 to line 157, column 35)",
                                                      " (in 'expr-prop-fail6.stan', line 30, column 6 to column 32)",
                                                      " (in 'expr-prop-fail6.stan', line 33, column 8 to column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 32, column 6 to line 33, column 17)",
                                                      " (in 'expr-prop-fail6.stan', line 29, column 37 to line 34, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 28, column 30 to line 36, column 3)",
                                                      " (in 'expr-prop-fail6.stan', line 159, column 4 to column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 158, column 2 to line 159, column 33)",
                                                      " (in 'expr-prop-fail6.stan', line 18, column 4 to column 13)",
                                                      " (in 'expr-prop-fail6.stan', line 35, column 4 to column 13)",
                                                      " (in 'expr-prop-fail6.stan', line 55, column 6 to line 61, column 7)",
                                                      " (in 'expr-prop-fail6.stan', line 53, column 4 to line 62, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 63, column 4 to column 15)",
                                                      " (in 'expr-prop-fail6.stan', line 132, column 8 to line 137, column 49)",
                                                      " (in 'expr-prop-fail6.stan', line 105, column 10 to line 110, column 56)",
                                                      " (in 'expr-prop-fail6.stan', line 86, column 4 to line 142, column 5)",
                                                      " (in 'expr-prop-fail6.stan', line 81, column 42 to line 143, column 3)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym51__;
    int lcm_sym50__;
    int lcm_sym49__;
    int lcm_sym48__;
    {
      lcm_sym49__ = size(y_i);
      if (logical_gte(lcm_sym49__, 1)) {
        current_statement__ = 54;
        if (y_i[(1 - 1)]) {
          current_statement__ = 53;
          return 1;
        } 
        for (size_t k = 2; k <= lcm_sym49__; ++k) {
          current_statement__ = 54;
          if (y_i[(k - 1)]) {
            current_statement__ = 53;
            return k;
          } }
      } 
      current_statement__ = 111;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym57__;
    int lcm_sym56__;
    int lcm_sym55__;
    int lcm_sym54__;
    int lcm_sym53__;
    int lcm_sym52__;
    {
      lcm_sym55__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym55__, 0)) {
        int k;
        
        lcm_sym54__ = (size(y_i) - 0);
        current_statement__ = 106;
        if (y_i[(lcm_sym54__ - 1)]) {
          current_statement__ = 105;
          return lcm_sym54__;
        } 
        for (size_t k_rev = 1; k_rev <= lcm_sym55__; ++k_rev) {
          int k;
          
          lcm_sym53__ = (size(y_i) - k_rev);
          current_statement__ = 106;
          if (y_i[(lcm_sym53__ - 1)]) {
            current_statement__ = 105;
            return lcm_sym53__;
          } }
      } 
      current_statement__ = 112;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__,
T1__>::type, -1, -1>
prob_uncaptured(const Eigen::Matrix<T0__, -1, -1>& p,
                const Eigen::Matrix<T1__, -1, -1>& phi,
                std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__,
          T1__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    double lcm_sym71__;
    int lcm_sym70__;
    double lcm_sym69__;
    double lcm_sym68__;
    double lcm_sym67__;
    double lcm_sym66__;
    int lcm_sym65__;
    int lcm_sym64__;
    int lcm_sym63__;
    int lcm_sym62__;
    int lcm_sym61__;
    int lcm_sym60__;
    int lcm_sym59__;
    int lcm_sym58__;
    {
      int n_ind;
      
      lcm_sym70__ = rows(p);
      int n_occasions;
      
      lcm_sym65__ = cols(p);
      n_occasions = lcm_sym65__;
      current_statement__ = 24;
      validate_non_negative_index("chi", "n_ind", lcm_sym70__);
      current_statement__ = 24;
      validate_non_negative_index("chi", "n_occasions", lcm_sym65__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym70__, lcm_sym65__);
      
      lcm_sym60__ = logical_gte(lcm_sym70__, 1);
      if (lcm_sym60__) {
        lcm_sym59__ = logical_gte(lcm_sym65__, 1);
        if (lcm_sym59__) {
          lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym65__; ++sym2__) {
            current_statement__ = 24;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym71__,
              "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym70__; ++sym1__) {
          current_statement__ = 24;
          if (lcm_sym59__) {
            lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym65__; ++sym2__) {
              current_statement__ = 24;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym71__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 114;
      if (lcm_sym60__) {
        current_statement__ = 25;
        assign(chi,
          cons_list(index_uni(1),
            cons_list(index_uni(lcm_sym65__), nil_index_list())), 1.0,
          "assigning variable chi");
        lcm_sym62__ = (lcm_sym65__ - 1);
        lcm_sym58__ = logical_gte(lcm_sym62__, 1);
        if (lcm_sym58__) {
          int t_curr;
          
          int t_next;
          
          lcm_sym64__ = (lcm_sym62__ + 1);
          current_statement__ = 28;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym62__), nil_index_list())),
            stan::math::fma(
              (rvalue(phi,
                 cons_list(index_uni(1),
                   cons_list(index_uni(lcm_sym62__), nil_index_list())),
                 "phi") *
                (1 -
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym64__), nil_index_list())),
                    "p"))),
              rvalue(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(lcm_sym64__), nil_index_list())),
                "chi"),
              (1 -
                rvalue(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym62__), nil_index_list())),
                  "phi"))), "assigning variable chi");
          for (size_t t = 2; t <= lcm_sym62__; ++t) {
            int t_curr;
            
            lcm_sym61__ = (lcm_sym65__ - t);
            int t_next;
            
            lcm_sym63__ = (lcm_sym61__ + 1);
            current_statement__ = 28;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(lcm_sym61__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(1),
                     cons_list(index_uni(lcm_sym61__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni(lcm_sym63__), nil_index_list())),
                      "p"))),
                rvalue(chi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym63__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym61__), nil_index_list())),
                    "phi"))), "assigning variable chi");}
        } 
        for (size_t i = 2; i <= lcm_sym70__; ++i) {
          current_statement__ = 25;
          assign(chi,
            cons_list(index_uni(i),
              cons_list(index_uni(lcm_sym65__), nil_index_list())), 1.0,
            "assigning variable chi");
          current_statement__ = 113;
          if (lcm_sym58__) {
            int t_curr;
            
            int t_next;
            
            lcm_sym64__ = (lcm_sym62__ + 1);
            current_statement__ = 28;
            assign(chi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym62__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(i),
                     cons_list(index_uni(lcm_sym62__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym64__), nil_index_list())),
                      "p"))),
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(lcm_sym64__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym62__), nil_index_list())),
                    "phi"))), "assigning variable chi");
            for (size_t t = 2; t <= lcm_sym62__; ++t) {
              int t_curr;
              
              lcm_sym61__ = (lcm_sym65__ - t);
              int t_next;
              
              lcm_sym63__ = (lcm_sym61__ + 1);
              current_statement__ = 28;
              assign(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(lcm_sym61__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_uni(lcm_sym61__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni(lcm_sym63__), nil_index_list())),
                        "p"))),
                  rvalue(chi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym63__), nil_index_list())),
                    "chi"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym61__), nil_index_list())),
                      "phi"))), "assigning variable chi");}
          } }
      } 
      current_statement__ = 115;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__,
T1__>::type, -1, -1>
operator()(const Eigen::Matrix<T0__, -1, -1>& p,
           const Eigen::Matrix<T1__, -1, -1>& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(p, phi, pstream__);
}
};

template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T7__, typename T_lp__, typename T_lp_accum__>
void
js_super_lp(const std::vector<std::vector<int>>& y,
            const std::vector<int>& first, const std::vector<int>& last,
            const Eigen::Matrix<T3__, -1, -1>& p,
            const Eigen::Matrix<T4__, -1, -1>& phi, const T5__& psi,
            const Eigen::Matrix<T6__, -1, 1>& nu,
            const Eigen::Matrix<T7__, -1, -1>& chi, T_lp__& lp__,
            T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T3__,
          T4__,
          T5__,
          T6__,
          T7__>::type;
  
  try {
    int lcm_sym126__;
    int lcm_sym125__;
    int lcm_sym124__;
    int lcm_sym123__;
    int lcm_sym122__;
    int lcm_sym121__;
    double lcm_sym120__;
    double lcm_sym119__;
    double lcm_sym118__;
    double lcm_sym117__;
    double lcm_sym116__;
    double lcm_sym115__;
    double lcm_sym114__;
    double lcm_sym113__;
    double lcm_sym112__;
    double lcm_sym111__;
    double lcm_sym110__;
    double lcm_sym109__;
    double lcm_sym108__;
    double lcm_sym107__;
    double lcm_sym106__;
    double lcm_sym105__;
    int lcm_sym104__;
    int lcm_sym103__;
    int lcm_sym102__;
    double lcm_sym101__;
    double lcm_sym100__;
    double lcm_sym99__;
    double lcm_sym98__;
    double lcm_sym97__;
    double lcm_sym96__;
    double lcm_sym95__;
    double lcm_sym94__;
    double lcm_sym93__;
    double lcm_sym92__;
    double lcm_sym91__;
    double lcm_sym90__;
    double lcm_sym89__;
    double lcm_sym88__;
    int lcm_sym87__;
    int lcm_sym86__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym85__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym84__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym83__;
    int lcm_sym82__;
    int lcm_sym81__;
    int lcm_sym80__;
    int lcm_sym79__;
    int lcm_sym78__;
    int lcm_sym77__;
    int lcm_sym76__;
    int lcm_sym75__;
    int lcm_sym74__;
    int lcm_sym73__;
    int lcm_sym72__;
    {
      int n_ind;
      
      lcm_sym125__ = dims(y)[(1 - 1)];
      int n_occasions;
      
      lcm_sym126__ = dims(y)[(2 - 1)];
      n_occasions = lcm_sym126__;
      current_statement__ = 74;
      validate_non_negative_index("qnu", "n_occasions", lcm_sym126__);
      Eigen::Matrix<double, -1, 1> qnu;
      qnu = Eigen::Matrix<double, -1, 1>(lcm_sym126__);
      
      assign(lcm_sym83__, nil_index_list(), subtract(1.0, nu),
        "assigning variable lcm_sym83__");
      current_statement__ = 118;
      if (logical_gte(lcm_sym125__, 1)) {
        current_statement__ = 75;
        validate_non_negative_index("qp", "n_occasions", lcm_sym126__);
        Eigen::Matrix<double, -1, 1> qp;
        qp = Eigen::Matrix<double, -1, 1>(lcm_sym126__);
        
        assign(lcm_sym85__, nil_index_list(),
          subtract(1.0,
            transpose(
              rvalue(p, cons_list(index_uni(1), nil_index_list()), "p"))),
          "assigning variable lcm_sym85__");
        lcm_sym122__ = first[(1 - 1)];
        if (lcm_sym122__) {
          current_statement__ = 82;
          lp_accum__.add(bernoulli_log<propto__>(1, psi));
          current_statement__ = 90;
          if (logical_eq(lcm_sym122__, 1)) {
            current_statement__ = 88;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                (nu[(1 - 1)] *
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(1), nil_index_list())), "p"))));
          } else {
            current_statement__ = 83;
            validate_non_negative_index("lp", "first[(i - 1)]", lcm_sym122__);
            Eigen::Matrix<local_scalar_t__, -1, 1> lp;
            lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym122__);
            
            current_statement__ = 83;
            if (logical_gte(lcm_sym122__, 1)) {
              lcm_sym120__ = std::numeric_limits<double>::quiet_NaN();
              assign(lp, cons_list(index_uni(1), nil_index_list()),
                lcm_sym120__, "assigning variable lp");
              for (size_t sym1__ = 2; sym1__ <= lcm_sym122__; ++sym1__) {
                current_statement__ = 83;
                assign(lp, cons_list(index_uni(sym1__), nil_index_list()),
                  lcm_sym120__, "assigning variable lp");}
            } 
            lcm_sym87__ = (lcm_sym122__ - 1);
            assign(lp, cons_list(index_uni(1), nil_index_list()),
              (((bernoulli_lpmf<false>(1, nu[(1 - 1)]) +
                  bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(lcm_sym85__,
                        cons_list(index_min_max(1, lcm_sym87__),
                          nil_index_list()), "lcm_sym85__")))) +
                 bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(phi,
                       cons_list(index_uni(1),
                         cons_list(index_min_max(1, lcm_sym87__),
                           nil_index_list())), "phi")))) +
                bernoulli_lpmf<false>(1,
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym122__), nil_index_list())),
                    "p"))), "assigning variable lp");
            current_statement__ = 117;
            if (logical_gte(lcm_sym87__, 2)) {
              current_statement__ = 84;
              assign(lp, cons_list(index_uni(2), nil_index_list()),
                ((((bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym83__,
                          cons_list(index_min_max(1, 1), nil_index_list()),
                          "lcm_sym83__"))) +
                     bernoulli_lpmf<false>(1, nu[(2 - 1)])) +
                    bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym85__,
                          cons_list(index_min_max(2, lcm_sym87__),
                            nil_index_list()), "lcm_sym85__")))) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(phi,
                         cons_list(index_uni(1),
                           cons_list(index_min_max(2, lcm_sym87__),
                             nil_index_list())), "phi")))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni(lcm_sym122__), nil_index_list())),
                      "p"))), "assigning variable lp");
              for (size_t t = 3; t <= lcm_sym87__; ++t) {
                current_statement__ = 84;
                assign(lp, cons_list(index_uni(t), nil_index_list()),
                  ((((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym83__,
                            cons_list(index_min_max(1, (t - 1)),
                              nil_index_list()), "lcm_sym83__"))) +
                       bernoulli_lpmf<false>(1, nu[(t - 1)])) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym85__,
                            cons_list(index_min_max(t, lcm_sym87__),
                              nil_index_list()), "lcm_sym85__")))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi,
                           cons_list(index_uni(1),
                             cons_list(index_min_max(t, lcm_sym87__),
                               nil_index_list())), "phi")))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p,
                        cons_list(index_uni(1),
                          cons_list(index_uni(lcm_sym122__),
                            nil_index_list())), "p"))),
                  "assigning variable lp");}
            } 
            current_statement__ = 85;
            assign(lp, cons_list(index_uni(lcm_sym122__), nil_index_list()),
              ((bernoulli_lpmf<false>(1,
                  prod(
                    rvalue(lcm_sym83__,
                      cons_list(index_min_max(1, lcm_sym87__),
                        nil_index_list()), "lcm_sym83__"))) +
                 bernoulli_lpmf<false>(1, nu[(lcm_sym122__ - 1)])) +
                bernoulli_lpmf<false>(1,
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym122__), nil_index_list())),
                    "p"))), "assigning variable lp");
            current_statement__ = 86;
            lp_accum__.add(log_sum_exp(lp));
          }
          lcm_sym124__ = last[(1 - 1)];
          if (logical_gte(lcm_sym124__, (lcm_sym122__ + 1))) {
            current_statement__ = 91;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                rvalue(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(((lcm_sym122__ + 1) - 1)),
                      nil_index_list())), "phi")));
            lcm_sym103__ = ((lcm_sym122__ + 1) + 1);
            lp_accum__.add(
              bernoulli_log<propto__>(y[(1 - 1)][((lcm_sym122__ + 1) - 1)],
                rvalue(p,
                  cons_list(index_uni(1),
                    cons_list(index_uni((lcm_sym122__ + 1)),
                      nil_index_list())), "p")));
            for (size_t t = lcm_sym103__; t <= lcm_sym124__; ++t) {
              current_statement__ = 91;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni((t - 1)), nil_index_list())),
                    "phi")));
              current_statement__ = 92;
              lp_accum__.add(
                bernoulli_log<propto__>(y[(1 - 1)][(t - 1)],
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(t), nil_index_list())), "p")));}
          } 
          current_statement__ = 94;
          lp_accum__.add(
            bernoulli_log<propto__>(1,
              rvalue(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(lcm_sym124__), nil_index_list())),
                "chi")));
        } else {
          lcm_sym104__ = (lcm_sym126__ + 1);
          validate_non_negative_index("lp", "(n_occasions + 1)", lcm_sym104__);
          Eigen::Matrix<local_scalar_t__, -1, 1> lp;
          lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym104__);
          
          current_statement__ = 76;
          if (logical_gte(lcm_sym104__, 1)) {
            lcm_sym120__ = std::numeric_limits<double>::quiet_NaN();
            assign(lp, cons_list(index_uni(1), nil_index_list()),
              lcm_sym120__, "assigning variable lp");
            for (size_t sym1__ = 2; sym1__ <= lcm_sym104__; ++sym1__) {
              current_statement__ = 76;
              assign(lp, cons_list(index_uni(sym1__), nil_index_list()),
                lcm_sym120__, "assigning variable lp");}
          } 
          current_statement__ = 77;
          assign(lp, cons_list(index_uni(1), nil_index_list()),
            (((bernoulli_lpmf<false>(1, psi) +
                bernoulli_lpmf<false>(1, nu[(1 - 1)])) +
               bernoulli_lpmf<false>(0,
                 rvalue(p,
                   cons_list(index_uni(1),
                     cons_list(index_uni(1), nil_index_list())), "p"))) +
              bernoulli_lpmf<false>(1,
                rvalue(chi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(1), nil_index_list())), "chi"))),
            "assigning variable lp");
          current_statement__ = 116;
          if (logical_gte(lcm_sym126__, 2)) {
            current_statement__ = 78;
            assign(lp, cons_list(index_uni(2), nil_index_list()),
              ((((bernoulli_lpmf<false>(1, psi) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(lcm_sym83__,
                         cons_list(index_min_max(1, 1), nil_index_list()),
                         "lcm_sym83__")))) +
                  bernoulli_lpmf<false>(1, nu[(2 - 1)])) +
                 bernoulli_lpmf<false>(0,
                   rvalue(p,
                     cons_list(index_uni(1),
                       cons_list(index_uni(2), nil_index_list())), "p"))) +
                bernoulli_lpmf<false>(1,
                  rvalue(chi,
                    cons_list(index_uni(1),
                      cons_list(index_uni(2), nil_index_list())), "chi"))),
              "assigning variable lp");
            for (size_t t = 3; t <= lcm_sym126__; ++t) {
              current_statement__ = 78;
              assign(lp, cons_list(index_uni(t), nil_index_list()),
                ((((bernoulli_lpmf<false>(1, psi) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym83__,
                           cons_list(index_min_max(1, (t - 1)),
                             nil_index_list()), "lcm_sym83__")))) +
                    bernoulli_lpmf<false>(1, nu[(t - 1)])) +
                   bernoulli_lpmf<false>(0,
                     rvalue(p,
                       cons_list(index_uni(1),
                         cons_list(index_uni(t), nil_index_list())), "p"))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(chi,
                      cons_list(index_uni(1),
                        cons_list(index_uni(t), nil_index_list())), "chi"))),
                "assigning variable lp");}
          } 
          current_statement__ = 79;
          assign(lp, cons_list(index_uni(lcm_sym104__), nil_index_list()),
            bernoulli_lpmf<false>(0, psi), "assigning variable lp");
          current_statement__ = 80;
          lp_accum__.add(log_sum_exp(lp));
        }
        for (size_t i = 2; i <= lcm_sym125__; ++i) {
          current_statement__ = 75;
          validate_non_negative_index("qp", "n_occasions", lcm_sym126__);
          Eigen::Matrix<double, -1, 1> qp;
          qp = Eigen::Matrix<double, -1, 1>(lcm_sym126__);
          
          assign(lcm_sym84__, nil_index_list(),
            subtract(1.0,
              transpose(
                rvalue(p, cons_list(index_uni(i), nil_index_list()), "p"))),
            "assigning variable lcm_sym84__");
          lcm_sym121__ = first[(i - 1)];
          if (lcm_sym121__) {
            current_statement__ = 82;
            lp_accum__.add(bernoulli_log<propto__>(1, psi));
            current_statement__ = 90;
            if (logical_eq(lcm_sym121__, 1)) {
              current_statement__ = 88;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  (nu[(1 - 1)] *
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(1), nil_index_list())), "p"))));
            } else {
              current_statement__ = 83;
              validate_non_negative_index("lp", "first[(i - 1)]",
                                          lcm_sym121__);
              Eigen::Matrix<local_scalar_t__, -1, 1> lp;
              lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym121__);
              
              current_statement__ = 83;
              if (logical_gte(lcm_sym121__, 1)) {
                lcm_sym120__ = std::numeric_limits<double>::quiet_NaN();
                assign(lp, cons_list(index_uni(1), nil_index_list()),
                  lcm_sym120__, "assigning variable lp");
                for (size_t sym1__ = 2; sym1__ <= lcm_sym121__; ++sym1__) {
                  current_statement__ = 83;
                  assign(lp, cons_list(index_uni(sym1__), nil_index_list()),
                    lcm_sym120__, "assigning variable lp");}
              } 
              lcm_sym86__ = (lcm_sym121__ - 1);
              assign(lp, cons_list(index_uni(1), nil_index_list()),
                (((bernoulli_lpmf<false>(1, nu[(1 - 1)]) +
                    bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym84__,
                          cons_list(index_min_max(1, lcm_sym86__),
                            nil_index_list()), "lcm_sym84__")))) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(phi,
                         cons_list(index_uni(i),
                           cons_list(index_min_max(1, lcm_sym86__),
                             nil_index_list())), "phi")))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym121__), nil_index_list())),
                      "p"))), "assigning variable lp");
              current_statement__ = 117;
              if (logical_gte(lcm_sym86__, 2)) {
                current_statement__ = 84;
                assign(lp, cons_list(index_uni(2), nil_index_list()),
                  ((((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym83__,
                            cons_list(index_min_max(1, 1), nil_index_list()),
                            "lcm_sym83__"))) +
                       bernoulli_lpmf<false>(1, nu[(2 - 1)])) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym84__,
                            cons_list(index_min_max(2, lcm_sym86__),
                              nil_index_list()), "lcm_sym84__")))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi,
                           cons_list(index_uni(i),
                             cons_list(index_min_max(2, lcm_sym86__),
                               nil_index_list())), "phi")))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni(lcm_sym121__),
                            nil_index_list())), "p"))),
                  "assigning variable lp");
                for (size_t t = 3; t <= lcm_sym86__; ++t) {
                  current_statement__ = 84;
                  assign(lp, cons_list(index_uni(t), nil_index_list()),
                    ((((bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym83__,
                              cons_list(index_min_max(1, (t - 1)),
                                nil_index_list()), "lcm_sym83__"))) +
                         bernoulli_lpmf<false>(1, nu[(t - 1)])) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym84__,
                              cons_list(index_min_max(t, lcm_sym86__),
                                nil_index_list()), "lcm_sym84__")))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(phi,
                             cons_list(index_uni(i),
                               cons_list(index_min_max(t, lcm_sym86__),
                                 nil_index_list())), "phi")))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(p,
                          cons_list(index_uni(i),
                            cons_list(index_uni(lcm_sym121__),
                              nil_index_list())), "p"))),
                    "assigning variable lp");}
              } 
              current_statement__ = 85;
              assign(lp,
                cons_list(index_uni(lcm_sym121__), nil_index_list()),
                ((bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(lcm_sym83__,
                        cons_list(index_min_max(1, lcm_sym86__),
                          nil_index_list()), "lcm_sym83__"))) +
                   bernoulli_lpmf<false>(1, nu[(lcm_sym121__ - 1)])) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym121__), nil_index_list())),
                      "p"))), "assigning variable lp");
              current_statement__ = 86;
              lp_accum__.add(log_sum_exp(lp));
            }
            lcm_sym123__ = last[(i - 1)];
            if (logical_gte(lcm_sym123__, (lcm_sym121__ + 1))) {
              current_statement__ = 91;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(((lcm_sym121__ + 1) - 1)),
                        nil_index_list())), "phi")));
              lcm_sym102__ = ((lcm_sym121__ + 1) + 1);
              lp_accum__.add(
                bernoulli_log<propto__>(y[(i - 1)][((lcm_sym121__ + 1) - 1)],
                  rvalue(p,
                    cons_list(index_uni(i),
                      cons_list(index_uni((lcm_sym121__ + 1)),
                        nil_index_list())), "p")));
              for (size_t t = lcm_sym102__; t <= lcm_sym123__; ++t) {
                current_statement__ = 91;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "phi")));
                current_statement__ = 92;
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(i - 1)][(t - 1)],
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(t), nil_index_list())), "p")));}
            } 
            current_statement__ = 94;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(lcm_sym123__), nil_index_list())),
                  "chi")));
          } else {
            lcm_sym104__ = (lcm_sym126__ + 1);
            validate_non_negative_index("lp", "(n_occasions + 1)",
                                        lcm_sym104__);
            Eigen::Matrix<local_scalar_t__, -1, 1> lp;
            lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym104__);
            
            current_statement__ = 76;
            if (logical_gte(lcm_sym104__, 1)) {
              lcm_sym120__ = std::numeric_limits<double>::quiet_NaN();
              assign(lp, cons_list(index_uni(1), nil_index_list()),
                lcm_sym120__, "assigning variable lp");
              for (size_t sym1__ = 2; sym1__ <= lcm_sym104__; ++sym1__) {
                current_statement__ = 76;
                assign(lp, cons_list(index_uni(sym1__), nil_index_list()),
                  lcm_sym120__, "assigning variable lp");}
            } 
            current_statement__ = 77;
            assign(lp, cons_list(index_uni(1), nil_index_list()),
              (((bernoulli_lpmf<false>(1, psi) +
                  bernoulli_lpmf<false>(1, nu[(1 - 1)])) +
                 bernoulli_lpmf<false>(0,
                   rvalue(p,
                     cons_list(index_uni(i),
                       cons_list(index_uni(1), nil_index_list())), "p"))) +
                bernoulli_lpmf<false>(1,
                  rvalue(chi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(1), nil_index_list())), "chi"))),
              "assigning variable lp");
            current_statement__ = 116;
            if (logical_gte(lcm_sym126__, 2)) {
              current_statement__ = 78;
              assign(lp, cons_list(index_uni(2), nil_index_list()),
                ((((bernoulli_lpmf<false>(1, psi) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym83__,
                           cons_list(index_min_max(1, 1), nil_index_list()),
                           "lcm_sym83__")))) +
                    bernoulli_lpmf<false>(1, nu[(2 - 1)])) +
                   bernoulli_lpmf<false>(0,
                     rvalue(p,
                       cons_list(index_uni(i),
                         cons_list(index_uni(2), nil_index_list())), "p"))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(chi,
                      cons_list(index_uni(i),
                        cons_list(index_uni(2), nil_index_list())), "chi"))),
                "assigning variable lp");
              for (size_t t = 3; t <= lcm_sym126__; ++t) {
                current_statement__ = 78;
                assign(lp, cons_list(index_uni(t), nil_index_list()),
                  ((((bernoulli_lpmf<false>(1, psi) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym83__,
                             cons_list(index_min_max(1, (t - 1)),
                               nil_index_list()), "lcm_sym83__")))) +
                      bernoulli_lpmf<false>(1, nu[(t - 1)])) +
                     bernoulli_lpmf<false>(0,
                       rvalue(p,
                         cons_list(index_uni(i),
                           cons_list(index_uni(t), nil_index_list())), "p")))
                    +
                    bernoulli_lpmf<false>(1,
                      rvalue(chi,
                        cons_list(index_uni(i),
                          cons_list(index_uni(t), nil_index_list())), "chi"))),
                  "assigning variable lp");}
            } 
            current_statement__ = 79;
            assign(lp, cons_list(index_uni(lcm_sym104__), nil_index_list()),
              bernoulli_lpmf<false>(0, psi), "assigning variable lp");
            current_statement__ = 80;
            lp_accum__.add(log_sum_exp(lp));
          }}
      } 
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct js_super_lp_functor__ {
template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T7__, typename T_lp__, typename T_lp_accum__>
void
operator()(const std::vector<std::vector<int>>& y,
           const std::vector<int>& first, const std::vector<int>& last,
           const Eigen::Matrix<T3__, -1, -1>& p,
           const Eigen::Matrix<T4__, -1, -1>& phi, const T5__& psi,
           const Eigen::Matrix<T6__, -1, 1>& nu,
           const Eigen::Matrix<T7__, -1, -1>& chi, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return js_super_lp(y, first, last, p, phi, psi, nu, chi, lp__, lp_accum__,
         pstream__);
}
};

class expr_prop_fail6_model : public model_base_crtp<expr_prop_fail6_model> {

 private:
  int lcm_sym332__;
  int lcm_sym331__;
  int lcm_sym330__;
  int lcm_sym329__;
  int lcm_sym328__;
  int lcm_sym327__;
  int lcm_sym326__;
  int lcm_sym325__;
  int lcm_sym324__;
  int lcm_sym323__;
  int lcm_sym322__;
  int lcm_sym321__;
  int lcm_sym320__;
  int lcm_sym319__;
  int lcm_sym318__;
  int lcm_sym317__;
  int lcm_sym316__;
  int lcm_sym315__;
  int lcm_sym314__;
  int lcm_sym313__;
  int lcm_sym312__;
  int lcm_sym311__;
  int lcm_sym310__;
  int pos__;
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~expr_prop_fail6_model() { }
  
  std::string model_name() const { return "expr_prop_fail6_model"; }
  
  expr_prop_fail6_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail6_model_namespace::expr_prop_fail6_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","M","int",
          context__.to_vec());
      
      current_statement__ = 97;
      M = context__.vals_i("M")[(1 - 1)];
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      
      current_statement__ = 98;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 99;
      validate_non_negative_index("y", "M", M);
      current_statement__ = 99;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(M, n_occasions));
      y = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, 0));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 99;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 99;
        pos__ = 1;
        lcm_sym311__ = logical_gte(n_occasions, 1);
        if (lcm_sym311__) {
          {
            lcm_sym310__ = logical_gte(M, 1);
            if (lcm_sym310__) {
              current_statement__ = 99;
              assign(y,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())),
                y_flat__[(1 - 1)], "assigning variable y");
              current_statement__ = 99;
              pos__ = 2;
              for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
                current_statement__ = 99;
                assign(y,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(1), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 99;
                pos__ = (pos__ + 1);}
            } 
            for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 99;
              if (lcm_sym310__) {
                current_statement__ = 99;
                assign(y,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 99;
                pos__ = (pos__ + 1);
                for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
                  current_statement__ = 99;
                  assign(y,
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list())),
                    y_flat__[(pos__ - 1)], "assigning variable y");
                  current_statement__ = 99;
                  pos__ = (pos__ + 1);}
              } }
          }
        } else {
          lcm_sym310__ = logical_gte(M, 1);
        }
      }
      current_statement__ = 100;
      validate_non_negative_index("first", "M", M);
      first = std::vector<int>(M, 0);
      
      current_statement__ = 101;
      validate_non_negative_index("last", "M", M);
      last = std::vector<int>(M, 0);
      
      current_statement__ = 103;
      if (lcm_sym310__) {
        int inline_sym39__;
        int inline_sym41__;
        
        inline_sym41__ = 0;
        for (size_t inline_sym42__ = 1; inline_sym42__ <= 1; ++inline_sym42__) {
          lcm_sym318__ = size(y[(1 - 1)]);
          for (size_t inline_sym40__ = 1; inline_sym40__ <= lcm_sym318__;
               ++inline_sym40__) {
            current_statement__ = 54;
            if (y[(1 - 1)][(inline_sym40__ - 1)]) {
              inline_sym41__ = 1;
              inline_sym39__ = inline_sym40__;
              break;
            } }
          if (inline_sym41__) {
            break;
          } 
          inline_sym41__ = 1;
          inline_sym39__ = 0;
          break;}
        assign(first, cons_list(index_uni(1), nil_index_list()),
          inline_sym39__, "assigning variable first");
        for (size_t i = 2; i <= M; ++i) {
          int inline_sym39__;
          int inline_sym41__;
          
          inline_sym41__ = 0;
          for (size_t inline_sym42__ = 1; inline_sym42__ <= 1;
               ++inline_sym42__) {
            lcm_sym317__ = size(y[(i - 1)]);
            for (size_t inline_sym40__ = 1; inline_sym40__ <= lcm_sym317__;
                 ++inline_sym40__) {
              current_statement__ = 54;
              if (y[(i - 1)][(inline_sym40__ - 1)]) {
                inline_sym41__ = 1;
                inline_sym39__ = inline_sym40__;
                break;
              } }
            if (inline_sym41__) {
              break;
            } 
            inline_sym41__ = 1;
            inline_sym39__ = 0;
            break;}
          assign(first, cons_list(index_uni(i), nil_index_list()),
            inline_sym39__, "assigning variable first");}
      } 
      current_statement__ = 110;
      if (lcm_sym310__) {
        int inline_sym43__;
        int inline_sym46__;
        
        inline_sym46__ = 0;
        for (size_t inline_sym47__ = 1; inline_sym47__ <= 1; ++inline_sym47__) {
          lcm_sym318__ = size(y[(1 - 1)]);
          lcm_sym315__ = (lcm_sym318__ - 1);
          for (size_t inline_sym45__ = 0; inline_sym45__ <= lcm_sym315__;
               ++inline_sym45__) {
            int inline_sym44__;
            
            lcm_sym314__ = (lcm_sym318__ - inline_sym45__);
            inline_sym44__ = lcm_sym314__;
            current_statement__ = 106;
            if (y[(1 - 1)][(lcm_sym314__ - 1)]) {
              inline_sym46__ = 1;
              inline_sym43__ = lcm_sym314__;
              break;
            } }
          if (inline_sym46__) {
            break;
          } 
          inline_sym46__ = 1;
          inline_sym43__ = 0;
          break;}
        assign(last, cons_list(index_uni(1), nil_index_list()),
          inline_sym43__, "assigning variable last");
        for (size_t i = 2; i <= M; ++i) {
          int inline_sym43__;
          int inline_sym46__;
          
          inline_sym46__ = 0;
          for (size_t inline_sym47__ = 1; inline_sym47__ <= 1;
               ++inline_sym47__) {
            lcm_sym317__ = size(y[(i - 1)]);
            lcm_sym313__ = (lcm_sym317__ - 1);
            for (size_t inline_sym45__ = 0; inline_sym45__ <= lcm_sym313__;
                 ++inline_sym45__) {
              int inline_sym44__;
              
              lcm_sym312__ = (lcm_sym317__ - inline_sym45__);
              inline_sym44__ = lcm_sym312__;
              current_statement__ = 106;
              if (y[(i - 1)][(lcm_sym312__ - 1)]) {
                inline_sym46__ = 1;
                inline_sym43__ = lcm_sym312__;
                break;
              } }
            if (inline_sym46__) {
              break;
            } 
            inline_sym46__ = 1;
            inline_sym43__ = 0;
            break;}
          assign(last, cons_list(index_uni(i), nil_index_list()),
            inline_sym43__, "assigning variable last");}
      } 
      current_statement__ = 97;
      current_statement__ = 97;
      check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 98;
      current_statement__ = 98;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 0);
      current_statement__ = 99;
      if (lcm_sym310__) {
        current_statement__ = 99;
        if (lcm_sym311__) {
          current_statement__ = 99;
          current_statement__ = 99;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 99;
            current_statement__ = 99;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 99;
          if (lcm_sym311__) {
            current_statement__ = 99;
            current_statement__ = 99;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 99;
              current_statement__ = 99;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 99;
      if (lcm_sym310__) {
        current_statement__ = 99;
        if (lcm_sym311__) {
          current_statement__ = 99;
          current_statement__ = 99;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 99;
            current_statement__ = 99;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 99;
          if (lcm_sym311__) {
            current_statement__ = 99;
            current_statement__ = 99;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 99;
              current_statement__ = 99;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      current_statement__ = 100;
      if (lcm_sym310__) {
        current_statement__ = 100;
        current_statement__ = 100;
        check_greater_or_equal(function__, "first[sym1__]", first[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 100;
          current_statement__ = 100;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 100;
      if (lcm_sym310__) {
        current_statement__ = 100;
        current_statement__ = 100;
        check_less_or_equal(function__, "first[sym1__]", first[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 100;
          current_statement__ = 100;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);}
      } 
      current_statement__ = 101;
      if (lcm_sym310__) {
        current_statement__ = 101;
        current_statement__ = 101;
        check_greater_or_equal(function__, "last[sym1__]", last[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 101;
          current_statement__ = 101;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 101;
      if (lcm_sym310__) {
        current_statement__ = 101;
        current_statement__ = 101;
        check_less_or_equal(function__, "last[sym1__]", last[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 101;
          current_statement__ = 101;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 4;
      validate_non_negative_index("beta", "n_occasions", n_occasions);
      num_params_r__ += n_occasions;
      current_statement__ = 5;
      validate_non_negative_index("epsilon", "M", M);
      num_params_r__ += M;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail6_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      int lcm_sym309__;
      int lcm_sym308__;
      local_scalar_t__ lcm_sym307__;
      int lcm_sym306__;
      int lcm_sym305__;
      int lcm_sym304__;
      int lcm_sym303__;
      double lcm_sym301__;
      double lcm_sym299__;
      double lcm_sym302__;
      int lcm_sym297__;
      Eigen::Matrix<local_scalar_t__, -1, -1> lcm_sym296__;
      double lcm_sym295__;
      double lcm_sym294__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym293__;
      double lcm_sym292__;
      double lcm_sym291__;
      double lcm_sym290__;
      int lcm_sym289__;
      double lcm_sym288__;
      double lcm_sym287__;
      double lcm_sym286__;
      double lcm_sym285__;
      double lcm_sym284__;
      double lcm_sym283__;
      double lcm_sym282__;
      double lcm_sym281__;
      double lcm_sym280__;
      double lcm_sym279__;
      double lcm_sym278__;
      double lcm_sym277__;
      double lcm_sym276__;
      double lcm_sym275__;
      int lcm_sym274__;
      double lcm_sym273__;
      int lcm_sym272__;
      int lcm_sym271__;
      double lcm_sym270__;
      double lcm_sym269__;
      double lcm_sym268__;
      double lcm_sym267__;
      double lcm_sym266__;
      double lcm_sym265__;
      double lcm_sym264__;
      double lcm_sym263__;
      double lcm_sym262__;
      double lcm_sym261__;
      double lcm_sym260__;
      double lcm_sym259__;
      double lcm_sym258__;
      double lcm_sym257__;
      int lcm_sym256__;
      int lcm_sym255__;
      double lcm_sym254__;
      int lcm_sym253__;
      int lcm_sym252__;
      int lcm_sym251__;
      int lcm_sym250__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym249__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym248__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym247__;
      int lcm_sym246__;
      int lcm_sym245__;
      int lcm_sym244__;
      int lcm_sym243__;
      int lcm_sym242__;
      int lcm_sym241__;
      int lcm_sym240__;
      int lcm_sym239__;
      int lcm_sym238__;
      int lcm_sym237__;
      int lcm_sym236__;
      int lcm_sym235__;
      int lcm_sym234__;
      int lcm_sym233__;
      int lcm_sym232__;
      int lcm_sym231__;
      int lcm_sym230__;
      int lcm_sym229__;
      double lcm_sym228__;
      double lcm_sym227__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym226__;
      local_scalar_t__ mean_phi;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      }
      local_scalar_t__ mean_p;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      local_scalar_t__ psi;
      
      current_statement__ = 3;
      psi = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        psi = stan::math::lub_constrain(psi, 0, 1, lp__);
      } else {
        current_statement__ = 3;
        psi = stan::math::lub_constrain(psi, 0, 1);
      }
      current_statement__ = 4;
      validate_non_negative_index("beta", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      
      current_statement__ = 4;
      beta = in__.vector(n_occasions);
      lcm_sym232__ = logical_gte(n_occasions, 1);
      if (lcm_sym232__) {
        current_statement__ = 4;
        if (jacobian__) {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            stan::math::lb_constrain(beta[(1 - 1)], 0, lp__),
            "assigning variable beta");
        } else {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            stan::math::lb_constrain(beta[(1 - 1)], 0),
            "assigning variable beta");
        }
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 4;
          if (jacobian__) {
            current_statement__ = 4;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              stan::math::lb_constrain(beta[(sym1__ - 1)], 0, lp__),
              "assigning variable beta");
          } else {
            current_statement__ = 4;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              stan::math::lb_constrain(beta[(sym1__ - 1)], 0),
              "assigning variable beta");
          }}
      } 
      current_statement__ = 5;
      validate_non_negative_index("epsilon", "M", M);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>(M);
      
      current_statement__ = 5;
      epsilon = in__.vector(M);
      local_scalar_t__ sigma;
      
      current_statement__ = 6;
      sigma = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        sigma = stan::math::lub_constrain(sigma, 0, 5, lp__);
      } else {
        current_statement__ = 6;
        sigma = stan::math::lub_constrain(sigma, 0, 5);
      }
      current_statement__ = 7;
      validate_non_negative_index("phi", "M", M);
      lcm_sym246__ = (n_occasions - 1);
      validate_non_negative_index("phi", "(n_occasions - 1)", lcm_sym246__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, lcm_sym246__);
      
      lcm_sym231__ = logical_gte(M, 1);
      if (lcm_sym231__) {
        lcm_sym233__ = logical_gte(lcm_sym246__, 1);
        if (lcm_sym233__) {
          lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym302__,
            "assigning variable phi");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym246__; ++sym2__) {
            current_statement__ = 7;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym302__, "assigning variable phi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym233__) {
            lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
            assign(phi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym302__,
              "assigning variable phi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym246__; ++sym2__) {
              current_statement__ = 7;
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym302__, "assigning variable phi");}
          } }
      } 
      current_statement__ = 8;
      validate_non_negative_index("p", "M", M);
      current_statement__ = 8;
      validate_non_negative_index("p", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      
      current_statement__ = 8;
      if (lcm_sym231__) {
        current_statement__ = 8;
        if (lcm_sym232__) {
          lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym302__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym302__, "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym232__) {
            lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym302__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym302__, "assigning variable p");}
          } }
      } 
      current_statement__ = 9;
      validate_non_negative_index("b", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      
      current_statement__ = 9;
      if (lcm_sym232__) {
        lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
        assign(b, cons_list(index_uni(1), nil_index_list()), lcm_sym302__,
          "assigning variable b");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 9;
          assign(b, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym302__, "assigning variable b");}
      } 
      current_statement__ = 10;
      validate_non_negative_index("nu", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> nu;
      nu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      
      current_statement__ = 10;
      if (lcm_sym232__) {
        lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
        assign(nu, cons_list(index_uni(1), nil_index_list()), lcm_sym302__,
          "assigning variable nu");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 10;
          assign(nu, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym302__, "assigning variable nu");}
      } 
      current_statement__ = 11;
      validate_non_negative_index("chi", "M", M);
      current_statement__ = 11;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      
      current_statement__ = 11;
      if (lcm_sym231__) {
        current_statement__ = 11;
        if (lcm_sym232__) {
          lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym302__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 11;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym302__, "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 11;
          if (lcm_sym232__) {
            lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym302__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 11;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym302__, "assigning variable chi");}
          } }
      } 
      assign(lcm_sym296__, nil_index_list(),
        rep_matrix(mean_phi, M, lcm_sym246__),
        "assigning variable lcm_sym296__");
      assign(phi, nil_index_list(), lcm_sym296__, "assigning variable phi");
      current_statement__ = 13;
      if (lcm_sym232__) {
        assign(lcm_sym293__, nil_index_list(),
          inv_logit(add(logit(mean_p), epsilon)),
          "assigning variable lcm_sym293__");
        assign(p,
          cons_list(index_omni(), cons_list(index_uni(1), nil_index_list())),
          lcm_sym293__, "assigning variable p");
        for (size_t t = 2; t <= n_occasions; ++t) {
          current_statement__ = 12;
          assign(p,
            cons_list(index_omni(),
              cons_list(index_uni(t), nil_index_list())), lcm_sym293__,
            "assigning variable p");}
      } 
      assign(lcm_sym226__, nil_index_list(), divide(beta, sum(beta)),
        "assigning variable lcm_sym226__");
      assign(b, nil_index_list(), lcm_sym226__, "assigning variable b");
      {
        local_scalar_t__ cum_b;
        
        lcm_sym307__ = lcm_sym226__[(1 - 1)];
        current_statement__ = 15;
        assign(nu, cons_list(index_uni(1), nil_index_list()), lcm_sym307__,
          "assigning variable nu");
        current_statement__ = 19;
        if (logical_gte(lcm_sym246__, 2)) {
          current_statement__ = 16;
          assign(nu, cons_list(index_uni(2), nil_index_list()),
            (lcm_sym226__[(2 - 1)] / (1.0 - lcm_sym307__)),
            "assigning variable nu");
          current_statement__ = 17;
          cum_b = (lcm_sym307__ + lcm_sym226__[(2 - 1)]);
          for (size_t t = 3; t <= lcm_sym246__; ++t) {
            current_statement__ = 16;
            assign(nu, cons_list(index_uni(t), nil_index_list()),
              (lcm_sym226__[(t - 1)] / (1.0 - cum_b)),
              "assigning variable nu");
            current_statement__ = 17;
            cum_b = (cum_b + lcm_sym226__[(t - 1)]);}
        } 
        current_statement__ = 20;
        assign(nu, cons_list(index_uni(n_occasions), nil_index_list()), 1.0,
          "assigning variable nu");
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym17__;
      int inline_sym27__;
      
      inline_sym27__ = 0;
      for (size_t inline_sym28__ = 1; inline_sym28__ <= 1; ++inline_sym28__) {
        int inline_sym18__;
        
        lcm_sym297__ = rows(p);
        int inline_sym19__;
        
        lcm_sym289__ = cols(p);
        current_statement__ = 24;
        validate_non_negative_index("chi", "n_ind", lcm_sym297__);
        current_statement__ = 24;
        validate_non_negative_index("chi", "n_occasions", lcm_sym289__);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym20__;
        inline_sym20__ = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym297__, lcm_sym289__);
        
        for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym297__;
             ++inline_sym22__) {
          if (logical_gte(lcm_sym289__, 1)) {
            lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
            assign(inline_sym20__,
              cons_list(index_uni(inline_sym22__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym302__,
              "assigning variable inline_sym20__");
            for (size_t inline_sym21__ = 2; inline_sym21__ <= lcm_sym289__;
                 ++inline_sym21__) {
              current_statement__ = 24;
              assign(inline_sym20__,
                cons_list(index_uni(inline_sym22__),
                  cons_list(index_uni(inline_sym21__), nil_index_list())),
                lcm_sym302__, "assigning variable inline_sym20__");}
          } 
          if (inline_sym27__) {
            break;
          } }
        if (inline_sym27__) {
          break;
        } 
        for (size_t inline_sym26__ = 1; inline_sym26__ <= lcm_sym297__;
             ++inline_sym26__) {
          current_statement__ = 25;
          assign(inline_sym20__,
            cons_list(index_uni(inline_sym26__),
              cons_list(index_uni(lcm_sym289__), nil_index_list())), 1.0,
            "assigning variable inline_sym20__");
          lcm_sym251__ = (lcm_sym289__ - 1);
          if (logical_gte(lcm_sym251__, 1)) {
            int inline_sym23__;
            
            int inline_sym24__;
            
            lcm_sym256__ = (lcm_sym251__ + 1);
            current_statement__ = 28;
            assign(inline_sym20__,
              cons_list(index_uni(inline_sym26__),
                cons_list(index_uni(lcm_sym251__), nil_index_list())),
              stan::math::fma(
                (rvalue(lcm_sym296__,
                   cons_list(index_uni(inline_sym26__),
                     cons_list(index_uni(lcm_sym251__), nil_index_list())),
                   "lcm_sym296__") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym26__),
                        cons_list(index_uni(lcm_sym256__), nil_index_list())),
                      "p"))),
                rvalue(inline_sym20__,
                  cons_list(index_uni(inline_sym26__),
                    cons_list(index_uni(lcm_sym256__), nil_index_list())),
                  "inline_sym20__"),
                (1 -
                  rvalue(lcm_sym296__,
                    cons_list(index_uni(inline_sym26__),
                      cons_list(index_uni(lcm_sym251__), nil_index_list())),
                    "lcm_sym296__"))), "assigning variable inline_sym20__");
            for (size_t inline_sym25__ = 2; inline_sym25__ <= lcm_sym251__;
                 ++inline_sym25__) {
              int inline_sym23__;
              
              lcm_sym250__ = (lcm_sym289__ - inline_sym25__);
              int inline_sym24__;
              
              lcm_sym255__ = (lcm_sym250__ + 1);
              current_statement__ = 28;
              assign(inline_sym20__,
                cons_list(index_uni(inline_sym26__),
                  cons_list(index_uni(lcm_sym250__), nil_index_list())),
                stan::math::fma(
                  (rvalue(lcm_sym296__,
                     cons_list(index_uni(inline_sym26__),
                       cons_list(index_uni(lcm_sym250__), nil_index_list())),
                     "lcm_sym296__") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym26__),
                          cons_list(index_uni(lcm_sym255__),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym20__,
                    cons_list(index_uni(inline_sym26__),
                      cons_list(index_uni(lcm_sym255__), nil_index_list())),
                    "inline_sym20__"),
                  (1 -
                    rvalue(lcm_sym296__,
                      cons_list(index_uni(inline_sym26__),
                        cons_list(index_uni(lcm_sym250__), nil_index_list())),
                      "lcm_sym296__"))), "assigning variable inline_sym20__");
            }
          } 
          if (inline_sym27__) {
            break;
          } }
        if (inline_sym27__) {
          break;
        } 
        inline_sym27__ = 1;
        assign(inline_sym17__, nil_index_list(), inline_sym20__,
          "assigning variable inline_sym17__");
        break;}
      assign(chi, nil_index_list(), inline_sym17__, "assigning variable chi");
      current_statement__ = 7;
      current_statement__ = 7;
      check_greater_or_equal(function__, "phi", lcm_sym296__, 0);
      current_statement__ = 7;
      current_statement__ = 7;
      check_less_or_equal(function__, "phi", lcm_sym296__, 1);
      current_statement__ = 8;
      current_statement__ = 8;
      check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 8;
      current_statement__ = 8;
      check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 9;
      current_statement__ = 9;
      check_simplex(function__, "b", lcm_sym226__);
      current_statement__ = 10;
      current_statement__ = 10;
      check_greater_or_equal(function__, "nu", nu, 0);
      current_statement__ = 10;
      current_statement__ = 10;
      check_less_or_equal(function__, "nu", nu, 1);
      current_statement__ = 11;
      current_statement__ = 11;
      check_greater_or_equal(function__, "chi", inline_sym17__, 0);
      current_statement__ = 11;
      current_statement__ = 11;
      check_less_or_equal(function__, "chi", inline_sym17__, 1);
      {
        current_statement__ = 70;
        lp_accum__.add(normal_log<propto__>(epsilon, 0, sigma));
        current_statement__ = 71;
        lp_accum__.add(gamma_log<propto__>(beta, 1, 1));
        int inline_sym37__;
        
        {
          int inline_sym29__;
          
          lcm_sym308__ = dims(y)[(1 - 1)];
          int inline_sym30__;
          
          lcm_sym309__ = dims(y)[(2 - 1)];
          current_statement__ = 74;
          validate_non_negative_index("qnu", "n_occasions", lcm_sym309__);
          Eigen::Matrix<double, -1, 1> inline_sym31__;
          inline_sym31__ = Eigen::Matrix<double, -1, 1>(lcm_sym309__);
          
          assign(lcm_sym247__, nil_index_list(), subtract(1.0, nu),
            "assigning variable lcm_sym247__");
          lcm_sym244__ = logical_gte(lcm_sym308__, 1);
          if (lcm_sym244__) {
            current_statement__ = 75;
            validate_non_negative_index("qp", "n_occasions", lcm_sym309__);
            Eigen::Matrix<double, -1, 1> inline_sym33__;
            inline_sym33__ = Eigen::Matrix<double, -1, 1>(lcm_sym309__);
            
            assign(lcm_sym249__, nil_index_list(),
              subtract(1.0,
                transpose(
                  rvalue(p, cons_list(index_uni(1), nil_index_list()), "p"))),
              "assigning variable lcm_sym249__");
            lcm_sym304__ = first[(1 - 1)];
            if (lcm_sym304__) {
              current_statement__ = 82;
              lp_accum__.add(bernoulli_log<propto__>(1, psi));
              current_statement__ = 90;
              if (logical_eq(lcm_sym304__, 1)) {
                current_statement__ = 88;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    (nu[(1 - 1)] *
                      rvalue(p,
                        cons_list(index_uni(1),
                          cons_list(index_uni(1), nil_index_list())), "p"))));
              } else {
                current_statement__ = 83;
                validate_non_negative_index("lp", "first[(i - 1)]",
                                            lcm_sym304__);
                Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym34__;
                inline_sym34__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym304__);
                
                if (logical_gte(lcm_sym304__, 1)) {
                  lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
                  assign(inline_sym34__,
                    cons_list(index_uni(1), nil_index_list()), lcm_sym302__,
                    "assigning variable inline_sym34__");
                  for (size_t inline_sym32__ = 2;
                       inline_sym32__ <= lcm_sym304__; ++inline_sym32__) {
                    current_statement__ = 83;
                    assign(inline_sym34__,
                      cons_list(index_uni(inline_sym32__), nil_index_list()),
                      lcm_sym302__, "assigning variable inline_sym34__");}
                } 
                lcm_sym253__ = (lcm_sym304__ - 1);
                assign(inline_sym34__,
                  cons_list(index_uni(1), nil_index_list()),
                  (((bernoulli_lpmf<false>(1, nu[(1 - 1)]) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym249__,
                            cons_list(index_min_max(1, lcm_sym253__),
                              nil_index_list()), "lcm_sym249__")))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym296__,
                           cons_list(index_uni(1),
                             cons_list(index_min_max(1, lcm_sym253__),
                               nil_index_list())), "lcm_sym296__")))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p,
                        cons_list(index_uni(1),
                          cons_list(index_uni(lcm_sym304__),
                            nil_index_list())), "p"))),
                  "assigning variable inline_sym34__");
                if (logical_gte(lcm_sym253__, 2)) {
                  current_statement__ = 84;
                  assign(inline_sym34__,
                    cons_list(index_uni(2), nil_index_list()),
                    ((((bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym247__,
                              cons_list(index_min_max(1, 1),
                                nil_index_list()), "lcm_sym247__"))) +
                         bernoulli_lpmf<false>(1, nu[(2 - 1)])) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym249__,
                              cons_list(index_min_max(2, lcm_sym253__),
                                nil_index_list()), "lcm_sym249__")))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym296__,
                             cons_list(index_uni(1),
                               cons_list(index_min_max(2, lcm_sym253__),
                                 nil_index_list())), "lcm_sym296__")))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(p,
                          cons_list(index_uni(1),
                            cons_list(index_uni(lcm_sym304__),
                              nil_index_list())), "p"))),
                    "assigning variable inline_sym34__");
                  for (size_t inline_sym35__ = 3;
                       inline_sym35__ <= lcm_sym253__; ++inline_sym35__) {
                    current_statement__ = 84;
                    assign(inline_sym34__,
                      cons_list(index_uni(inline_sym35__), nil_index_list()),
                      ((((bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym247__,
                                cons_list(
                                  index_min_max(1, (inline_sym35__ - 1)),
                                  nil_index_list()), "lcm_sym247__"))) +
                           bernoulli_lpmf<false>(1, nu[(inline_sym35__ - 1)]))
                          +
                          bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym249__,
                                cons_list(
                                  index_min_max(inline_sym35__, lcm_sym253__),
                                  nil_index_list()), "lcm_sym249__")))) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym296__,
                               cons_list(index_uni(1),
                                 cons_list(
                                   index_min_max(inline_sym35__, lcm_sym253__),
                                   nil_index_list())), "lcm_sym296__")))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(p,
                            cons_list(index_uni(1),
                              cons_list(index_uni(lcm_sym304__),
                                nil_index_list())), "p"))),
                      "assigning variable inline_sym34__");}
                } 
                current_statement__ = 85;
                assign(inline_sym34__,
                  cons_list(index_uni(lcm_sym304__), nil_index_list()),
                  ((bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym247__,
                          cons_list(index_min_max(1, lcm_sym253__),
                            nil_index_list()), "lcm_sym247__"))) +
                     bernoulli_lpmf<false>(1, nu[(lcm_sym304__ - 1)])) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p,
                        cons_list(index_uni(1),
                          cons_list(index_uni(lcm_sym304__),
                            nil_index_list())), "p"))),
                  "assigning variable inline_sym34__");
                current_statement__ = 86;
                lp_accum__.add(log_sum_exp(inline_sym34__));
              }
              lcm_sym306__ = last[(1 - 1)];
              if (logical_gte(lcm_sym306__, (lcm_sym304__ + 1))) {
                current_statement__ = 91;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(lcm_sym296__,
                      cons_list(index_uni(1),
                        cons_list(index_uni(((lcm_sym304__ + 1) - 1)),
                          nil_index_list())), "lcm_sym296__")));
                lcm_sym272__ = ((lcm_sym304__ + 1) + 1);
                lp_accum__.add(
                  bernoulli_log<propto__>(
                    y[(1 - 1)][((lcm_sym304__ + 1) - 1)],
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((lcm_sym304__ + 1)),
                          nil_index_list())), "p")));
                for (size_t inline_sym35__ = lcm_sym272__;
                     inline_sym35__ <= lcm_sym306__; ++inline_sym35__) {
                  current_statement__ = 91;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      rvalue(lcm_sym296__,
                        cons_list(index_uni(1),
                          cons_list(index_uni((inline_sym35__ - 1)),
                            nil_index_list())), "lcm_sym296__")));
                  current_statement__ = 92;
                  lp_accum__.add(
                    bernoulli_log<propto__>(y[(1 - 1)][(inline_sym35__ - 1)],
                      rvalue(p,
                        cons_list(index_uni(1),
                          cons_list(index_uni(inline_sym35__),
                            nil_index_list())), "p")));}
              } 
              current_statement__ = 94;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(inline_sym17__,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym306__), nil_index_list())),
                    "inline_sym17__")));
            } else {
              lcm_sym274__ = (lcm_sym309__ + 1);
              validate_non_negative_index("lp", "(n_occasions + 1)",
                                          lcm_sym274__);
              Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym34__;
              inline_sym34__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym274__);
              
              if (logical_gte(lcm_sym274__, 1)) {
                lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
                assign(inline_sym34__,
                  cons_list(index_uni(1), nil_index_list()), lcm_sym302__,
                  "assigning variable inline_sym34__");
                for (size_t inline_sym32__ = 2;
                     inline_sym32__ <= lcm_sym274__; ++inline_sym32__) {
                  current_statement__ = 76;
                  assign(inline_sym34__,
                    cons_list(index_uni(inline_sym32__), nil_index_list()),
                    lcm_sym302__, "assigning variable inline_sym34__");}
              } 
              current_statement__ = 77;
              assign(inline_sym34__,
                cons_list(index_uni(1), nil_index_list()),
                (((bernoulli_lpmf<false>(1, psi) +
                    bernoulli_lpmf<false>(1, nu[(1 - 1)])) +
                   bernoulli_lpmf<false>(0,
                     rvalue(p,
                       cons_list(index_uni(1),
                         cons_list(index_uni(1), nil_index_list())), "p"))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(inline_sym17__,
                      cons_list(index_uni(1),
                        cons_list(index_uni(1), nil_index_list())),
                      "inline_sym17__"))),
                "assigning variable inline_sym34__");
              if (logical_gte(lcm_sym309__, 2)) {
                current_statement__ = 78;
                assign(inline_sym34__,
                  cons_list(index_uni(2), nil_index_list()),
                  ((((bernoulli_lpmf<false>(1, psi) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym247__,
                             cons_list(index_min_max(1, 1), nil_index_list()),
                             "lcm_sym247__")))) +
                      bernoulli_lpmf<false>(1, nu[(2 - 1)])) +
                     bernoulli_lpmf<false>(0,
                       rvalue(p,
                         cons_list(index_uni(1),
                           cons_list(index_uni(2), nil_index_list())), "p")))
                    +
                    bernoulli_lpmf<false>(1,
                      rvalue(inline_sym17__,
                        cons_list(index_uni(1),
                          cons_list(index_uni(2), nil_index_list())),
                        "inline_sym17__"))),
                  "assigning variable inline_sym34__");
                for (size_t inline_sym35__ = 3;
                     inline_sym35__ <= lcm_sym309__; ++inline_sym35__) {
                  current_statement__ = 78;
                  assign(inline_sym34__,
                    cons_list(index_uni(inline_sym35__), nil_index_list()),
                    ((((bernoulli_lpmf<false>(1, psi) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym247__,
                               cons_list(
                                 index_min_max(1, (inline_sym35__ - 1)),
                                 nil_index_list()), "lcm_sym247__")))) +
                        bernoulli_lpmf<false>(1, nu[(inline_sym35__ - 1)])) +
                       bernoulli_lpmf<false>(0,
                         rvalue(p,
                           cons_list(index_uni(1),
                             cons_list(index_uni(inline_sym35__),
                               nil_index_list())), "p"))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(inline_sym17__,
                          cons_list(index_uni(1),
                            cons_list(index_uni(inline_sym35__),
                              nil_index_list())), "inline_sym17__"))),
                    "assigning variable inline_sym34__");}
              } 
              current_statement__ = 79;
              assign(inline_sym34__,
                cons_list(index_uni(lcm_sym274__), nil_index_list()),
                bernoulli_lpmf<false>(0, psi),
                "assigning variable inline_sym34__");
              current_statement__ = 80;
              lp_accum__.add(log_sum_exp(inline_sym34__));
            }
            for (size_t inline_sym36__ = 2; inline_sym36__ <= lcm_sym308__;
                 ++inline_sym36__) {
              current_statement__ = 75;
              validate_non_negative_index("qp", "n_occasions", lcm_sym309__);
              Eigen::Matrix<double, -1, 1> inline_sym33__;
              inline_sym33__ = Eigen::Matrix<double, -1, 1>(lcm_sym309__);
              
              assign(lcm_sym248__, nil_index_list(),
                subtract(1.0,
                  transpose(
                    rvalue(p,
                      cons_list(index_uni(inline_sym36__), nil_index_list()),
                      "p"))), "assigning variable lcm_sym248__");
              lcm_sym303__ = first[(inline_sym36__ - 1)];
              if (lcm_sym303__) {
                current_statement__ = 82;
                lp_accum__.add(bernoulli_log<propto__>(1, psi));
                current_statement__ = 90;
                if (logical_eq(lcm_sym303__, 1)) {
                  current_statement__ = 88;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      (nu[(1 - 1)] *
                        rvalue(p,
                          cons_list(index_uni(inline_sym36__),
                            cons_list(index_uni(1), nil_index_list())), "p"))));
                } else {
                  current_statement__ = 83;
                  validate_non_negative_index("lp", "first[(i - 1)]",
                                              lcm_sym303__);
                  Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym34__;
                  inline_sym34__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym303__);
                  
                  if (logical_gte(lcm_sym303__, 1)) {
                    lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
                    assign(inline_sym34__,
                      cons_list(index_uni(1), nil_index_list()),
                      lcm_sym302__, "assigning variable inline_sym34__");
                    for (size_t inline_sym32__ = 2;
                         inline_sym32__ <= lcm_sym303__; ++inline_sym32__) {
                      current_statement__ = 83;
                      assign(inline_sym34__,
                        cons_list(index_uni(inline_sym32__),
                          nil_index_list()), lcm_sym302__,
                        "assigning variable inline_sym34__");}
                  } 
                  lcm_sym252__ = (lcm_sym303__ - 1);
                  assign(inline_sym34__,
                    cons_list(index_uni(1), nil_index_list()),
                    (((bernoulli_lpmf<false>(1, nu[(1 - 1)]) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym248__,
                              cons_list(index_min_max(1, lcm_sym252__),
                                nil_index_list()), "lcm_sym248__")))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym296__,
                             cons_list(index_uni(inline_sym36__),
                               cons_list(index_min_max(1, lcm_sym252__),
                                 nil_index_list())), "lcm_sym296__")))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(p,
                          cons_list(index_uni(inline_sym36__),
                            cons_list(index_uni(lcm_sym303__),
                              nil_index_list())), "p"))),
                    "assigning variable inline_sym34__");
                  if (logical_gte(lcm_sym252__, 2)) {
                    current_statement__ = 84;
                    assign(inline_sym34__,
                      cons_list(index_uni(2), nil_index_list()),
                      ((((bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym247__,
                                cons_list(index_min_max(1, 1),
                                  nil_index_list()), "lcm_sym247__"))) +
                           bernoulli_lpmf<false>(1, nu[(2 - 1)])) +
                          bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym248__,
                                cons_list(index_min_max(2, lcm_sym252__),
                                  nil_index_list()), "lcm_sym248__")))) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym296__,
                               cons_list(index_uni(inline_sym36__),
                                 cons_list(index_min_max(2, lcm_sym252__),
                                   nil_index_list())), "lcm_sym296__")))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(p,
                            cons_list(index_uni(inline_sym36__),
                              cons_list(index_uni(lcm_sym303__),
                                nil_index_list())), "p"))),
                      "assigning variable inline_sym34__");
                    for (size_t inline_sym35__ = 3;
                         inline_sym35__ <= lcm_sym252__; ++inline_sym35__) {
                      current_statement__ = 84;
                      assign(inline_sym34__,
                        cons_list(index_uni(inline_sym35__),
                          nil_index_list()),
                        ((((bernoulli_lpmf<false>(1,
                              prod(
                                rvalue(lcm_sym247__,
                                  cons_list(
                                    index_min_max(1, (inline_sym35__ - 1)),
                                    nil_index_list()), "lcm_sym247__"))) +
                             bernoulli_lpmf<false>(1,
                               nu[(inline_sym35__ - 1)])) +
                            bernoulli_lpmf<false>(1,
                              prod(
                                rvalue(lcm_sym248__,
                                  cons_list(
                                    index_min_max(inline_sym35__, lcm_sym252__),
                                    nil_index_list()), "lcm_sym248__")))) +
                           bernoulli_lpmf<false>(1,
                             prod(
                               rvalue(lcm_sym296__,
                                 cons_list(index_uni(inline_sym36__),
                                   cons_list(
                                     index_min_max(inline_sym35__, lcm_sym252__),
                                     nil_index_list())), "lcm_sym296__")))) +
                          bernoulli_lpmf<false>(1,
                            rvalue(p,
                              cons_list(index_uni(inline_sym36__),
                                cons_list(index_uni(lcm_sym303__),
                                  nil_index_list())), "p"))),
                        "assigning variable inline_sym34__");}
                  } 
                  current_statement__ = 85;
                  assign(inline_sym34__,
                    cons_list(index_uni(lcm_sym303__), nil_index_list()),
                    ((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym247__,
                            cons_list(index_min_max(1, lcm_sym252__),
                              nil_index_list()), "lcm_sym247__"))) +
                       bernoulli_lpmf<false>(1, nu[(lcm_sym303__ - 1)])) +
                      bernoulli_lpmf<false>(1,
                        rvalue(p,
                          cons_list(index_uni(inline_sym36__),
                            cons_list(index_uni(lcm_sym303__),
                              nil_index_list())), "p"))),
                    "assigning variable inline_sym34__");
                  current_statement__ = 86;
                  lp_accum__.add(log_sum_exp(inline_sym34__));
                }
                lcm_sym305__ = last[(inline_sym36__ - 1)];
                if (logical_gte(lcm_sym305__, (lcm_sym303__ + 1))) {
                  current_statement__ = 91;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      rvalue(lcm_sym296__,
                        cons_list(index_uni(inline_sym36__),
                          cons_list(index_uni(((lcm_sym303__ + 1) - 1)),
                            nil_index_list())), "lcm_sym296__")));
                  lcm_sym271__ = ((lcm_sym303__ + 1) + 1);
                  lp_accum__.add(
                    bernoulli_log<propto__>(
                      y[(inline_sym36__ - 1)][((lcm_sym303__ + 1) - 1)],
                      rvalue(p,
                        cons_list(index_uni(inline_sym36__),
                          cons_list(index_uni((lcm_sym303__ + 1)),
                            nil_index_list())), "p")));
                  for (size_t inline_sym35__ = lcm_sym271__;
                       inline_sym35__ <= lcm_sym305__; ++inline_sym35__) {
                    current_statement__ = 91;
                    lp_accum__.add(
                      bernoulli_log<propto__>(1,
                        rvalue(lcm_sym296__,
                          cons_list(index_uni(inline_sym36__),
                            cons_list(index_uni((inline_sym35__ - 1)),
                              nil_index_list())), "lcm_sym296__")));
                    current_statement__ = 92;
                    lp_accum__.add(
                      bernoulli_log<propto__>(
                        y[(inline_sym36__ - 1)][(inline_sym35__ - 1)],
                        rvalue(p,
                          cons_list(index_uni(inline_sym36__),
                            cons_list(index_uni(inline_sym35__),
                              nil_index_list())), "p")));}
                } 
                current_statement__ = 94;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(inline_sym17__,
                      cons_list(index_uni(inline_sym36__),
                        cons_list(index_uni(lcm_sym305__), nil_index_list())),
                      "inline_sym17__")));
              } else {
                lcm_sym274__ = (lcm_sym309__ + 1);
                validate_non_negative_index("lp", "(n_occasions + 1)",
                                            lcm_sym274__);
                Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym34__;
                inline_sym34__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym274__);
                
                if (logical_gte(lcm_sym274__, 1)) {
                  lcm_sym302__ = std::numeric_limits<double>::quiet_NaN();
                  assign(inline_sym34__,
                    cons_list(index_uni(1), nil_index_list()), lcm_sym302__,
                    "assigning variable inline_sym34__");
                  for (size_t inline_sym32__ = 2;
                       inline_sym32__ <= lcm_sym274__; ++inline_sym32__) {
                    current_statement__ = 76;
                    assign(inline_sym34__,
                      cons_list(index_uni(inline_sym32__), nil_index_list()),
                      lcm_sym302__, "assigning variable inline_sym34__");}
                } 
                current_statement__ = 77;
                assign(inline_sym34__,
                  cons_list(index_uni(1), nil_index_list()),
                  (((bernoulli_lpmf<false>(1, psi) +
                      bernoulli_lpmf<false>(1, nu[(1 - 1)])) +
                     bernoulli_lpmf<false>(0,
                       rvalue(p,
                         cons_list(index_uni(inline_sym36__),
                           cons_list(index_uni(1), nil_index_list())), "p")))
                    +
                    bernoulli_lpmf<false>(1,
                      rvalue(inline_sym17__,
                        cons_list(index_uni(inline_sym36__),
                          cons_list(index_uni(1), nil_index_list())),
                        "inline_sym17__"))),
                  "assigning variable inline_sym34__");
                if (logical_gte(lcm_sym309__, 2)) {
                  current_statement__ = 78;
                  assign(inline_sym34__,
                    cons_list(index_uni(2), nil_index_list()),
                    ((((bernoulli_lpmf<false>(1, psi) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym247__,
                               cons_list(index_min_max(1, 1),
                                 nil_index_list()), "lcm_sym247__")))) +
                        bernoulli_lpmf<false>(1, nu[(2 - 1)])) +
                       bernoulli_lpmf<false>(0,
                         rvalue(p,
                           cons_list(index_uni(inline_sym36__),
                             cons_list(index_uni(2), nil_index_list())), "p")))
                      +
                      bernoulli_lpmf<false>(1,
                        rvalue(inline_sym17__,
                          cons_list(index_uni(inline_sym36__),
                            cons_list(index_uni(2), nil_index_list())),
                          "inline_sym17__"))),
                    "assigning variable inline_sym34__");
                  for (size_t inline_sym35__ = 3;
                       inline_sym35__ <= lcm_sym309__; ++inline_sym35__) {
                    current_statement__ = 78;
                    assign(inline_sym34__,
                      cons_list(index_uni(inline_sym35__), nil_index_list()),
                      ((((bernoulli_lpmf<false>(1, psi) +
                           bernoulli_lpmf<false>(1,
                             prod(
                               rvalue(lcm_sym247__,
                                 cons_list(
                                   index_min_max(1, (inline_sym35__ - 1)),
                                   nil_index_list()), "lcm_sym247__")))) +
                          bernoulli_lpmf<false>(1, nu[(inline_sym35__ - 1)]))
                         +
                         bernoulli_lpmf<false>(0,
                           rvalue(p,
                             cons_list(index_uni(inline_sym36__),
                               cons_list(index_uni(inline_sym35__),
                                 nil_index_list())), "p"))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(inline_sym17__,
                            cons_list(index_uni(inline_sym36__),
                              cons_list(index_uni(inline_sym35__),
                                nil_index_list())), "inline_sym17__"))),
                      "assigning variable inline_sym34__");}
                } 
                current_statement__ = 79;
                assign(inline_sym34__,
                  cons_list(index_uni(lcm_sym274__), nil_index_list()),
                  bernoulli_lpmf<false>(0, psi),
                  "assigning variable inline_sym34__");
                current_statement__ = 80;
                lp_accum__.add(log_sum_exp(inline_sym34__));
              }}
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail6_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      int lcm_sym225__;
      int lcm_sym224__;
      double lcm_sym223__;
      double lcm_sym222__;
      double lcm_sym221__;
      double lcm_sym220__;
      local_scalar_t__ lcm_sym219__;
      double lcm_sym218__;
      double lcm_sym217__;
      int lcm_sym216__;
      int lcm_sym215__;
      int lcm_sym214__;
      int lcm_sym213__;
      int lcm_sym212__;
      int lcm_sym211__;
      int lcm_sym210__;
      double lcm_sym209__;
      double lcm_sym208__;
      double lcm_sym207__;
      double lcm_sym206__;
      double lcm_sym170__;
      double lcm_sym205__;
      double lcm_sym204__;
      double lcm_sym203__;
      double lcm_sym202__;
      double lcm_sym201__;
      double lcm_sym200__;
      double lcm_sym199__;
      double lcm_sym198__;
      double lcm_sym197__;
      double lcm_sym196__;
      int lcm_sym195__;
      int lcm_sym194__;
      int lcm_sym193__;
      int lcm_sym192__;
      double lcm_sym191__;
      int lcm_sym188__;
      int lcm_sym187__;
      int lcm_sym186__;
      int lcm_sym185__;
      int lcm_sym184__;
      int lcm_sym183__;
      int lcm_sym182__;
      double lcm_sym181__;
      int lcm_sym180__;
      int lcm_sym179__;
      int lcm_sym178__;
      Eigen::Matrix<double, -1, -1> lcm_sym177__;
      std::vector<int> lcm_sym176__;
      std::vector<std::vector<int>> lcm_sym175__;
      Eigen::Matrix<double, -1, 1> lcm_sym174__;
      double lcm_sym169__;
      double lcm_sym168__;
      double lcm_sym167__;
      double lcm_sym166__;
      double lcm_sym173__;
      double lcm_sym172__;
      int lcm_sym171__;
      int lcm_sym165__;
      int lcm_sym164__;
      int lcm_sym163__;
      int lcm_sym162__;
      double lcm_sym161__;
      int lcm_sym160__;
      int lcm_sym159__;
      double lcm_sym158__;
      int lcm_sym157__;
      int lcm_sym156__;
      int lcm_sym155__;
      int lcm_sym154__;
      int lcm_sym153__;
      int lcm_sym152__;
      int lcm_sym151__;
      int lcm_sym150__;
      int lcm_sym149__;
      int lcm_sym148__;
      int lcm_sym147__;
      int lcm_sym146__;
      int lcm_sym145__;
      int lcm_sym144__;
      int lcm_sym143__;
      double lcm_sym142__;
      double lcm_sym141__;
      Eigen::Matrix<double, -1, 1> lcm_sym140__;
      double mean_phi;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      double mean_p;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      double psi;
      
      current_statement__ = 3;
      psi = in__.scalar();
      current_statement__ = 3;
      psi = stan::math::lub_constrain(psi, 0, 1);
      current_statement__ = 4;
      validate_non_negative_index("beta", "n_occasions", n_occasions);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(n_occasions);
      
      current_statement__ = 4;
      beta = in__.vector(n_occasions);
      lcm_sym144__ = logical_gte(n_occasions, 1);
      if (lcm_sym144__) {
        current_statement__ = 4;
        assign(beta, cons_list(index_uni(1), nil_index_list()),
          stan::math::lb_constrain(beta[(1 - 1)], 0),
          "assigning variable beta");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(beta[(sym1__ - 1)], 0),
            "assigning variable beta");}
      } 
      current_statement__ = 5;
      validate_non_negative_index("epsilon", "M", M);
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(M);
      
      current_statement__ = 5;
      epsilon = in__.vector(M);
      double sigma;
      
      current_statement__ = 6;
      sigma = in__.scalar();
      current_statement__ = 6;
      sigma = stan::math::lub_constrain(sigma, 0, 5);
      current_statement__ = 7;
      validate_non_negative_index("phi", "M", M);
      lcm_sym153__ = (n_occasions - 1);
      validate_non_negative_index("phi", "(n_occasions - 1)", lcm_sym153__);
      Eigen::Matrix<double, -1, -1> phi;
      phi = Eigen::Matrix<double, -1, -1>(M, lcm_sym153__);
      
      lcm_sym143__ = logical_gte(M, 1);
      if (lcm_sym143__) {
        {
          lcm_sym146__ = logical_gte(lcm_sym153__, 1);
          if (lcm_sym146__) {
            {
              lcm_sym191__ = std::numeric_limits<double>::quiet_NaN();
              assign(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym191__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
                current_statement__ = 7;
                assign(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym191__, "assigning variable phi");}
            }
          } else {
            lcm_sym191__ = std::numeric_limits<double>::quiet_NaN();
          }
          for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
            current_statement__ = 7;
            if (lcm_sym146__) {
              current_statement__ = 7;
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym191__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
                current_statement__ = 7;
                assign(phi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym191__, "assigning variable phi");}
            } }
        }
      } else {
        lcm_sym191__ = std::numeric_limits<double>::quiet_NaN();
        lcm_sym146__ = logical_gte(lcm_sym153__, 1);
      }
      current_statement__ = 8;
      validate_non_negative_index("p", "M", M);
      current_statement__ = 8;
      validate_non_negative_index("p", "n_occasions", n_occasions);
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(M, n_occasions);
      
      current_statement__ = 8;
      if (lcm_sym143__) {
        current_statement__ = 8;
        if (lcm_sym144__) {
          current_statement__ = 8;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym191__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym191__, "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym144__) {
            current_statement__ = 8;
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym191__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym191__, "assigning variable p");}
          } }
      } 
      current_statement__ = 9;
      validate_non_negative_index("b", "n_occasions", n_occasions);
      Eigen::Matrix<double, -1, 1> b;
      b = Eigen::Matrix<double, -1, 1>(n_occasions);
      
      current_statement__ = 9;
      if (lcm_sym144__) {
        current_statement__ = 9;
        assign(b, cons_list(index_uni(1), nil_index_list()), lcm_sym191__,
          "assigning variable b");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 9;
          assign(b, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym191__, "assigning variable b");}
      } 
      current_statement__ = 10;
      validate_non_negative_index("nu", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> nu;
      nu = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      
      current_statement__ = 10;
      if (lcm_sym144__) {
        current_statement__ = 10;
        assign(nu, cons_list(index_uni(1), nil_index_list()), lcm_sym191__,
          "assigning variable nu");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 10;
          assign(nu, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym191__, "assigning variable nu");}
      } 
      current_statement__ = 11;
      validate_non_negative_index("chi", "M", M);
      current_statement__ = 11;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      
      current_statement__ = 11;
      if (lcm_sym143__) {
        current_statement__ = 11;
        if (lcm_sym144__) {
          current_statement__ = 11;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym191__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 11;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym191__, "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 11;
          if (lcm_sym144__) {
            current_statement__ = 11;
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym191__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 11;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym191__, "assigning variable chi");}
          } }
      } 
      vars__.push_back(mean_phi);
      vars__.push_back(mean_p);
      vars__.push_back(psi);
      if (lcm_sym144__) {
        vars__.push_back(beta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(beta[(sym1__ - 1)]);}
      } 
      if (lcm_sym143__) {
        vars__.push_back(epsilon[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          vars__.push_back(epsilon[(sym1__ - 1)]);}
      } 
      vars__.push_back(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      assign(lcm_sym177__, nil_index_list(),
        rep_matrix(mean_phi, M, lcm_sym153__),
        "assigning variable lcm_sym177__");
      assign(phi, nil_index_list(), lcm_sym177__, "assigning variable phi");
      current_statement__ = 13;
      if (lcm_sym144__) {
        assign(lcm_sym174__, nil_index_list(),
          inv_logit(add(logit(mean_p), epsilon)),
          "assigning variable lcm_sym174__");
        assign(p,
          cons_list(index_omni(), cons_list(index_uni(1), nil_index_list())),
          lcm_sym174__, "assigning variable p");
        for (size_t t = 2; t <= n_occasions; ++t) {
          current_statement__ = 12;
          assign(p,
            cons_list(index_omni(),
              cons_list(index_uni(t), nil_index_list())), lcm_sym174__,
            "assigning variable p");}
      } 
      assign(lcm_sym140__, nil_index_list(), divide(beta, sum(beta)),
        "assigning variable lcm_sym140__");
      assign(b, nil_index_list(), lcm_sym140__, "assigning variable b");
      {
        local_scalar_t__ cum_b;
        
        lcm_sym219__ = lcm_sym140__[(1 - 1)];
        current_statement__ = 15;
        assign(nu, cons_list(index_uni(1), nil_index_list()), lcm_sym219__,
          "assigning variable nu");
        current_statement__ = 19;
        if (logical_gte(lcm_sym153__, 2)) {
          current_statement__ = 16;
          assign(nu, cons_list(index_uni(2), nil_index_list()),
            (lcm_sym140__[(2 - 1)] / (1.0 - lcm_sym219__)),
            "assigning variable nu");
          current_statement__ = 17;
          cum_b = (lcm_sym219__ + lcm_sym140__[(2 - 1)]);
          for (size_t t = 3; t <= lcm_sym153__; ++t) {
            current_statement__ = 16;
            assign(nu, cons_list(index_uni(t), nil_index_list()),
              (lcm_sym140__[(t - 1)] / (1.0 - cum_b)),
              "assigning variable nu");
            current_statement__ = 17;
            cum_b = (cum_b + lcm_sym140__[(t - 1)]);}
        } 
        current_statement__ = 20;
        assign(nu, cons_list(index_uni(n_occasions), nil_index_list()), 1.0,
          "assigning variable nu");
      }
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym11__;
      
      inline_sym11__ = 0;
      for (size_t inline_sym12__ = 1; inline_sym12__ <= 1; ++inline_sym12__) {
        int inline_sym2__;
        
        lcm_sym178__ = rows(p);
        int inline_sym3__;
        
        lcm_sym171__ = cols(p);
        current_statement__ = 24;
        validate_non_negative_index("chi", "n_ind", lcm_sym178__);
        current_statement__ = 24;
        validate_non_negative_index("chi", "n_occasions", lcm_sym171__);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym4__;
        inline_sym4__ = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym178__, lcm_sym171__);
        
        for (size_t inline_sym6__ = 1; inline_sym6__ <= lcm_sym178__;
             ++inline_sym6__) {
          if (logical_gte(lcm_sym171__, 1)) {
            current_statement__ = 24;
            assign(inline_sym4__,
              cons_list(index_uni(inline_sym6__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym191__,
              "assigning variable inline_sym4__");
            for (size_t inline_sym5__ = 2; inline_sym5__ <= lcm_sym171__;
                 ++inline_sym5__) {
              current_statement__ = 24;
              assign(inline_sym4__,
                cons_list(index_uni(inline_sym6__),
                  cons_list(index_uni(inline_sym5__), nil_index_list())),
                lcm_sym191__, "assigning variable inline_sym4__");}
          } 
          if (inline_sym11__) {
            break;
          } }
        if (inline_sym11__) {
          break;
        } 
        for (size_t inline_sym10__ = 1; inline_sym10__ <= lcm_sym178__;
             ++inline_sym10__) {
          current_statement__ = 25;
          assign(inline_sym4__,
            cons_list(index_uni(inline_sym10__),
              cons_list(index_uni(lcm_sym171__), nil_index_list())), 1.0,
            "assigning variable inline_sym4__");
          lcm_sym155__ = (lcm_sym171__ - 1);
          if (logical_gte(lcm_sym155__, 1)) {
            int inline_sym7__;
            
            int inline_sym8__;
            
            lcm_sym160__ = (lcm_sym155__ + 1);
            current_statement__ = 28;
            assign(inline_sym4__,
              cons_list(index_uni(inline_sym10__),
                cons_list(index_uni(lcm_sym155__), nil_index_list())),
              stan::math::fma(
                (rvalue(lcm_sym177__,
                   cons_list(index_uni(inline_sym10__),
                     cons_list(index_uni(lcm_sym155__), nil_index_list())),
                   "lcm_sym177__") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym10__),
                        cons_list(index_uni(lcm_sym160__), nil_index_list())),
                      "p"))),
                rvalue(inline_sym4__,
                  cons_list(index_uni(inline_sym10__),
                    cons_list(index_uni(lcm_sym160__), nil_index_list())),
                  "inline_sym4__"),
                (1 -
                  rvalue(lcm_sym177__,
                    cons_list(index_uni(inline_sym10__),
                      cons_list(index_uni(lcm_sym155__), nil_index_list())),
                    "lcm_sym177__"))), "assigning variable inline_sym4__");
            for (size_t inline_sym9__ = 2; inline_sym9__ <= lcm_sym155__;
                 ++inline_sym9__) {
              int inline_sym7__;
              
              lcm_sym154__ = (lcm_sym171__ - inline_sym9__);
              int inline_sym8__;
              
              lcm_sym159__ = (lcm_sym154__ + 1);
              current_statement__ = 28;
              assign(inline_sym4__,
                cons_list(index_uni(inline_sym10__),
                  cons_list(index_uni(lcm_sym154__), nil_index_list())),
                stan::math::fma(
                  (rvalue(lcm_sym177__,
                     cons_list(index_uni(inline_sym10__),
                       cons_list(index_uni(lcm_sym154__), nil_index_list())),
                     "lcm_sym177__") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym10__),
                          cons_list(index_uni(lcm_sym159__),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym4__,
                    cons_list(index_uni(inline_sym10__),
                      cons_list(index_uni(lcm_sym159__), nil_index_list())),
                    "inline_sym4__"),
                  (1 -
                    rvalue(lcm_sym177__,
                      cons_list(index_uni(inline_sym10__),
                        cons_list(index_uni(lcm_sym154__), nil_index_list())),
                      "lcm_sym177__"))), "assigning variable inline_sym4__");
            }
          } 
          if (inline_sym11__) {
            break;
          } }
        if (inline_sym11__) {
          break;
        } 
        inline_sym11__ = 1;
        assign(inline_sym1__, nil_index_list(), inline_sym4__,
          "assigning variable inline_sym1__");
        break;}
      assign(chi, nil_index_list(), inline_sym1__, "assigning variable chi");
      if (lcm_sym146__) {
        if (lcm_sym143__) {
          vars__.push_back(
            rvalue(lcm_sym177__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "lcm_sym177__"));
          for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
            vars__.push_back(
              rvalue(lcm_sym177__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "lcm_sym177__"));
          }
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym153__; ++sym1__) {
          if (lcm_sym143__) {
            vars__.push_back(
              rvalue(lcm_sym177__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "lcm_sym177__"));
            for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
              vars__.push_back(
                rvalue(lcm_sym177__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "lcm_sym177__"));}
          } }
      } 
      if (lcm_sym144__) {
        if (lcm_sym143__) {
          vars__.push_back(
            rvalue(p,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "p"));
          for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "p"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym143__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));
            for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
              vars__.push_back(
                rvalue(p,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "p"));}
          } }
      } 
      if (lcm_sym144__) {
        vars__.push_back(lcm_sym140__[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(lcm_sym140__[(sym1__ - 1)]);}
      } 
      if (lcm_sym144__) {
        vars__.push_back(nu[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(nu[(sym1__ - 1)]);}
      } 
      if (lcm_sym144__) {
        if (lcm_sym143__) {
          vars__.push_back(
            rvalue(inline_sym1__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "inline_sym1__"));
          for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                "inline_sym1__"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym143__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "inline_sym1__"));
            for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
              vars__.push_back(
                rvalue(inline_sym1__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "inline_sym1__"));}
          } }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      
      current_statement__ = 32;
      sigma2 = lcm_sym191__;
      int Nsuper;
      
      current_statement__ = 34;
      validate_non_negative_index("N", "n_occasions", n_occasions);
      std::vector<int> N;
      N = std::vector<int>(n_occasions, 0);
      
      current_statement__ = 35;
      validate_non_negative_index("B", "n_occasions", n_occasions);
      std::vector<int> B;
      B = std::vector<int>(n_occasions, 0);
      
      current_statement__ = 36;
      validate_non_negative_index("z", "M", M);
      current_statement__ = 36;
      validate_non_negative_index("z", "n_occasions", n_occasions);
      std::vector<std::vector<int>> z;
      z = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, 0));
      
      lcm_sym181__ = square(sigma);
      sigma2 = lcm_sym181__;
      current_statement__ = 48;
      if (lcm_sym143__) {
        int q;
        
        current_statement__ = 46;
        if (bernoulli_rng(psi, base_rng__)) {
          current_statement__ = 40;
          assign(z,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())),
            bernoulli_rng(nu[(1 - 1)], base_rng__), "assigning variable z");
          current_statement__ = 44;
          if (logical_gte(n_occasions, 2)) {
            lcm_sym216__ = z[(1 - 1)][(1 - 1)];
            lcm_sym165__ = (1 * (1 - lcm_sym216__));
            q = lcm_sym165__;
            current_statement__ = 41;
            assign(z,
              cons_list(index_uni(1),
                cons_list(index_uni(2), nil_index_list())),
              bernoulli_rng(
                stan::math::fma(lcm_sym216__,
                  rvalue(lcm_sym177__,
                    cons_list(index_uni(1),
                      cons_list(index_uni(1), nil_index_list())),
                    "lcm_sym177__"), (lcm_sym165__ * nu[(2 - 1)])),
                base_rng__), "assigning variable z");
            for (size_t t = 3; t <= n_occasions; ++t) {
              current_statement__ = 42;
              q = (q * (1 - z[(1 - 1)][((t - 1) - 1)]));
              current_statement__ = 41;
              assign(z,
                cons_list(index_uni(1),
                  cons_list(index_uni(t), nil_index_list())),
                bernoulli_rng(
                  stan::math::fma(z[(1 - 1)][((t - 1) - 1)],
                    rvalue(lcm_sym177__,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "lcm_sym177__"), (q * nu[(t - 1)])), base_rng__),
                "assigning variable z");}
          } 
        } else {
          current_statement__ = 38;
          assign(z,
            cons_list(index_uni(1),
              cons_list(index_omni(), nil_index_list())),
            rep_array(0, n_occasions), "assigning variable z");
        }
        for (size_t i = 2; i <= M; ++i) {
          int q;
          
          current_statement__ = 46;
          if (bernoulli_rng(psi, base_rng__)) {
            current_statement__ = 40;
            assign(z,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())),
              bernoulli_rng(nu[(1 - 1)], base_rng__), "assigning variable z");
            current_statement__ = 44;
            if (logical_gte(n_occasions, 2)) {
              lcm_sym164__ = (1 * (1 - z[(i - 1)][(1 - 1)]));
              q = lcm_sym164__;
              current_statement__ = 41;
              assign(z,
                cons_list(index_uni(i),
                  cons_list(index_uni(2), nil_index_list())),
                bernoulli_rng(
                  stan::math::fma(z[(i - 1)][(1 - 1)],
                    rvalue(lcm_sym177__,
                      cons_list(index_uni(i),
                        cons_list(index_uni(1), nil_index_list())),
                      "lcm_sym177__"), (lcm_sym164__ * nu[(2 - 1)])),
                  base_rng__), "assigning variable z");
              for (size_t t = 3; t <= n_occasions; ++t) {
                current_statement__ = 42;
                q = (q * (1 - z[(i - 1)][((t - 1) - 1)]));
                current_statement__ = 41;
                assign(z,
                  cons_list(index_uni(i),
                    cons_list(index_uni(t), nil_index_list())),
                  bernoulli_rng(
                    stan::math::fma(z[(i - 1)][((t - 1) - 1)],
                      rvalue(lcm_sym177__,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "lcm_sym177__"), (q * nu[(t - 1)])), base_rng__),
                  "assigning variable z");}
            } 
          } else {
            current_statement__ = 38;
            assign(z,
              cons_list(index_uni(i),
                cons_list(index_omni(), nil_index_list())),
              rep_array(0, n_occasions), "assigning variable z");
          }}
      } 
      {
        current_statement__ = 49;
        validate_non_negative_index("recruit", "M", M);
        current_statement__ = 49;
        validate_non_negative_index("recruit", "n_occasions", n_occasions);
        std::vector<std::vector<int>> recruit;
        recruit = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, 0));
        
        current_statement__ = 49;
        assign(recruit, nil_index_list(), rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 50;
        validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind;
        Nind = std::vector<int>(M, 0);
        
        current_statement__ = 51;
        validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive;
        Nalive = std::vector<int>(M, 0);
        
        current_statement__ = 59;
        if (lcm_sym143__) {
          int f;
          
          int inline_sym13__;
          int inline_sym15__;
          
          inline_sym15__ = 0;
          for (size_t inline_sym16__ = 1; inline_sym16__ <= 1;
               ++inline_sym16__) {
            lcm_sym180__ = size(z[(1 - 1)]);
            for (size_t inline_sym14__ = 1; inline_sym14__ <= lcm_sym180__;
                 ++inline_sym14__) {
              current_statement__ = 54;
              if (z[(1 - 1)][(inline_sym14__ - 1)]) {
                inline_sym15__ = 1;
                inline_sym13__ = inline_sym14__;
                break;
              } }
            if (inline_sym15__) {
              break;
            } 
            inline_sym15__ = 1;
            inline_sym13__ = 0;
            break;}
          current_statement__ = 57;
          if (logical_gt(inline_sym13__, 0)) {
            current_statement__ = 56;
            assign(recruit,
              cons_list(index_uni(1),
                cons_list(index_uni(inline_sym13__), nil_index_list())), 1,
              "assigning variable recruit");
          } 
          for (size_t i = 2; i <= M; ++i) {
            int f;
            
            int inline_sym13__;
            int inline_sym15__;
            
            inline_sym15__ = 0;
            for (size_t inline_sym16__ = 1; inline_sym16__ <= 1;
                 ++inline_sym16__) {
              lcm_sym179__ = size(z[(i - 1)]);
              for (size_t inline_sym14__ = 1; inline_sym14__ <= lcm_sym179__;
                   ++inline_sym14__) {
                current_statement__ = 54;
                if (z[(i - 1)][(inline_sym14__ - 1)]) {
                  inline_sym15__ = 1;
                  inline_sym13__ = inline_sym14__;
                  break;
                } }
              if (inline_sym15__) {
                break;
              } 
              inline_sym15__ = 1;
              inline_sym13__ = 0;
              break;}
            current_statement__ = 57;
            if (logical_gt(inline_sym13__, 0)) {
              current_statement__ = 56;
              assign(recruit,
                cons_list(index_uni(i),
                  cons_list(index_uni(inline_sym13__), nil_index_list())), 1,
                "assigning variable recruit");
            } }
        } 
        current_statement__ = 63;
        if (lcm_sym144__) {
          current_statement__ = 60;
          assign(N, cons_list(index_uni(1), nil_index_list()),
            sum(
              rvalue(z,
                cons_list(index_omni(),
                  cons_list(index_uni(1), nil_index_list())), "z")),
            "assigning variable N");
          current_statement__ = 61;
          assign(B, cons_list(index_uni(1), nil_index_list()),
            sum(
              rvalue(recruit,
                cons_list(index_omni(),
                  cons_list(index_uni(1), nil_index_list())), "recruit")),
            "assigning variable B");
          for (size_t t = 2; t <= n_occasions; ++t) {
            current_statement__ = 60;
            assign(N, cons_list(index_uni(t), nil_index_list()),
              sum(
                rvalue(z,
                  cons_list(index_omni(),
                    cons_list(index_uni(t), nil_index_list())), "z")),
              "assigning variable N");
            current_statement__ = 61;
            assign(B, cons_list(index_uni(t), nil_index_list()),
              sum(
                rvalue(recruit,
                  cons_list(index_omni(),
                    cons_list(index_uni(t), nil_index_list())), "recruit")),
              "assigning variable B");}
        } 
        current_statement__ = 67;
        if (lcm_sym143__) {
          current_statement__ = 64;
          assign(Nind, cons_list(index_uni(1), nil_index_list()),
            sum(z[(1 - 1)]), "assigning variable Nind");
          current_statement__ = 65;
          assign(Nalive, cons_list(index_uni(1), nil_index_list()),
            logical_gt(Nind[(1 - 1)], 0), "assigning variable Nalive");
          for (size_t i = 2; i <= M; ++i) {
            current_statement__ = 64;
            assign(Nind, cons_list(index_uni(i), nil_index_list()),
              sum(z[(i - 1)]), "assigning variable Nind");
            current_statement__ = 65;
            assign(Nalive, cons_list(index_uni(i), nil_index_list()),
              logical_gt(Nind[(i - 1)], 0), "assigning variable Nalive");}
        } 
        current_statement__ = 68;
        Nsuper = sum(Nalive);
      }
      current_statement__ = 32;
      current_statement__ = 32;
      check_greater_or_equal(function__, "sigma2", lcm_sym181__, 0);
      current_statement__ = 33;
      current_statement__ = 33;
      check_greater_or_equal(function__, "Nsuper", Nsuper, 0);
      current_statement__ = 34;
      if (lcm_sym144__) {
        current_statement__ = 34;
        current_statement__ = 34;
        check_greater_or_equal(function__, "N[sym1__]", N[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_greater_or_equal(function__, "N[sym1__]", N[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 35;
      if (lcm_sym144__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_greater_or_equal(function__, "B[sym1__]", B[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 35;
          current_statement__ = 35;
          check_greater_or_equal(function__, "B[sym1__]", B[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 36;
      if (lcm_sym143__) {
        current_statement__ = 36;
        if (lcm_sym144__) {
          current_statement__ = 36;
          current_statement__ = 36;
          check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                 z[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 36;
            current_statement__ = 36;
            check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                   z[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 36;
          if (lcm_sym144__) {
            current_statement__ = 36;
            current_statement__ = 36;
            check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                   z[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 36;
              current_statement__ = 36;
              check_greater_or_equal(function__, "z[sym1__, sym2__]",
                                     z[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 36;
      if (lcm_sym143__) {
        current_statement__ = 36;
        if (lcm_sym144__) {
          current_statement__ = 36;
          current_statement__ = 36;
          check_less_or_equal(function__, "z[sym1__, sym2__]",
                              z[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 36;
            current_statement__ = 36;
            check_less_or_equal(function__, "z[sym1__, sym2__]",
                                z[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 36;
          if (lcm_sym144__) {
            current_statement__ = 36;
            current_statement__ = 36;
            check_less_or_equal(function__, "z[sym1__, sym2__]",
                                z[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 36;
              current_statement__ = 36;
              check_less_or_equal(function__, "z[sym1__, sym2__]",
                                  z[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      vars__.push_back(lcm_sym181__);
      vars__.push_back(Nsuper);
      if (lcm_sym144__) {
        vars__.push_back(N[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(N[(sym1__ - 1)]);}
      } 
      if (lcm_sym144__) {
        vars__.push_back(B[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(B[(sym1__ - 1)]);}
      } 
      if (lcm_sym144__) {
        if (lcm_sym143__) {
          vars__.push_back(z[(1 - 1)][(1 - 1)]);
          for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
            vars__.push_back(z[(sym2__ - 1)][(1 - 1)]);}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym143__) {
            vars__.push_back(z[(1 - 1)][(sym1__ - 1)]);
            for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
              vars__.push_back(z[(sym2__ - 1)][(sym1__ - 1)]);}
          } }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym139__;
      double lcm_sym138__;
      double lcm_sym137__;
      double lcm_sym136__;
      double lcm_sym135__;
      double lcm_sym134__;
      double lcm_sym133__;
      double lcm_sym132__;
      int lcm_sym129__;
      int lcm_sym128__;
      int lcm_sym127__;
      int pos__;
      
      pos__ = 1;
      double mean_phi;
      
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      current_statement__ = 1;
      mean_phi = stan::math::lub_free(mean_phi, 0, 1);
      double mean_p;
      
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      current_statement__ = 2;
      mean_p = stan::math::lub_free(mean_p, 0, 1);
      double psi;
      
      current_statement__ = 3;
      psi = context__.vals_r("psi")[(1 - 1)];
      current_statement__ = 3;
      psi = stan::math::lub_free(psi, 0, 1);
      current_statement__ = 4;
      validate_non_negative_index("beta", "n_occasions", n_occasions);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(n_occasions);
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 4;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 4;
        pos__ = 1;
        lcm_sym128__ = logical_gte(n_occasions, 1);
        if (lcm_sym128__) {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            beta_flat__[(1 - 1)], "assigning variable beta");
          current_statement__ = 4;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            current_statement__ = 4;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 4;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 4;
      if (lcm_sym128__) {
        current_statement__ = 4;
        assign(beta, cons_list(index_uni(1), nil_index_list()),
          stan::math::lb_free(beta[(1 - 1)], 0), "assigning variable beta");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 4;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_free(beta[(sym1__ - 1)], 0),
            "assigning variable beta");}
      } 
      current_statement__ = 5;
      validate_non_negative_index("epsilon", "M", M);
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(M);
      
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 5;
        assign(epsilon_flat__, nil_index_list(), context__.vals_r("epsilon"),
          "assigning variable epsilon_flat__");
        current_statement__ = 5;
        pos__ = 1;
        lcm_sym127__ = logical_gte(M, 1);
        if (lcm_sym127__) {
          current_statement__ = 5;
          assign(epsilon, cons_list(index_uni(1), nil_index_list()),
            epsilon_flat__[(1 - 1)], "assigning variable epsilon");
          current_statement__ = 5;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
            current_statement__ = 5;
            assign(epsilon, cons_list(index_uni(sym1__), nil_index_list()),
              epsilon_flat__[(pos__ - 1)], "assigning variable epsilon");
            current_statement__ = 5;
            pos__ = (pos__ + 1);}
        } 
      }
      double sigma;
      
      current_statement__ = 6;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      current_statement__ = 6;
      sigma = stan::math::lub_free(sigma, 0, 5);
      vars__.push_back(mean_phi);
      vars__.push_back(mean_p);
      vars__.push_back(psi);
      if (lcm_sym128__) {
        vars__.push_back(beta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(beta[(sym1__ - 1)]);}
      } 
      if (lcm_sym127__) {
        vars__.push_back(epsilon[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          vars__.push_back(epsilon[(sym1__ - 1)]);}
      } 
      vars__.push_back(sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mean_phi");
    names__.push_back("mean_p");
    names__.push_back("psi");
    names__.push_back("beta");
    names__.push_back("epsilon");
    names__.push_back("sigma");
    names__.push_back("phi");
    names__.push_back("p");
    names__.push_back("b");
    names__.push_back("nu");
    names__.push_back("chi");
    names__.push_back("sigma2");
    names__.push_back("Nsuper");
    names__.push_back("N");
    names__.push_back("B");
    names__.push_back("z");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    
    dims__.push_back((n_occasions - 1));
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_phi");
    param_names__.push_back(std::string() + "mean_p");
    param_names__.push_back(std::string() + "psi");
    for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym333__));
      }}
    for (size_t sym333__ = 1; sym333__ <= M; ++sym333__) {
      {
        param_names__.push_back(std::string() + "epsilon" + '.' + std::to_string(sym333__));
      }}
    param_names__.push_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (size_t sym333__ = 1; sym333__ <= (n_occasions - 1); ++sym333__) {
        {
          for (size_t sym334__ = 1; sym334__ <= M; ++sym334__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym334__) + '.' + std::to_string(sym333__));
            }}
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          for (size_t sym334__ = 1; sym334__ <= M; ++sym334__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym334__) + '.' + std::to_string(sym333__));
            }}
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          param_names__.push_back(std::string() + "b" + '.' + std::to_string(sym333__));
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          param_names__.push_back(std::string() + "nu" + '.' + std::to_string(sym333__));
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          for (size_t sym334__ = 1; sym334__ <= M; ++sym334__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym334__) + '.' + std::to_string(sym333__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "sigma2");
      param_names__.push_back(std::string() + "Nsuper");
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          param_names__.push_back(std::string() + "N" + '.' + std::to_string(sym333__));
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          param_names__.push_back(std::string() + "B" + '.' + std::to_string(sym333__));
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          for (size_t sym334__ = 1; sym334__ <= M; ++sym334__) {
            {
              param_names__.push_back(std::string() + "z" + '.' + std::to_string(sym334__) + '.' + std::to_string(sym333__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_phi");
    param_names__.push_back(std::string() + "mean_p");
    param_names__.push_back(std::string() + "psi");
    for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym333__));
      }}
    for (size_t sym333__ = 1; sym333__ <= M; ++sym333__) {
      {
        param_names__.push_back(std::string() + "epsilon" + '.' + std::to_string(sym333__));
      }}
    param_names__.push_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (size_t sym333__ = 1; sym333__ <= (n_occasions - 1); ++sym333__) {
        {
          for (size_t sym334__ = 1; sym334__ <= M; ++sym334__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym334__) + '.' + std::to_string(sym333__));
            }}
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          for (size_t sym334__ = 1; sym334__ <= M; ++sym334__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym334__) + '.' + std::to_string(sym333__));
            }}
        }}
      for (size_t sym333__ = 1; sym333__ <= (n_occasions - 1); ++sym333__) {
        {
          param_names__.push_back(std::string() + "b" + '.' + std::to_string(sym333__));
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          param_names__.push_back(std::string() + "nu" + '.' + std::to_string(sym333__));
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          for (size_t sym334__ = 1; sym334__ <= M; ++sym334__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym334__) + '.' + std::to_string(sym333__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "sigma2");
      param_names__.push_back(std::string() + "Nsuper");
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          param_names__.push_back(std::string() + "N" + '.' + std::to_string(sym333__));
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          param_names__.push_back(std::string() + "B" + '.' + std::to_string(sym333__));
        }}
      for (size_t sym333__ = 1; sym333__ <= n_occasions; ++sym333__) {
        {
          for (size_t sym334__ = 1; sym334__ <= M; ++sym334__) {
            {
              param_names__.push_back(std::string() + "z" + '.' + std::to_string(sym334__) + '.' + std::to_string(sym333__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << M << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << (n_occasions - 1) << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << M << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << (n_occasions - 1) << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << (n_occasions - 1) << "},\"block\":\"transformed_parameters\"},{\"name\":\"nu\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef expr_prop_fail6_model_namespace::expr_prop_fail6_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-fail7.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail7_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail7.stan', line 20, column 2 to column 16)",
                                                      " (in 'expr-prop-fail7.stan', line 21, column 2 to column 24)",
                                                      " (in 'expr-prop-fail7.stan', line 40, column 2 to column 24)",
                                                      " (in 'expr-prop-fail7.stan', line 42, column 4 to column 30)",
                                                      " (in 'expr-prop-fail7.stan', line 44, column 6 to column 51)",
                                                      " (in 'expr-prop-fail7.stan', line 43, column 4 to line 44, column 51)",
                                                      " (in 'expr-prop-fail7.stan', line 45, column 4 to column 45)",
                                                      " (in 'expr-prop-fail7.stan', line 41, column 17 to line 46, column 3)",
                                                      " (in 'expr-prop-fail7.stan', line 41, column 2 to line 46, column 3)",
                                                      " (in 'expr-prop-fail7.stan', line 25, column 2 to column 24)",
                                                      " (in 'expr-prop-fail7.stan', line 28, column 6 to column 39)",
                                                      " (in 'expr-prop-fail7.stan', line 27, column 4 to line 28, column 39)",
                                                      " (in 'expr-prop-fail7.stan', line 26, column 2 to line 28, column 39)",
                                                      " (in 'expr-prop-fail7.stan', line 32, column 4 to column 30)",
                                                      " (in 'expr-prop-fail7.stan', line 34, column 6 to column 51)",
                                                      " (in 'expr-prop-fail7.stan', line 33, column 4 to line 34, column 51)",
                                                      " (in 'expr-prop-fail7.stan', line 35, column 4 to column 33)",
                                                      " (in 'expr-prop-fail7.stan', line 31, column 17 to line 36, column 3)",
                                                      " (in 'expr-prop-fail7.stan', line 31, column 2 to line 36, column 3)",
                                                      " (in 'expr-prop-fail7.stan', line 12, column 2 to column 17)",
                                                      " (in 'expr-prop-fail7.stan', line 13, column 2 to column 17)",
                                                      " (in 'expr-prop-fail7.stan', line 14, column 2 to column 17)",
                                                      " (in 'expr-prop-fail7.stan', line 15, column 2 to column 30)",
                                                      " (in 'expr-prop-fail7.stan', line 16, column 2 to column 27)",
                                                      " (in 'expr-prop-fail7.stan', line 17, column 2 to column 29)"};



class expr_prop_fail7_model : public model_base_crtp<expr_prop_fail7_model> {

 private:
  int lcm_sym93__;
  int lcm_sym92__;
  int lcm_sym91__;
  int lcm_sym90__;
  int lcm_sym89__;
  int lcm_sym88__;
  double lcm_sym87__;
  double lcm_sym86__;
  Eigen::Matrix<double, -1, 1> lcm_sym85__;
  Eigen::Matrix<double, -1, 1> lcm_sym84__;
  double lcm_sym83__;
  double lcm_sym82__;
  int lcm_sym81__;
  int lcm_sym80__;
  int lcm_sym79__;
  int lcm_sym78__;
  int pos__;
  int K;
  int I;
  int J;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double, -1, 1> alpha;
  std::vector<Eigen::Matrix<double, -1, 1>> beta;
 
 public:
  ~expr_prop_fail7_model() { }
  
  std::string model_name() const { return "expr_prop_fail7_model"; }
  
  expr_prop_fail7_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail7_model_namespace::expr_prop_fail7_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","K","int",
          context__.to_vec());
      
      current_statement__ = 20;
      K = context__.vals_i("K")[(1 - 1)];
      context__.validate_dims("data initialization","I","int",
          context__.to_vec());
      
      current_statement__ = 21;
      I = context__.vals_i("I")[(1 - 1)];
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      
      current_statement__ = 22;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 23;
      validate_non_negative_index("y", "I", I);
      current_statement__ = 23;
      validate_non_negative_index("y", "J", J);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(I, J));
      y = std::vector<std::vector<int>>(I, std::vector<int>(J, 0));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 23;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 23;
        pos__ = 1;
        lcm_sym79__ = logical_gte(J, 1);
        if (lcm_sym79__) {
          {
            lcm_sym78__ = logical_gte(I, 1);
            if (lcm_sym78__) {
              current_statement__ = 23;
              assign(y,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())),
                y_flat__[(1 - 1)], "assigning variable y");
              current_statement__ = 23;
              pos__ = 2;
              for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 23;
                assign(y,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(1), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 23;
                pos__ = (pos__ + 1);}
            } 
            for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
              current_statement__ = 23;
              if (lcm_sym78__) {
                current_statement__ = 23;
                assign(y,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 23;
                pos__ = (pos__ + 1);
                for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                  current_statement__ = 23;
                  assign(y,
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list())),
                    y_flat__[(pos__ - 1)], "assigning variable y");
                  current_statement__ = 23;
                  pos__ = (pos__ + 1);}
              } }
          }
        } else {
          lcm_sym78__ = logical_gte(I, 1);
        }
      }
      current_statement__ = 24;
      validate_non_negative_index("alpha", "K", K);
      context__.validate_dims("data initialization","alpha","double",
          context__.to_vec(K));
      alpha = Eigen::Matrix<double, -1, 1>(K);
      
      {
        std::vector<double> alpha_flat__;
        current_statement__ = 24;
        assign(alpha_flat__, nil_index_list(), context__.vals_r("alpha"),
          "assigning variable alpha_flat__");
        current_statement__ = 24;
        pos__ = 1;
        lcm_sym80__ = logical_gte(K, 1);
        if (lcm_sym80__) {
          current_statement__ = 24;
          assign(alpha, cons_list(index_uni(1), nil_index_list()),
            alpha_flat__[(1 - 1)], "assigning variable alpha");
          current_statement__ = 24;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= K; ++sym1__) {
            current_statement__ = 24;
            assign(alpha, cons_list(index_uni(sym1__), nil_index_list()),
              alpha_flat__[(pos__ - 1)], "assigning variable alpha");
            current_statement__ = 24;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 25;
      validate_non_negative_index("beta", "K", K);
      current_statement__ = 25;
      validate_non_negative_index("beta", "K", K);
      context__.validate_dims("data initialization","beta","double",
          context__.to_vec(K, K));
      beta = std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(K));
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 25;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 25;
        pos__ = 1;
        current_statement__ = 25;
        if (lcm_sym80__) {
          current_statement__ = 25;
          if (lcm_sym80__) {
            current_statement__ = 25;
            assign(beta,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              beta_flat__[(1 - 1)], "assigning variable beta");
            current_statement__ = 25;
            pos__ = 2;
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 25;
              assign(beta,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                beta_flat__[(pos__ - 1)], "assigning variable beta");
              current_statement__ = 25;
              pos__ = (pos__ + 1);}
          } 
          for (size_t sym1__ = 2; sym1__ <= K; ++sym1__) {
            current_statement__ = 25;
            if (lcm_sym80__) {
              current_statement__ = 25;
              assign(beta,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                beta_flat__[(pos__ - 1)], "assigning variable beta");
              current_statement__ = 25;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
                current_statement__ = 25;
                assign(beta,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  beta_flat__[(pos__ - 1)], "assigning variable beta");
                current_statement__ = 25;
                pos__ = (pos__ + 1);}
            } }
        } 
      }
      current_statement__ = 20;
      current_statement__ = 20;
      check_greater_or_equal(function__, "K", K, 2);
      current_statement__ = 21;
      current_statement__ = 21;
      check_greater_or_equal(function__, "I", I, 1);
      current_statement__ = 22;
      current_statement__ = 22;
      check_greater_or_equal(function__, "J", J, 1);
      current_statement__ = 23;
      if (lcm_sym78__) {
        current_statement__ = 23;
        if (lcm_sym79__) {
          current_statement__ = 23;
          current_statement__ = 23;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= J; ++sym2__) {
            current_statement__ = 23;
            current_statement__ = 23;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 23;
          if (lcm_sym79__) {
            current_statement__ = 23;
            current_statement__ = 23;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= J; ++sym2__) {
              current_statement__ = 23;
              current_statement__ = 23;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      current_statement__ = 23;
      if (lcm_sym78__) {
        current_statement__ = 23;
        if (lcm_sym79__) {
          current_statement__ = 23;
          current_statement__ = 23;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(1 - 1)][(1 - 1)], K);
          for (size_t sym2__ = 2; sym2__ <= J; ++sym2__) {
            current_statement__ = 23;
            current_statement__ = 23;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(1 - 1)][(sym2__ - 1)], K);}
        } 
        for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 23;
          if (lcm_sym79__) {
            current_statement__ = 23;
            current_statement__ = 23;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(sym1__ - 1)][(1 - 1)], K);
            for (size_t sym2__ = 2; sym2__ <= J; ++sym2__) {
              current_statement__ = 23;
              current_statement__ = 23;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], K);}
          } }
      } 
      current_statement__ = 24;
      current_statement__ = 24;
      check_greater_or_equal(function__, "alpha", alpha, 0);
      current_statement__ = 25;
      if (lcm_sym80__) {
        current_statement__ = 25;
        current_statement__ = 25;
        check_greater_or_equal(function__, "beta[sym1__]", beta[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= K; ++sym1__) {
          current_statement__ = 25;
          current_statement__ = 25;
          check_greater_or_equal(function__, "beta[sym1__]",
                                 beta[(sym1__ - 1)], 0);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_positive_index("pi", "K", K);
      num_params_r__ += (K - 1);
      current_statement__ = 2;
      validate_non_negative_index("theta", "J", J);
      current_statement__ = 2;
      validate_non_negative_index("theta", "K", K);
      current_statement__ = 2;
      validate_positive_index("theta", "K", K);
      num_params_r__ += J * K * (K - 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail7_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      Eigen::Matrix<double, -1, 1> lcm_sym76__;
      Eigen::Matrix<double, -1, 1> lcm_sym74__;
      Eigen::Matrix<double, -1, 1> lcm_sym72__;
      Eigen::Matrix<double, -1, 1> lcm_sym70__;
      double lcm_sym68__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym67__;
      double lcm_sym66__;
      double lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      double lcm_sym62__;
      Eigen::Matrix<double, -1, 1> lcm_sym61__;
      Eigen::Matrix<double, -1, 1> lcm_sym60__;
      Eigen::Matrix<double, -1, 1> lcm_sym59__;
      Eigen::Matrix<double, -1, 1> lcm_sym58__;
      int lcm_sym77__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      current_statement__ = 1;
      validate_positive_index("pi", "K", K);
      Eigen::Matrix<local_scalar_t__, -1, 1> pi;
      pi = Eigen::Matrix<local_scalar_t__, -1, 1>(K);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> pi_in__;
      pi_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>((K - 1));
      
      lcm_sym77__ = (K - 1);
      pi_in__ = in__.vector(lcm_sym77__);
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        assign(pi, nil_index_list(),
          stan::math::simplex_constrain(pi_in__, lp__),
          "assigning variable pi");
      } else {
        current_statement__ = 1;
        assign(pi, nil_index_list(), stan::math::simplex_constrain(pi_in__),
          "assigning variable pi");
      }
      current_statement__ = 2;
      validate_non_negative_index("theta", "J", J);
      current_statement__ = 2;
      validate_non_negative_index("theta", "K", K);
      current_statement__ = 2;
      validate_positive_index("theta", "K", K);
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> theta;
      theta = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(J, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(K)));
      
      std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>> theta_in__;
      theta_in__ = std::vector<std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>>(J, std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(K, Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym77__)));
      
      lcm_sym56__ = logical_gte(J, 1);
      if (lcm_sym56__) {
        lcm_sym57__ = logical_gte(K, 1);
        if (lcm_sym57__) {
          current_statement__ = 2;
          assign(theta_in__,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())),
            in__.vector(lcm_sym77__), "assigning variable theta_in__");
          for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
            current_statement__ = 2;
            assign(theta_in__,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              in__.vector(lcm_sym77__), "assigning variable theta_in__");}
        } 
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 2;
          if (lcm_sym57__) {
            current_statement__ = 2;
            assign(theta_in__,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())),
              in__.vector(lcm_sym77__), "assigning variable theta_in__");
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 2;
              assign(theta_in__,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                in__.vector(lcm_sym77__), "assigning variable theta_in__");}
          } }
      } 
      current_statement__ = 2;
      if (lcm_sym56__) {
        lcm_sym57__ = logical_gte(K, 1);
        if (lcm_sym57__) {
          current_statement__ = 2;
          if (jacobian__) {
            current_statement__ = 2;
            assign(theta,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              stan::math::simplex_constrain(theta_in__[(1 - 1)][(1 - 1)],
                lp__), "assigning variable theta");
          } else {
            current_statement__ = 2;
            assign(theta,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              stan::math::simplex_constrain(theta_in__[(1 - 1)][(1 - 1)]),
              "assigning variable theta");
          }
          for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
            current_statement__ = 2;
            if (jacobian__) {
              current_statement__ = 2;
              assign(theta,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                stan::math::simplex_constrain(
                  theta_in__[(1 - 1)][(sym2__ - 1)], lp__),
                "assigning variable theta");
            } else {
              current_statement__ = 2;
              assign(theta,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                stan::math::simplex_constrain(
                  theta_in__[(1 - 1)][(sym2__ - 1)]),
                "assigning variable theta");
            }}
        } 
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 2;
          if (lcm_sym57__) {
            current_statement__ = 2;
            if (jacobian__) {
              current_statement__ = 2;
              assign(theta,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())),
                stan::math::simplex_constrain(
                  theta_in__[(sym1__ - 1)][(1 - 1)], lp__),
                "assigning variable theta");
            } else {
              current_statement__ = 2;
              assign(theta,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())),
                stan::math::simplex_constrain(
                  theta_in__[(sym1__ - 1)][(1 - 1)]),
                "assigning variable theta");
            }
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 2;
              if (jacobian__) {
                current_statement__ = 2;
                assign(theta,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  stan::math::simplex_constrain(
                    theta_in__[(sym1__ - 1)][(sym2__ - 1)], lp__),
                  "assigning variable theta");
              } else {
                current_statement__ = 2;
                assign(theta,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  stan::math::simplex_constrain(
                    theta_in__[(sym1__ - 1)][(sym2__ - 1)]),
                  "assigning variable theta");
              }}
          } }
      } 
      {
        current_statement__ = 10;
        lp_accum__.add(dirichlet_log<propto__>(pi, alpha));
        current_statement__ = 13;
        if (lcm_sym56__) {
          lcm_sym57__ = logical_gte(K, 1);
          if (lcm_sym57__) {
            current_statement__ = 11;
            lp_accum__.add(
              dirichlet_log<propto__>(theta[(1 - 1)][(1 - 1)], beta[(1 - 1)]));
            for (size_t k = 2; k <= K; ++k) {
              current_statement__ = 11;
              lp_accum__.add(
                dirichlet_log<propto__>(theta[(1 - 1)][(k - 1)],
                  beta[(k - 1)]));}
          } 
          for (size_t j = 2; j <= J; ++j) {
            current_statement__ = 12;
            if (lcm_sym57__) {
              current_statement__ = 11;
              lp_accum__.add(
                dirichlet_log<propto__>(theta[(j - 1)][(1 - 1)],
                  beta[(1 - 1)]));
              for (size_t k = 2; k <= K; ++k) {
                current_statement__ = 11;
                lp_accum__.add(
                  dirichlet_log<propto__>(theta[(j - 1)][(k - 1)],
                    beta[(k - 1)]));}
            } }
        } 
        current_statement__ = 19;
        if (logical_gte(I, 1)) {
          current_statement__ = 14;
          validate_non_negative_index("log_q", "K", K);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_q;
          log_q = Eigen::Matrix<local_scalar_t__, -1, 1>(K);
          
          assign(lcm_sym67__, nil_index_list(), stan::math::log(pi),
            "assigning variable lcm_sym67__");
          assign(log_q, nil_index_list(), lcm_sym67__,
            "assigning variable log_q");
          current_statement__ = 16;
          if (lcm_sym56__) {
            current_statement__ = 15;
            assign(log_q, nil_index_list(),
              add(lcm_sym67__,
                to_vector(
                  stan::math::log(
                    rvalue(theta,
                      cons_list(index_uni(1),
                        cons_list(index_omni(),
                          cons_list(index_uni(y[(1 - 1)][(1 - 1)]),
                            nil_index_list()))), "theta")))),
              "assigning variable log_q");
            for (size_t j = 2; j <= J; ++j) {
              current_statement__ = 15;
              assign(log_q, nil_index_list(),
                add(stan::model::deep_copy(log_q),
                  to_vector(
                    stan::math::log(
                      rvalue(theta,
                        cons_list(index_uni(j),
                          cons_list(index_omni(),
                            cons_list(index_uni(y[(1 - 1)][(j - 1)]),
                              nil_index_list()))), "theta")))),
                "assigning variable log_q");}
          } 
          current_statement__ = 17;
          lp_accum__.add(log_sum_exp(log_q));
          for (size_t i = 2; i <= I; ++i) {
            current_statement__ = 14;
            validate_non_negative_index("log_q", "K", K);
            Eigen::Matrix<local_scalar_t__, -1, 1> log_q;
            log_q = Eigen::Matrix<local_scalar_t__, -1, 1>(K);
            
            current_statement__ = 14;
            assign(log_q, nil_index_list(), lcm_sym67__,
              "assigning variable log_q");
            current_statement__ = 16;
            if (lcm_sym56__) {
              current_statement__ = 15;
              assign(log_q, nil_index_list(),
                add(lcm_sym67__,
                  to_vector(
                    stan::math::log(
                      rvalue(theta,
                        cons_list(index_uni(1),
                          cons_list(index_omni(),
                            cons_list(index_uni(y[(i - 1)][(1 - 1)]),
                              nil_index_list()))), "theta")))),
                "assigning variable log_q");
              for (size_t j = 2; j <= J; ++j) {
                current_statement__ = 15;
                assign(log_q, nil_index_list(),
                  add(stan::model::deep_copy(log_q),
                    to_vector(
                      stan::math::log(
                        rvalue(theta,
                          cons_list(index_uni(j),
                            cons_list(index_omni(),
                              cons_list(index_uni(y[(i - 1)][(j - 1)]),
                                nil_index_list()))), "theta")))),
                  "assigning variable log_q");}
            } 
            current_statement__ = 17;
            lp_accum__.add(log_sum_exp(log_q));}
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail7_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      Eigen::Matrix<double, -1, 1> lcm_sym38__;
      Eigen::Matrix<double, -1, 1> lcm_sym37__;
      Eigen::Matrix<double, -1, 1> lcm_sym36__;
      Eigen::Matrix<double, -1, 1> lcm_sym35__;
      double lcm_sym54__;
      double lcm_sym53__;
      double lcm_sym52__;
      double lcm_sym51__;
      double lcm_sym50__;
      double lcm_sym49__;
      double lcm_sym48__;
      double lcm_sym47__;
      double lcm_sym46__;
      double lcm_sym45__;
      double lcm_sym44__;
      double lcm_sym43__;
      double lcm_sym42__;
      double lcm_sym41__;
      double lcm_sym39__;
      Eigen::Matrix<double, -1, 1> lcm_sym34__;
      Eigen::Matrix<double, -1, 1> lcm_sym33__;
      Eigen::Matrix<double, -1, 1> lcm_sym32__;
      Eigen::Matrix<double, -1, 1> lcm_sym31__;
      Eigen::Matrix<double, -1, 1> lcm_sym30__;
      int lcm_sym29__;
      int lcm_sym28__;
      Eigen::Matrix<double, -1, 1> lcm_sym27__;
      int lcm_sym40__;
      int lcm_sym26__;
      int lcm_sym25__;
      int lcm_sym24__;
      current_statement__ = 1;
      validate_positive_index("pi", "K", K);
      Eigen::Matrix<double, -1, 1> pi;
      pi = Eigen::Matrix<double, -1, 1>(K);
      
      Eigen::Matrix<double, -1, 1> pi_in__;
      pi_in__ = Eigen::Matrix<double, -1, 1>((K - 1));
      
      lcm_sym40__ = (K - 1);
      pi_in__ = in__.vector(lcm_sym40__);
      current_statement__ = 1;
      assign(pi, nil_index_list(), stan::math::simplex_constrain(pi_in__),
        "assigning variable pi");
      current_statement__ = 2;
      validate_non_negative_index("theta", "J", J);
      current_statement__ = 2;
      validate_non_negative_index("theta", "K", K);
      current_statement__ = 2;
      validate_positive_index("theta", "K", K);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta;
      theta = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(J, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(K)));
      
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta_in__;
      theta_in__ = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(J, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(lcm_sym40__)));
      
      lcm_sym25__ = logical_gte(J, 1);
      if (lcm_sym25__) {
        {
          lcm_sym26__ = logical_gte(K, 1);
          if (lcm_sym26__) {
            current_statement__ = 2;
            assign(theta_in__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              in__.vector(lcm_sym40__), "assigning variable theta_in__");
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 2;
              assign(theta_in__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                in__.vector(lcm_sym40__), "assigning variable theta_in__");}
          } 
          for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
            current_statement__ = 2;
            if (lcm_sym26__) {
              current_statement__ = 2;
              assign(theta_in__,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())),
                in__.vector(lcm_sym40__), "assigning variable theta_in__");
              for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
                current_statement__ = 2;
                assign(theta_in__,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  in__.vector(lcm_sym40__), "assigning variable theta_in__");
              }
            } }
        }
      } else {
        lcm_sym26__ = logical_gte(K, 1);
      }
      current_statement__ = 2;
      if (lcm_sym25__) {
        current_statement__ = 2;
        if (lcm_sym26__) {
          current_statement__ = 2;
          assign(theta,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())),
            stan::math::simplex_constrain(theta_in__[(1 - 1)][(1 - 1)]),
            "assigning variable theta");
          for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
            current_statement__ = 2;
            assign(theta,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::simplex_constrain(theta_in__[(1 - 1)][(sym2__ - 1)]),
              "assigning variable theta");}
        } 
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 2;
          if (lcm_sym26__) {
            current_statement__ = 2;
            assign(theta,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())),
              stan::math::simplex_constrain(theta_in__[(sym1__ - 1)][(1 - 1)]),
              "assigning variable theta");
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 2;
              assign(theta,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                stan::math::simplex_constrain(
                  theta_in__[(sym1__ - 1)][(sym2__ - 1)]),
                "assigning variable theta");}
          } }
      } 
      if (lcm_sym26__) {
        vars__.push_back(pi[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= K; ++sym1__) {
          vars__.push_back(pi[(sym1__ - 1)]);}
      } 
      if (lcm_sym26__) {
        if (lcm_sym26__) {
          if (lcm_sym25__) {
            vars__.push_back(theta[(1 - 1)][(1 - 1)][(1 - 1)]);
            for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
              vars__.push_back(theta[(sym3__ - 1)][(1 - 1)][(1 - 1)]);}
          } 
          for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
            if (lcm_sym25__) {
              vars__.push_back(theta[(1 - 1)][(sym2__ - 1)][(1 - 1)]);
              for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                vars__.push_back(theta[(sym3__ - 1)][(sym2__ - 1)][(1 - 1)]);
              }
            } }
        } 
        for (size_t sym1__ = 2; sym1__ <= K; ++sym1__) {
          if (lcm_sym26__) {
            if (lcm_sym25__) {
              vars__.push_back(theta[(1 - 1)][(1 - 1)][(sym1__ - 1)]);
              for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                vars__.push_back(theta[(sym3__ - 1)][(1 - 1)][(sym1__ - 1)]);
              }
            } 
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              if (lcm_sym25__) {
                vars__.push_back(theta[(1 - 1)][(sym2__ - 1)][(sym1__ - 1)]);
                for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                  vars__.push_back(
                    theta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}
              } }
          } }
      } 
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      current_statement__ = 3;
      validate_non_negative_index("log_Pr_z", "I", I);
      current_statement__ = 3;
      validate_non_negative_index("log_Pr_z", "K", K);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> log_Pr_z;
      log_Pr_z = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(I, Eigen::Matrix<local_scalar_t__, -1, 1>(K));
      
      lcm_sym24__ = logical_gte(I, 1);
      if (lcm_sym24__) {
        current_statement__ = 3;
        if (lcm_sym26__) {
          lcm_sym39__ = std::numeric_limits<double>::quiet_NaN();
          assign(log_Pr_z,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym39__,
            "assigning variable log_Pr_z");
          for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
            current_statement__ = 3;
            assign(log_Pr_z,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym39__,
              "assigning variable log_Pr_z");}
        } 
        for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym26__) {
            lcm_sym39__ = std::numeric_limits<double>::quiet_NaN();
            assign(log_Pr_z,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym39__,
              "assigning variable log_Pr_z");
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 3;
              assign(log_Pr_z,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym39__, "assigning variable log_Pr_z");}
          } }
      } 
      current_statement__ = 9;
      if (lcm_sym24__) {
        current_statement__ = 4;
        validate_non_negative_index("log_q", "K", K);
        Eigen::Matrix<local_scalar_t__, -1, 1> log_q;
        log_q = Eigen::Matrix<local_scalar_t__, -1, 1>(K);
        
        assign(lcm_sym34__, nil_index_list(), stan::math::log(pi),
          "assigning variable lcm_sym34__");
        assign(log_q, nil_index_list(), lcm_sym34__,
          "assigning variable log_q");
        current_statement__ = 6;
        if (lcm_sym25__) {
          current_statement__ = 5;
          assign(log_q, nil_index_list(),
            add(lcm_sym34__,
              to_vector(
                stan::math::log(
                  rvalue(theta,
                    cons_list(index_uni(1),
                      cons_list(index_omni(),
                        cons_list(index_uni(y[(1 - 1)][(1 - 1)]),
                          nil_index_list()))), "theta")))),
            "assigning variable log_q");
          for (size_t j = 2; j <= J; ++j) {
            current_statement__ = 5;
            assign(log_q, nil_index_list(),
              add(stan::model::deep_copy(log_q),
                to_vector(
                  stan::math::log(
                    rvalue(theta,
                      cons_list(index_uni(j),
                        cons_list(index_omni(),
                          cons_list(index_uni(y[(1 - 1)][(j - 1)]),
                            nil_index_list()))), "theta")))),
              "assigning variable log_q");}
        } 
        current_statement__ = 7;
        assign(log_Pr_z, cons_list(index_uni(1), nil_index_list()),
          subtract(log_q, log_sum_exp(log_q)), "assigning variable log_Pr_z");
        for (size_t i = 2; i <= I; ++i) {
          current_statement__ = 4;
          validate_non_negative_index("log_q", "K", K);
          Eigen::Matrix<local_scalar_t__, -1, 1> log_q;
          log_q = Eigen::Matrix<local_scalar_t__, -1, 1>(K);
          
          current_statement__ = 4;
          assign(log_q, nil_index_list(), lcm_sym34__,
            "assigning variable log_q");
          current_statement__ = 6;
          if (lcm_sym25__) {
            current_statement__ = 5;
            assign(log_q, nil_index_list(),
              add(lcm_sym34__,
                to_vector(
                  stan::math::log(
                    rvalue(theta,
                      cons_list(index_uni(1),
                        cons_list(index_omni(),
                          cons_list(index_uni(y[(i - 1)][(1 - 1)]),
                            nil_index_list()))), "theta")))),
              "assigning variable log_q");
            for (size_t j = 2; j <= J; ++j) {
              current_statement__ = 5;
              assign(log_q, nil_index_list(),
                add(stan::model::deep_copy(log_q),
                  to_vector(
                    stan::math::log(
                      rvalue(theta,
                        cons_list(index_uni(j),
                          cons_list(index_omni(),
                            cons_list(index_uni(y[(i - 1)][(j - 1)]),
                              nil_index_list()))), "theta")))),
                "assigning variable log_q");}
          } 
          current_statement__ = 7;
          assign(log_Pr_z, cons_list(index_uni(i), nil_index_list()),
            subtract(log_q, log_sum_exp(log_q)),
            "assigning variable log_Pr_z");}
      } 
      if (lcm_sym26__) {
        if (lcm_sym24__) {
          vars__.push_back(log_Pr_z[(1 - 1)][(1 - 1)]);
          for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
            vars__.push_back(log_Pr_z[(sym2__ - 1)][(1 - 1)]);}
        } 
        for (size_t sym1__ = 2; sym1__ <= K; ++sym1__) {
          if (lcm_sym24__) {
            vars__.push_back(log_Pr_z[(1 - 1)][(sym1__ - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(log_Pr_z[(sym2__ - 1)][(sym1__ - 1)]);}
          } }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      Eigen::Matrix<double, -1, 1> lcm_sym9__;
      double lcm_sym19__;
      double lcm_sym18__;
      Eigen::Matrix<double, -1, 1> lcm_sym8__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      Eigen::Matrix<double, -1, 1> lcm_sym7__;
      Eigen::Matrix<double, -1, 1> lcm_sym6__;
      double lcm_sym13__;
      double lcm_sym12__;
      double lcm_sym11__;
      double lcm_sym10__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      current_statement__ = 1;
      validate_positive_index("pi", "K", K);
      Eigen::Matrix<double, -1, 1> pi;
      pi = Eigen::Matrix<double, -1, 1>(K);
      
      {
        std::vector<double> pi_flat__;
        current_statement__ = 1;
        assign(pi_flat__, nil_index_list(), context__.vals_r("pi"),
          "assigning variable pi_flat__");
        current_statement__ = 1;
        pos__ = 1;
        lcm_sym2__ = logical_gte(K, 1);
        if (lcm_sym2__) {
          current_statement__ = 1;
          assign(pi, cons_list(index_uni(1), nil_index_list()),
            pi_flat__[(1 - 1)], "assigning variable pi");
          current_statement__ = 1;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= K; ++sym1__) {
            current_statement__ = 1;
            assign(pi, cons_list(index_uni(sym1__), nil_index_list()),
              pi_flat__[(pos__ - 1)], "assigning variable pi");
            current_statement__ = 1;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 1;
      assign(pi, nil_index_list(), stan::math::simplex_free(pi),
        "assigning variable pi");
      current_statement__ = 2;
      validate_non_negative_index("theta", "J", J);
      current_statement__ = 2;
      validate_non_negative_index("theta", "K", K);
      current_statement__ = 2;
      validate_positive_index("theta", "K", K);
      std::vector<std::vector<Eigen::Matrix<double, -1, 1>>> theta;
      theta = std::vector<std::vector<Eigen::Matrix<double, -1, 1>>>(J, std::vector<Eigen::Matrix<double, -1, 1>>(K, Eigen::Matrix<double, -1, 1>(K)));
      
      {
        std::vector<double> theta_flat__;
        current_statement__ = 2;
        assign(theta_flat__, nil_index_list(), context__.vals_r("theta"),
          "assigning variable theta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        current_statement__ = 2;
        if (lcm_sym2__) {
          {
            current_statement__ = 2;
            if (lcm_sym2__) {
              {
                lcm_sym1__ = logical_gte(J, 1);
                if (lcm_sym1__) {
                  current_statement__ = 2;
                  assign(theta,
                    cons_list(index_uni(1),
                      cons_list(index_uni(1),
                        cons_list(index_uni(1), nil_index_list()))),
                    theta_flat__[(1 - 1)], "assigning variable theta");
                  current_statement__ = 2;
                  pos__ = 2;
                  for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                    current_statement__ = 2;
                    assign(theta,
                      cons_list(index_uni(sym3__),
                        cons_list(index_uni(1),
                          cons_list(index_uni(1), nil_index_list()))),
                      theta_flat__[(pos__ - 1)], "assigning variable theta");
                    current_statement__ = 2;
                    pos__ = (pos__ + 1);}
                } 
                for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
                  current_statement__ = 2;
                  if (lcm_sym1__) {
                    current_statement__ = 2;
                    assign(theta,
                      cons_list(index_uni(1),
                        cons_list(index_uni(sym2__),
                          cons_list(index_uni(1), nil_index_list()))),
                      theta_flat__[(pos__ - 1)], "assigning variable theta");
                    current_statement__ = 2;
                    pos__ = (pos__ + 1);
                    for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                      current_statement__ = 2;
                      assign(theta,
                        cons_list(index_uni(sym3__),
                          cons_list(index_uni(sym2__),
                            cons_list(index_uni(1), nil_index_list()))),
                        theta_flat__[(pos__ - 1)], "assigning variable theta");
                      current_statement__ = 2;
                      pos__ = (pos__ + 1);}
                  } }
              }
            } else {
              lcm_sym1__ = logical_gte(J, 1);
            }
            for (size_t sym1__ = 2; sym1__ <= K; ++sym1__) {
              current_statement__ = 2;
              if (lcm_sym2__) {
                current_statement__ = 2;
                if (lcm_sym1__) {
                  current_statement__ = 2;
                  assign(theta,
                    cons_list(index_uni(1),
                      cons_list(index_uni(1),
                        cons_list(index_uni(sym1__), nil_index_list()))),
                    theta_flat__[(pos__ - 1)], "assigning variable theta");
                  current_statement__ = 2;
                  pos__ = (pos__ + 1);
                  for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                    current_statement__ = 2;
                    assign(theta,
                      cons_list(index_uni(sym3__),
                        cons_list(index_uni(1),
                          cons_list(index_uni(sym1__), nil_index_list()))),
                      theta_flat__[(pos__ - 1)], "assigning variable theta");
                    current_statement__ = 2;
                    pos__ = (pos__ + 1);}
                } 
                for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
                  current_statement__ = 2;
                  if (lcm_sym1__) {
                    current_statement__ = 2;
                    assign(theta,
                      cons_list(index_uni(1),
                        cons_list(index_uni(sym2__),
                          cons_list(index_uni(sym1__), nil_index_list()))),
                      theta_flat__[(pos__ - 1)], "assigning variable theta");
                    current_statement__ = 2;
                    pos__ = (pos__ + 1);
                    for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                      current_statement__ = 2;
                      assign(theta,
                        cons_list(index_uni(sym3__),
                          cons_list(index_uni(sym2__),
                            cons_list(index_uni(sym1__), nil_index_list()))),
                        theta_flat__[(pos__ - 1)], "assigning variable theta");
                      current_statement__ = 2;
                      pos__ = (pos__ + 1);}
                  } }
              } }
          }
        } else {
          lcm_sym1__ = logical_gte(J, 1);
        }
      }
      current_statement__ = 2;
      if (lcm_sym1__) {
        current_statement__ = 2;
        if (lcm_sym2__) {
          current_statement__ = 2;
          assign(theta,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())),
            stan::math::simplex_free(theta[(1 - 1)][(1 - 1)]),
            "assigning variable theta");
          for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
            current_statement__ = 2;
            assign(theta,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              stan::math::simplex_free(theta[(1 - 1)][(sym2__ - 1)]),
              "assigning variable theta");}
        } 
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 2;
          if (lcm_sym2__) {
            current_statement__ = 2;
            assign(theta,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())),
              stan::math::simplex_free(theta[(sym1__ - 1)][(1 - 1)]),
              "assigning variable theta");
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              current_statement__ = 2;
              assign(theta,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                stan::math::simplex_free(theta[(sym1__ - 1)][(sym2__ - 1)]),
                "assigning variable theta");}
          } }
      } 
      lcm_sym4__ = (K - 1);
      lcm_sym3__ = logical_gte(lcm_sym4__, 1);
      if (lcm_sym3__) {
        vars__.push_back(pi[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= lcm_sym4__; ++sym1__) {
          vars__.push_back(pi[(sym1__ - 1)]);}
      } 
      if (lcm_sym3__) {
        if (lcm_sym2__) {
          if (lcm_sym1__) {
            vars__.push_back(theta[(1 - 1)][(1 - 1)][(1 - 1)]);
            for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
              vars__.push_back(theta[(sym3__ - 1)][(1 - 1)][(1 - 1)]);}
          } 
          for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
            if (lcm_sym1__) {
              vars__.push_back(theta[(1 - 1)][(sym2__ - 1)][(1 - 1)]);
              for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                vars__.push_back(theta[(sym3__ - 1)][(sym2__ - 1)][(1 - 1)]);
              }
            } }
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym4__; ++sym1__) {
          if (lcm_sym2__) {
            if (lcm_sym1__) {
              vars__.push_back(theta[(1 - 1)][(1 - 1)][(sym1__ - 1)]);
              for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                vars__.push_back(theta[(sym3__ - 1)][(1 - 1)][(sym1__ - 1)]);
              }
            } 
            for (size_t sym2__ = 2; sym2__ <= K; ++sym2__) {
              if (lcm_sym1__) {
                vars__.push_back(theta[(1 - 1)][(sym2__ - 1)][(sym1__ - 1)]);
                for (size_t sym3__ = 2; sym3__ <= J; ++sym3__) {
                  vars__.push_back(
                    theta[(sym3__ - 1)][(sym2__ - 1)][(sym1__ - 1)]);}
              } }
          } }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("pi");
    names__.push_back("theta");
    names__.push_back("log_Pr_z");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(K);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(J);
    
    dims__.push_back(K);
    
    dims__.push_back(K);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(I);
    
    dims__.push_back(K);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    for (size_t sym94__ = 1; sym94__ <= K; ++sym94__) {
      {
        param_names__.push_back(std::string() + "pi" + '.' + std::to_string(sym94__));
      }}
    for (size_t sym94__ = 1; sym94__ <= K; ++sym94__) {
      {
        for (size_t sym95__ = 1; sym95__ <= K; ++sym95__) {
          {
            for (size_t sym96__ = 1; sym96__ <= J; ++sym96__) {
              {
                param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym96__) + '.' + std::to_string(sym95__) + '.' + std::to_string(sym94__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      for (size_t sym94__ = 1; sym94__ <= K; ++sym94__) {
        {
          for (size_t sym95__ = 1; sym95__ <= I; ++sym95__) {
            {
              param_names__.push_back(std::string() + "log_Pr_z" + '.' + std::to_string(sym95__) + '.' + std::to_string(sym94__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    for (size_t sym94__ = 1; sym94__ <= (K - 1); ++sym94__) {
      {
        param_names__.push_back(std::string() + "pi" + '.' + std::to_string(sym94__));
      }}
    for (size_t sym94__ = 1; sym94__ <= (K - 1); ++sym94__) {
      {
        for (size_t sym95__ = 1; sym95__ <= K; ++sym95__) {
          {
            for (size_t sym96__ = 1; sym96__ <= J; ++sym96__) {
              {
                param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym96__) + '.' + std::to_string(sym95__) + '.' + std::to_string(sym94__));
              }}
          }}
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      for (size_t sym94__ = 1; sym94__ <= K; ++sym94__) {
        {
          for (size_t sym95__ = 1; sym95__ <= I; ++sym95__) {
            {
              param_names__.push_back(std::string() + "log_Pr_z" + '.' + std::to_string(sym95__) + '.' + std::to_string(sym94__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" << K << "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" << I << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"pi\",\"type\":{\"name\":\"vector\",\"length\":" << (K - 1) << "},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"array\",\"length\":" << K << ",\"element_type\":{\"name\":\"vector\",\"length\":" << (K - 1) << "}}},\"block\":\"parameters\"},{\"name\":\"log_Pr_z\",\"type\":{\"name\":\"array\",\"length\":" << I << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef expr_prop_fail7_model_namespace::expr_prop_fail7_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp expr-prop-fail8.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace expr_prop_fail8_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'expr-prop-fail8.stan', line 11, column 2 to column 13)",
                                                      " (in 'expr-prop-fail8.stan', line 12, column 2 to column 13)",
                                                      " (in 'expr-prop-fail8.stan', line 14, column 2 to column 26)",
                                                      " (in 'expr-prop-fail8.stan', line 15, column 2 to column 24)",
                                                      " (in 'expr-prop-fail8.stan', line 17, column 2 to column 22)",
                                                      " (in 'expr-prop-fail8.stan', line 18, column 2 to column 24)",
                                                      " (in 'expr-prop-fail8.stan', line 21, column 2 to column 47)",
                                                      " (in 'expr-prop-fail8.stan', line 22, column 2 to column 16)",
                                                      " (in 'expr-prop-fail8.stan', line 23, column 2 to column 25)",
                                                      " (in 'expr-prop-fail8.stan', line 24, column 2 to column 24)",
                                                      " (in 'expr-prop-fail8.stan', line 27, column 2 to column 33)",
                                                      " (in 'expr-prop-fail8.stan', line 2, column 2 to column 17)",
                                                      " (in 'expr-prop-fail8.stan', line 3, column 2 to column 23)",
                                                      " (in 'expr-prop-fail8.stan', line 4, column 2 to column 39)",
                                                      " (in 'expr-prop-fail8.stan', line 5, column 2 to column 39)",
                                                      " (in 'expr-prop-fail8.stan', line 7, column 2 to column 20)",
                                                      " (in 'expr-prop-fail8.stan', line 8, column 2 to column 14)"};



class expr_prop_fail8_model : public model_base_crtp<expr_prop_fail8_model> {

 private:
  int lcm_sym38__;
  int lcm_sym37__;
  double lcm_sym36__;
  double lcm_sym35__;
  int lcm_sym34__;
  int lcm_sym33__;
  int lcm_sym32__;
  int lcm_sym31__;
  int lcm_sym30__;
  int lcm_sym29__;
  int lcm_sym28__;
  int pos__;
  int N;
  int N_edges;
  std::vector<int> node1;
  std::vector<int> node2;
  std::vector<int> y;
  Eigen::Matrix<double, -1, 1> x;
 
 public:
  ~expr_prop_fail8_model() { }
  
  std::string model_name() const { return "expr_prop_fail8_model"; }
  
  expr_prop_fail8_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "expr_prop_fail8_model_namespace::expr_prop_fail8_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      
      current_statement__ = 12;
      N = context__.vals_i("N")[(1 - 1)];
      context__.validate_dims("data initialization","N_edges","int",
          context__.to_vec());
      
      current_statement__ = 13;
      N_edges = context__.vals_i("N_edges")[(1 - 1)];
      current_statement__ = 14;
      validate_non_negative_index("node1", "N_edges", N_edges);
      context__.validate_dims("data initialization","node1","int",
          context__.to_vec(N_edges));
      node1 = std::vector<int>(N_edges, 0);
      
      current_statement__ = 14;
      assign(node1, nil_index_list(), context__.vals_i("node1"),
        "assigning variable node1");
      current_statement__ = 15;
      validate_non_negative_index("node2", "N_edges", N_edges);
      context__.validate_dims("data initialization","node2","int",
          context__.to_vec(N_edges));
      node2 = std::vector<int>(N_edges, 0);
      
      current_statement__ = 15;
      assign(node2, nil_index_list(), context__.vals_i("node2"),
        "assigning variable node2");
      current_statement__ = 16;
      validate_non_negative_index("y", "N", N);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(N));
      y = std::vector<int>(N, 0);
      
      current_statement__ = 16;
      assign(y, nil_index_list(), context__.vals_i("y"),
        "assigning variable y");
      current_statement__ = 17;
      validate_non_negative_index("x", "N", N);
      context__.validate_dims("data initialization","x","double",
          context__.to_vec(N));
      x = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> x_flat__;
        current_statement__ = 17;
        assign(x_flat__, nil_index_list(), context__.vals_r("x"),
          "assigning variable x_flat__");
        current_statement__ = 17;
        pos__ = 1;
        lcm_sym28__ = logical_gte(N, 1);
        if (lcm_sym28__) {
          current_statement__ = 17;
          assign(x, cons_list(index_uni(1), nil_index_list()),
            x_flat__[(1 - 1)], "assigning variable x");
          current_statement__ = 17;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 17;
            assign(x, cons_list(index_uni(sym1__), nil_index_list()),
              x_flat__[(pos__ - 1)], "assigning variable x");
            current_statement__ = 17;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 12;
      current_statement__ = 12;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 13;
      current_statement__ = 13;
      check_greater_or_equal(function__, "N_edges", N_edges, 0);
      lcm_sym29__ = logical_gte(N_edges, 1);
      if (lcm_sym29__) {
        current_statement__ = 14;
        current_statement__ = 14;
        check_greater_or_equal(function__, "node1[sym1__]", node1[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 14;
          current_statement__ = 14;
          check_greater_or_equal(function__, "node1[sym1__]",
                                 node1[(sym1__ - 1)], 1);}
      } 
      current_statement__ = 14;
      if (lcm_sym29__) {
        current_statement__ = 14;
        current_statement__ = 14;
        check_less_or_equal(function__, "node1[sym1__]", node1[(1 - 1)], N);
        for (size_t sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 14;
          current_statement__ = 14;
          check_less_or_equal(function__, "node1[sym1__]",
                              node1[(sym1__ - 1)], N);}
      } 
      current_statement__ = 15;
      if (lcm_sym29__) {
        current_statement__ = 15;
        current_statement__ = 15;
        check_greater_or_equal(function__, "node2[sym1__]", node2[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "node2[sym1__]",
                                 node2[(sym1__ - 1)], 1);}
      } 
      current_statement__ = 15;
      if (lcm_sym29__) {
        current_statement__ = 15;
        current_statement__ = 15;
        check_less_or_equal(function__, "node2[sym1__]", node2[(1 - 1)], N);
        for (size_t sym1__ = 2; sym1__ <= N_edges; ++sym1__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_less_or_equal(function__, "node2[sym1__]",
                              node2[(sym1__ - 1)], N);}
      } 
      current_statement__ = 16;
      if (lcm_sym28__) {
        current_statement__ = 16;
        current_statement__ = 16;
        check_greater_or_equal(function__, "y[sym1__]", y[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "y[sym1__]", y[(sym1__ - 1)], 0);
        }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 5;
      validate_non_negative_index("theta_std", "N", N);
      num_params_r__ += N;
      current_statement__ = 6;
      validate_non_negative_index("phi_std_raw", "N", N);
      num_params_r__ += N;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "expr_prop_fail8_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym27__;
      local_scalar_t__ lcm_sym26__;
      double lcm_sym25__;
      Eigen::Matrix<double, -1, 1> lcm_sym24__;
      int lcm_sym23__;
      local_scalar_t__ beta0;
      
      current_statement__ = 1;
      beta0 = in__.scalar();
      local_scalar_t__ beta1;
      
      current_statement__ = 2;
      beta1 = in__.scalar();
      local_scalar_t__ tau_theta;
      
      current_statement__ = 3;
      tau_theta = in__.scalar();
      current_statement__ = 3;
      if (jacobian__) {
        current_statement__ = 3;
        tau_theta = stan::math::lb_constrain(tau_theta, 0, lp__);
      } else {
        current_statement__ = 3;
        tau_theta = stan::math::lb_constrain(tau_theta, 0);
      }
      local_scalar_t__ tau_phi;
      
      current_statement__ = 4;
      tau_phi = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        tau_phi = stan::math::lb_constrain(tau_phi, 0, lp__);
      } else {
        current_statement__ = 4;
        tau_phi = stan::math::lb_constrain(tau_phi, 0);
      }
      current_statement__ = 5;
      validate_non_negative_index("theta_std", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_std;
      theta_std = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      current_statement__ = 5;
      theta_std = in__.vector(N);
      current_statement__ = 6;
      validate_non_negative_index("phi_std_raw", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      current_statement__ = 6;
      phi_std_raw = in__.vector(N);
      local_scalar_t__ sigma_phi;
      
      lcm_sym27__ = std::numeric_limits<double>::quiet_NaN();
      sigma_phi = lcm_sym27__;
      lcm_sym26__ = inv_sqrt(tau_phi);
      sigma_phi = lcm_sym26__;
      current_statement__ = 8;
      validate_non_negative_index("phi", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      current_statement__ = 8;
      if (logical_gte(N, 1)) {
        current_statement__ = 8;
        assign(phi, cons_list(index_uni(1), nil_index_list()), lcm_sym27__,
          "assigning variable phi");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 8;
          assign(phi, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym27__, "assigning variable phi");}
      } 
      current_statement__ = 9;
      assign(phi, cons_list(index_min_max(1, N), nil_index_list()),
        phi_std_raw, "assigning variable phi");
      current_statement__ = 10;
      assign(phi, nil_index_list(),
        multiply(stan::model::deep_copy(phi), lcm_sym26__),
        "assigning variable phi");
      current_statement__ = 7;
      current_statement__ = 7;
      check_greater_or_equal(function__, "sigma_phi", lcm_sym26__, 0);
      {
        current_statement__ = 11;
        lp_accum__.add(
          dot_self(
            rvalue(phi, cons_list(index_multi(node1), nil_index_list()),
              "phi")));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "expr_prop_fail8_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      Eigen::Matrix<double, -1, 1> lcm_sym14__;
      int lcm_sym13__;
      int lcm_sym12__;
      int lcm_sym11__;
      double beta0;
      
      current_statement__ = 1;
      beta0 = in__.scalar();
      double beta1;
      
      current_statement__ = 2;
      beta1 = in__.scalar();
      double tau_theta;
      
      current_statement__ = 3;
      tau_theta = in__.scalar();
      current_statement__ = 3;
      tau_theta = stan::math::lb_constrain(tau_theta, 0);
      double tau_phi;
      
      current_statement__ = 4;
      tau_phi = in__.scalar();
      current_statement__ = 4;
      tau_phi = stan::math::lb_constrain(tau_phi, 0);
      current_statement__ = 5;
      validate_non_negative_index("theta_std", "N", N);
      Eigen::Matrix<double, -1, 1> theta_std;
      theta_std = Eigen::Matrix<double, -1, 1>(N);
      
      current_statement__ = 5;
      theta_std = in__.vector(N);
      current_statement__ = 6;
      validate_non_negative_index("phi_std_raw", "N", N);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<double, -1, 1>(N);
      
      current_statement__ = 6;
      phi_std_raw = in__.vector(N);
      double sigma_phi;
      
      lcm_sym16__ = std::numeric_limits<double>::quiet_NaN();
      sigma_phi = lcm_sym16__;
      current_statement__ = 8;
      validate_non_negative_index("phi", "N", N);
      Eigen::Matrix<double, -1, 1> phi;
      phi = Eigen::Matrix<double, -1, 1>(N);
      
      lcm_sym11__ = logical_gte(N, 1);
      if (lcm_sym11__) {
        current_statement__ = 8;
        assign(phi, cons_list(index_uni(1), nil_index_list()), lcm_sym16__,
          "assigning variable phi");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 8;
          assign(phi, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym16__, "assigning variable phi");}
      } 
      vars__.push_back(beta0);
      vars__.push_back(beta1);
      vars__.push_back(tau_theta);
      vars__.push_back(tau_phi);
      if (lcm_sym11__) {
        vars__.push_back(theta_std[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(theta_std[(sym1__ - 1)]);}
      } 
      if (lcm_sym11__) {
        vars__.push_back(phi_std_raw[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(phi_std_raw[(sym1__ - 1)]);}
      } 
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym15__ = inv_sqrt(tau_phi);
      sigma_phi = lcm_sym15__;
      current_statement__ = 9;
      assign(phi, cons_list(index_min_max(1, N), nil_index_list()),
        phi_std_raw, "assigning variable phi");
      current_statement__ = 10;
      assign(phi, nil_index_list(),
        multiply(stan::model::deep_copy(phi), lcm_sym15__),
        "assigning variable phi");
      vars__.push_back(lcm_sym15__);
      if (lcm_sym11__) {
        vars__.push_back(phi[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(phi[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      double beta0;
      
      current_statement__ = 1;
      beta0 = context__.vals_r("beta0")[(1 - 1)];
      double beta1;
      
      current_statement__ = 2;
      beta1 = context__.vals_r("beta1")[(1 - 1)];
      double tau_theta;
      
      current_statement__ = 3;
      tau_theta = context__.vals_r("tau_theta")[(1 - 1)];
      current_statement__ = 3;
      tau_theta = stan::math::lb_free(tau_theta, 0);
      double tau_phi;
      
      current_statement__ = 4;
      tau_phi = context__.vals_r("tau_phi")[(1 - 1)];
      current_statement__ = 4;
      tau_phi = stan::math::lb_free(tau_phi, 0);
      current_statement__ = 5;
      validate_non_negative_index("theta_std", "N", N);
      Eigen::Matrix<double, -1, 1> theta_std;
      theta_std = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> theta_std_flat__;
        current_statement__ = 5;
        assign(theta_std_flat__, nil_index_list(),
          context__.vals_r("theta_std"),
          "assigning variable theta_std_flat__");
        current_statement__ = 5;
        pos__ = 1;
        lcm_sym1__ = logical_gte(N, 1);
        if (lcm_sym1__) {
          current_statement__ = 5;
          assign(theta_std, cons_list(index_uni(1), nil_index_list()),
            theta_std_flat__[(1 - 1)], "assigning variable theta_std");
          current_statement__ = 5;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 5;
            assign(theta_std, cons_list(index_uni(sym1__), nil_index_list()),
              theta_std_flat__[(pos__ - 1)], "assigning variable theta_std");
            current_statement__ = 5;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 6;
      validate_non_negative_index("phi_std_raw", "N", N);
      Eigen::Matrix<double, -1, 1> phi_std_raw;
      phi_std_raw = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> phi_std_raw_flat__;
        current_statement__ = 6;
        assign(phi_std_raw_flat__, nil_index_list(),
          context__.vals_r("phi_std_raw"),
          "assigning variable phi_std_raw_flat__");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        if (lcm_sym1__) {
          current_statement__ = 6;
          assign(phi_std_raw, cons_list(index_uni(1), nil_index_list()),
            phi_std_raw_flat__[(1 - 1)], "assigning variable phi_std_raw");
          current_statement__ = 6;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 6;
            assign(phi_std_raw,
              cons_list(index_uni(sym1__), nil_index_list()),
              phi_std_raw_flat__[(pos__ - 1)],
              "assigning variable phi_std_raw");
            current_statement__ = 6;
            pos__ = (pos__ + 1);}
        } 
      }
      vars__.push_back(beta0);
      vars__.push_back(beta1);
      vars__.push_back(tau_theta);
      vars__.push_back(tau_phi);
      if (lcm_sym1__) {
        vars__.push_back(theta_std[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(theta_std[(sym1__ - 1)]);}
      } 
      if (lcm_sym1__) {
        vars__.push_back(phi_std_raw[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(phi_std_raw[(sym1__ - 1)]);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("beta0");
    names__.push_back("beta1");
    names__.push_back("tau_theta");
    names__.push_back("tau_phi");
    names__.push_back("theta_std");
    names__.push_back("phi_std_raw");
    names__.push_back("sigma_phi");
    names__.push_back("phi");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "beta0");
    param_names__.push_back(std::string() + "beta1");
    param_names__.push_back(std::string() + "tau_theta");
    param_names__.push_back(std::string() + "tau_phi");
    for (size_t sym39__ = 1; sym39__ <= N; ++sym39__) {
      {
        param_names__.push_back(std::string() + "theta_std" + '.' + std::to_string(sym39__));
      }}
    for (size_t sym39__ = 1; sym39__ <= N; ++sym39__) {
      {
        param_names__.push_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym39__));
      }}
    if (emit_transformed_parameters__) {
      param_names__.push_back(std::string() + "sigma_phi");
      for (size_t sym39__ = 1; sym39__ <= N; ++sym39__) {
        {
          param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym39__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "beta0");
    param_names__.push_back(std::string() + "beta1");
    param_names__.push_back(std::string() + "tau_theta");
    param_names__.push_back(std::string() + "tau_phi");
    for (size_t sym39__ = 1; sym39__ <= N; ++sym39__) {
      {
        param_names__.push_back(std::string() + "theta_std" + '.' + std::to_string(sym39__));
      }}
    for (size_t sym39__ = 1; sym39__ <= N; ++sym39__) {
      {
        param_names__.push_back(std::string() + "phi_std_raw" + '.' + std::to_string(sym39__));
      }}
    if (emit_transformed_parameters__) {
      param_names__.push_back(std::string() + "sigma_phi");
      for (size_t sym39__ = 1; sym39__ <= N; ++sym39__) {
        {
          param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym39__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta_std\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"phi_std_raw\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"parameters\"},{\"name\":\"sigma_phi\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef expr_prop_fail8_model_namespace::expr_prop_fail8_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp fails-test.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace fails_test_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'fails-test.stan', line 71, column 2 to column 31)",
                                                      " (in 'fails-test.stan', line 72, column 2 to column 40)",
                                                      " (in 'fails-test.stan', line 76, column 2 to column 51)",
                                                      " (in 'fails-test.stan', line 77, column 2 to column 49)",
                                                      " (in 'fails-test.stan', line 78, column 2 to column 49)",
                                                      " (in 'fails-test.stan', line 83, column 6 to column 20)",
                                                      " (in 'fails-test.stan', line 84, column 6 to column 18)",
                                                      " (in 'fails-test.stan', line 82, column 32 to line 85, column 5)",
                                                      " (in 'fails-test.stan', line 87, column 6 to column 32)",
                                                      " (in 'fails-test.stan', line 88, column 6 to column 23)",
                                                      " (in 'fails-test.stan', line 86, column 38 to line 89, column 5)",
                                                      " (in 'fails-test.stan', line 86, column 4 to line 89, column 5)",
                                                      " (in 'fails-test.stan', line 81, column 20 to line 90, column 3)",
                                                      " (in 'fails-test.stan', line 81, column 2 to line 90, column 3)",
                                                      " (in 'fails-test.stan', line 26, column 4 to column 34)",
                                                      " (in 'fails-test.stan', line 29, column 6 to column 32)",
                                                      " (in 'fails-test.stan', line 32, column 8 to column 37)",
                                                      " (in 'fails-test.stan', line 33, column 8 to column 32)",
                                                      " (in 'fails-test.stan', line 41, column 8 to line 42, column 83)",
                                                      " (in 'fails-test.stan', line 30, column 37 to line 43, column 7)",
                                                      " (in 'fails-test.stan', line 28, column 22 to line 44, column 5)",
                                                      " (in 'fails-test.stan', line 25, column 47 to line 46, column 3)",
                                                      " (in 'fails-test.stan', line 105, column 8 to column 37)",
                                                      " (in 'fails-test.stan', line 106, column 8 to column 41)",
                                                      " (in 'fails-test.stan', line 104, column 40 to line 107, column 7)",
                                                      " (in 'fails-test.stan', line 108, column 6 to column 37)",
                                                      " (in 'fails-test.stan', line 103, column 22 to line 109, column 5)",
                                                      " (in 'fails-test.stan', line 102, column 20 to line 110, column 3)",
                                                      " (in 'fails-test.stan', line 102, column 2 to line 110, column 3)",
                                                      " (in 'fails-test.stan', line 50, column 2 to column 20)",
                                                      " (in 'fails-test.stan', line 51, column 2 to column 27)",
                                                      " (in 'fails-test.stan', line 52, column 2 to column 44)",
                                                      " (in 'fails-test.stan', line 53, column 2 to column 23)",
                                                      " (in 'fails-test.stan', line 54, column 2 to column 54)",
                                                      " (in 'fails-test.stan', line 58, column 2 to column 38)",
                                                      " (in 'fails-test.stan', line 60, column 2 to column 45)",
                                                      " (in 'fails-test.stan', line 61, column 2 to column 44)",
                                                      " (in 'fails-test.stan', line 8, column 8 to column 17)",
                                                      " (in 'fails-test.stan', line 7, column 6 to line 8, column 17)",
                                                      " (in 'fails-test.stan', line 5, column 31 to line 10, column 3)",
                                                      " (in 'fails-test.stan', line 65, column 4 to column 35)",
                                                      " (in 'fails-test.stan', line 64, column 2 to line 65, column 35)",
                                                      " (in 'fails-test.stan', line 15, column 6 to column 32)",
                                                      " (in 'fails-test.stan', line 19, column 8 to column 17)",
                                                      " (in 'fails-test.stan', line 18, column 6 to line 19, column 17)",
                                                      " (in 'fails-test.stan', line 13, column 37 to line 20, column 5)",
                                                      " (in 'fails-test.stan', line 12, column 30 to line 22, column 3)",
                                                      " (in 'fails-test.stan', line 67, column 4 to column 33)",
                                                      " (in 'fails-test.stan', line 66, column 2 to line 67, column 33)",
                                                      " (in 'fails-test.stan', line 9, column 4 to column 13)",
                                                      " (in 'fails-test.stan', line 21, column 4 to column 13)",
                                                      " (in 'fails-test.stan', line 30, column 6 to line 43, column 7)",
                                                      " (in 'fails-test.stan', line 28, column 4 to line 44, column 5)",
                                                      " (in 'fails-test.stan', line 45, column 4 to column 15)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym33__;
    int lcm_sym32__;
    int lcm_sym31__;
    int lcm_sym30__;
    {
      lcm_sym31__ = size(y_i);
      if (logical_gte(lcm_sym31__, 1)) {
        current_statement__ = 39;
        if (y_i[(1 - 1)]) {
          current_statement__ = 38;
          return 1;
        } 
        for (size_t k = 2; k <= lcm_sym31__; ++k) {
          current_statement__ = 39;
          if (y_i[(k - 1)]) {
            current_statement__ = 38;
            return k;
          } }
      } 
      current_statement__ = 50;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym39__;
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    int lcm_sym35__;
    int lcm_sym34__;
    {
      lcm_sym37__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym37__, 0)) {
        int k;
        
        lcm_sym36__ = (size(y_i) - 0);
        current_statement__ = 45;
        if (y_i[(lcm_sym36__ - 1)]) {
          current_statement__ = 44;
          return lcm_sym36__;
        } 
        for (size_t k_rev = 1; k_rev <= lcm_sym37__; ++k_rev) {
          int k;
          
          lcm_sym35__ = (size(y_i) - k_rev);
          current_statement__ = 45;
          if (y_i[(lcm_sym35__ - 1)]) {
            current_statement__ = 44;
            return lcm_sym35__;
          } }
      } 
      current_statement__ = 51;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__,
T3__>::type, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions,
                const Eigen::Matrix<T2__, -1, -1>& p,
                const Eigen::Matrix<T3__, -1, -1>& phi,
                std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T2__,
          T3__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    double lcm_sym51__;
    double lcm_sym50__;
    double lcm_sym49__;
    double lcm_sym48__;
    double lcm_sym47__;
    int lcm_sym46__;
    int lcm_sym45__;
    int lcm_sym44__;
    int lcm_sym43__;
    int lcm_sym42__;
    int lcm_sym41__;
    int lcm_sym40__;
    {
      current_statement__ = 15;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      lcm_sym41__ = logical_gte(nind, 1);
      if (lcm_sym41__) {
        lcm_sym40__ = logical_gte(n_occasions, 1);
        if (lcm_sym40__) {
          lcm_sym51__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym51__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 15;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym51__,
              "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 15;
          if (lcm_sym40__) {
            lcm_sym51__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym51__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 15;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym51__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 53;
      if (lcm_sym41__) {
        current_statement__ = 16;
        assign(chi,
          cons_list(index_uni(1),
            cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
          "assigning variable chi");
        lcm_sym44__ = (n_occasions - 1);
        lcm_sym42__ = logical_gte(lcm_sym44__, 1);
        if (lcm_sym42__) {
          int t_curr;
          
          int t_next;
          
          lcm_sym46__ = (lcm_sym44__ + 1);
          current_statement__ = 19;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym44__), nil_index_list())),
            stan::math::fma(
              (rvalue(phi,
                 cons_list(index_uni(1),
                   cons_list(index_uni(lcm_sym44__), nil_index_list())),
                 "phi") *
                (1 -
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym46__ - 1)),
                        nil_index_list())), "p"))),
              rvalue(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(lcm_sym46__), nil_index_list())),
                "chi"),
              (1 -
                rvalue(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym44__), nil_index_list())),
                  "phi"))), "assigning variable chi");
          for (size_t t = 2; t <= lcm_sym44__; ++t) {
            int t_curr;
            
            lcm_sym43__ = (n_occasions - t);
            int t_next;
            
            lcm_sym45__ = (lcm_sym43__ + 1);
            current_statement__ = 19;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(lcm_sym43__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(1),
                     cons_list(index_uni(lcm_sym43__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((lcm_sym45__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(chi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym45__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym43__), nil_index_list())),
                    "phi"))), "assigning variable chi");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          current_statement__ = 16;
          assign(chi,
            cons_list(index_uni(i),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable chi");
          current_statement__ = 52;
          if (lcm_sym42__) {
            int t_curr;
            
            int t_next;
            
            lcm_sym46__ = (lcm_sym44__ + 1);
            current_statement__ = 19;
            assign(chi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym44__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(i),
                     cons_list(index_uni(lcm_sym44__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym46__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(lcm_sym46__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym44__), nil_index_list())),
                    "phi"))), "assigning variable chi");
            for (size_t t = 2; t <= lcm_sym44__; ++t) {
              int t_curr;
              
              lcm_sym43__ = (n_occasions - t);
              int t_next;
              
              lcm_sym45__ = (lcm_sym43__ + 1);
              current_statement__ = 19;
              assign(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(lcm_sym43__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_uni(lcm_sym43__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni((lcm_sym45__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(chi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym45__), nil_index_list())),
                    "chi"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym43__), nil_index_list())),
                      "phi"))), "assigning variable chi");}
          } }
      } 
      current_statement__ = 54;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__,
T3__>::type, -1, -1>
operator()(const int& nind, const int& n_occasions,
           const Eigen::Matrix<T2__, -1, -1>& p,
           const Eigen::Matrix<T3__, -1, -1>& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

class fails_test_model : public model_base_crtp<fails_test_model> {

 private:
  int lcm_sym180__;
  int lcm_sym179__;
  int lcm_sym178__;
  int lcm_sym177__;
  int lcm_sym176__;
  int lcm_sym175__;
  int lcm_sym174__;
  int lcm_sym173__;
  int lcm_sym172__;
  int lcm_sym171__;
  int lcm_sym170__;
  int lcm_sym169__;
  int lcm_sym168__;
  int lcm_sym167__;
  int lcm_sym166__;
  int lcm_sym165__;
  int lcm_sym164__;
  int lcm_sym163__;
  int lcm_sym162__;
  int lcm_sym161__;
  int lcm_sym160__;
  int lcm_sym159__;
  int lcm_sym158__;
  int lcm_sym157__;
  int lcm_sym156__;
  int lcm_sym155__;
  int lcm_sym154__;
  int lcm_sym153__;
  int lcm_sym152__;
  int lcm_sym151__;
  int lcm_sym150__;
  int pos__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int max_age;
  std::vector<std::vector<int>> x;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~fails_test_model() { }
  
  std::string model_name() const { return "fails_test_model"; }
  
  fails_test_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "fails_test_model_namespace::fails_test_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","nind","int",
          context__.to_vec());
      
      current_statement__ = 30;
      nind = context__.vals_i("nind")[(1 - 1)];
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      
      current_statement__ = 31;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 32;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 32;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(nind, n_occasions));
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, 0));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 32;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 32;
        pos__ = 1;
        lcm_sym150__ = logical_gte(n_occasions, 1);
        if (lcm_sym150__) {
          {
            lcm_sym151__ = logical_gte(nind, 1);
            if (lcm_sym151__) {
              current_statement__ = 32;
              assign(y,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())),
                y_flat__[(1 - 1)], "assigning variable y");
              current_statement__ = 32;
              pos__ = 2;
              for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 32;
                assign(y,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(1), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 32;
                pos__ = (pos__ + 1);}
            } 
            for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 32;
              if (lcm_sym151__) {
                current_statement__ = 32;
                assign(y,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 32;
                pos__ = (pos__ + 1);
                for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                  current_statement__ = 32;
                  assign(y,
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list())),
                    y_flat__[(pos__ - 1)], "assigning variable y");
                  current_statement__ = 32;
                  pos__ = (pos__ + 1);}
              } }
          }
        } else {
          lcm_sym151__ = logical_gte(nind, 1);
        }
      }
      context__.validate_dims("data initialization","max_age","int",
          context__.to_vec());
      
      current_statement__ = 33;
      max_age = context__.vals_i("max_age")[(1 - 1)];
      current_statement__ = 34;
      validate_non_negative_index("x", "nind", nind);
      lcm_sym153__ = (n_occasions - 1);
      validate_non_negative_index("x", "(n_occasions - 1)", lcm_sym153__);
      context__.validate_dims("data initialization","x","int",
          context__.to_vec(nind, lcm_sym153__));
      x = std::vector<std::vector<int>>(nind, std::vector<int>(lcm_sym153__, 0));
      
      {
        std::vector<int> x_flat__;
        current_statement__ = 34;
        assign(x_flat__, nil_index_list(), context__.vals_i("x"),
          "assigning variable x_flat__");
        current_statement__ = 34;
        pos__ = 1;
        lcm_sym152__ = logical_gte(lcm_sym153__, 1);
        if (lcm_sym152__) {
          current_statement__ = 34;
          if (lcm_sym151__) {
            current_statement__ = 34;
            assign(x,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              x_flat__[(1 - 1)], "assigning variable x");
            current_statement__ = 34;
            pos__ = 2;
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              current_statement__ = 34;
              assign(x,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                x_flat__[(pos__ - 1)], "assigning variable x");
              current_statement__ = 34;
              pos__ = (pos__ + 1);}
          } 
          for (size_t sym1__ = 2; sym1__ <= lcm_sym153__; ++sym1__) {
            current_statement__ = 34;
            if (lcm_sym151__) {
              current_statement__ = 34;
              assign(x,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                x_flat__[(pos__ - 1)], "assigning variable x");
              current_statement__ = 34;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 34;
                assign(x,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  x_flat__[(pos__ - 1)], "assigning variable x");
                current_statement__ = 34;
                pos__ = (pos__ + 1);}
            } }
        } 
      }
      
      current_statement__ = 35;
      n_occ_minus_1 = lcm_sym153__;
      current_statement__ = 36;
      validate_non_negative_index("first", "nind", nind);
      first = std::vector<int>(nind, 0);
      
      current_statement__ = 37;
      validate_non_negative_index("last", "nind", nind);
      last = std::vector<int>(nind, 0);
      
      current_statement__ = 42;
      if (lcm_sym151__) {
        int inline_sym21__;
        int inline_sym23__;
        
        inline_sym23__ = 0;
        for (size_t inline_sym24__ = 1; inline_sym24__ <= 1; ++inline_sym24__) {
          lcm_sym160__ = size(y[(1 - 1)]);
          for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym160__;
               ++inline_sym22__) {
            current_statement__ = 39;
            if (y[(1 - 1)][(inline_sym22__ - 1)]) {
              inline_sym23__ = 1;
              inline_sym21__ = inline_sym22__;
              break;
            } }
          if (inline_sym23__) {
            break;
          } 
          inline_sym23__ = 1;
          inline_sym21__ = 0;
          break;}
        assign(first, cons_list(index_uni(1), nil_index_list()),
          inline_sym21__, "assigning variable first");
        for (size_t i = 2; i <= nind; ++i) {
          int inline_sym21__;
          int inline_sym23__;
          
          inline_sym23__ = 0;
          for (size_t inline_sym24__ = 1; inline_sym24__ <= 1;
               ++inline_sym24__) {
            lcm_sym159__ = size(y[(i - 1)]);
            for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym159__;
                 ++inline_sym22__) {
              current_statement__ = 39;
              if (y[(i - 1)][(inline_sym22__ - 1)]) {
                inline_sym23__ = 1;
                inline_sym21__ = inline_sym22__;
                break;
              } }
            if (inline_sym23__) {
              break;
            } 
            inline_sym23__ = 1;
            inline_sym21__ = 0;
            break;}
          assign(first, cons_list(index_uni(i), nil_index_list()),
            inline_sym21__, "assigning variable first");}
      } 
      current_statement__ = 49;
      if (lcm_sym151__) {
        int inline_sym25__;
        int inline_sym28__;
        
        inline_sym28__ = 0;
        for (size_t inline_sym29__ = 1; inline_sym29__ <= 1; ++inline_sym29__) {
          lcm_sym160__ = size(y[(1 - 1)]);
          lcm_sym157__ = (lcm_sym160__ - 1);
          for (size_t inline_sym27__ = 0; inline_sym27__ <= lcm_sym157__;
               ++inline_sym27__) {
            int inline_sym26__;
            
            lcm_sym156__ = (lcm_sym160__ - inline_sym27__);
            inline_sym26__ = lcm_sym156__;
            current_statement__ = 45;
            if (y[(1 - 1)][(lcm_sym156__ - 1)]) {
              inline_sym28__ = 1;
              inline_sym25__ = lcm_sym156__;
              break;
            } }
          if (inline_sym28__) {
            break;
          } 
          inline_sym28__ = 1;
          inline_sym25__ = 0;
          break;}
        assign(last, cons_list(index_uni(1), nil_index_list()),
          inline_sym25__, "assigning variable last");
        for (size_t i = 2; i <= nind; ++i) {
          int inline_sym25__;
          int inline_sym28__;
          
          inline_sym28__ = 0;
          for (size_t inline_sym29__ = 1; inline_sym29__ <= 1;
               ++inline_sym29__) {
            lcm_sym159__ = size(y[(i - 1)]);
            lcm_sym155__ = (lcm_sym159__ - 1);
            for (size_t inline_sym27__ = 0; inline_sym27__ <= lcm_sym155__;
                 ++inline_sym27__) {
              int inline_sym26__;
              
              lcm_sym154__ = (lcm_sym159__ - inline_sym27__);
              inline_sym26__ = lcm_sym154__;
              current_statement__ = 45;
              if (y[(i - 1)][(lcm_sym154__ - 1)]) {
                inline_sym28__ = 1;
                inline_sym25__ = lcm_sym154__;
                break;
              } }
            if (inline_sym28__) {
              break;
            } 
            inline_sym28__ = 1;
            inline_sym25__ = 0;
            break;}
          assign(last, cons_list(index_uni(i), nil_index_list()),
            inline_sym25__, "assigning variable last");}
      } 
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 31;
      current_statement__ = 31;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 32;
      if (lcm_sym151__) {
        current_statement__ = 32;
        if (lcm_sym150__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 32;
          if (lcm_sym150__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 32;
              current_statement__ = 32;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 32;
      if (lcm_sym151__) {
        current_statement__ = 32;
        if (lcm_sym150__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 32;
          if (lcm_sym150__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 32;
              current_statement__ = 32;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      current_statement__ = 33;
      current_statement__ = 33;
      check_greater_or_equal(function__, "max_age", max_age, 1);
      current_statement__ = 34;
      if (lcm_sym151__) {
        current_statement__ = 34;
        if (lcm_sym152__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                 x[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
            current_statement__ = 34;
            current_statement__ = 34;
            check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                   x[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 34;
          if (lcm_sym152__) {
            current_statement__ = 34;
            current_statement__ = 34;
            check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                   x[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
              current_statement__ = 34;
              current_statement__ = 34;
              check_greater_or_equal(function__, "x[sym1__, sym2__]",
                                     x[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 34;
      if (lcm_sym151__) {
        current_statement__ = 34;
        if (lcm_sym152__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_less_or_equal(function__, "x[sym1__, sym2__]",
                              x[(1 - 1)][(1 - 1)], max_age);
          for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
            current_statement__ = 34;
            current_statement__ = 34;
            check_less_or_equal(function__, "x[sym1__, sym2__]",
                                x[(1 - 1)][(sym2__ - 1)], max_age);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 34;
          if (lcm_sym152__) {
            current_statement__ = 34;
            current_statement__ = 34;
            check_less_or_equal(function__, "x[sym1__, sym2__]",
                                x[(sym1__ - 1)][(1 - 1)], max_age);
            for (size_t sym2__ = 2; sym2__ <= lcm_sym153__; ++sym2__) {
              current_statement__ = 34;
              current_statement__ = 34;
              check_less_or_equal(function__, "x[sym1__, sym2__]",
                                  x[(sym1__ - 1)][(sym2__ - 1)], max_age);}
          } }
      } 
      current_statement__ = 36;
      if (lcm_sym151__) {
        current_statement__ = 36;
        current_statement__ = 36;
        check_greater_or_equal(function__, "first[sym1__]", first[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 36;
          current_statement__ = 36;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 36;
      if (lcm_sym151__) {
        current_statement__ = 36;
        current_statement__ = 36;
        check_less_or_equal(function__, "first[sym1__]", first[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 36;
          current_statement__ = 36;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);}
      } 
      current_statement__ = 37;
      if (lcm_sym151__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_greater_or_equal(function__, "last[sym1__]", last[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 37;
          current_statement__ = 37;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 37;
      if (lcm_sym151__) {
        current_statement__ = 37;
        current_statement__ = 37;
        check_less_or_equal(function__, "last[sym1__]", last[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 37;
          current_statement__ = 37;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      current_statement__ = 2;
      validate_non_negative_index("beta", "max_age", max_age);
      num_params_r__ += max_age;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "fails_test_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      int lcm_sym149__;
      int lcm_sym148__;
      int lcm_sym147__;
      int lcm_sym146__;
      double lcm_sym145__;
      double lcm_sym144__;
      double lcm_sym143__;
      double lcm_sym142__;
      double lcm_sym140__;
      double lcm_sym138__;
      double lcm_sym141__;
      double lcm_sym136__;
      double lcm_sym135__;
      double lcm_sym134__;
      double lcm_sym133__;
      double lcm_sym132__;
      double lcm_sym131__;
      double lcm_sym130__;
      double lcm_sym129__;
      double lcm_sym128__;
      double lcm_sym127__;
      double lcm_sym126__;
      double lcm_sym125__;
      int lcm_sym124__;
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      int lcm_sym120__;
      int lcm_sym119__;
      int lcm_sym118__;
      int lcm_sym117__;
      int lcm_sym116__;
      int lcm_sym115__;
      int lcm_sym114__;
      int lcm_sym113__;
      int lcm_sym112__;
      int lcm_sym111__;
      int lcm_sym110__;
      int lcm_sym109__;
      int lcm_sym108__;
      int lcm_sym107__;
      int lcm_sym106__;
      int lcm_sym105__;
      int lcm_sym104__;
      int lcm_sym103__;
      local_scalar_t__ mean_p;
      
      current_statement__ = 1;
      mean_p = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      current_statement__ = 2;
      validate_non_negative_index("beta", "max_age", max_age);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(max_age);
      
      current_statement__ = 2;
      beta = in__.vector(max_age);
      current_statement__ = 2;
      if (logical_gte(max_age, 1)) {
        current_statement__ = 2;
        if (jacobian__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            stan::math::lub_constrain(beta[(1 - 1)], 0, 1, lp__),
            "assigning variable beta");
        } else {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            stan::math::lub_constrain(beta[(1 - 1)], 0, 1),
            "assigning variable beta");
        }
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          current_statement__ = 2;
          if (jacobian__) {
            current_statement__ = 2;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1, lp__),
              "assigning variable beta");
          } else {
            current_statement__ = 2;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1),
              "assigning variable beta");
          }}
      } 
      current_statement__ = 3;
      validate_non_negative_index("phi", "nind", nind);
      lcm_sym116__ = (n_occasions - 1);
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym116__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym116__);
      
      lcm_sym105__ = logical_gte(nind, 1);
      if (lcm_sym105__) {
        lcm_sym106__ = logical_gte(lcm_sym116__, 1);
        if (lcm_sym106__) {
          lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
            "assigning variable phi");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym116__; ++sym2__) {
            current_statement__ = 3;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym141__, "assigning variable phi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym106__) {
            lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
            assign(phi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
              "assigning variable phi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym116__; ++sym2__) {
              current_statement__ = 3;
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym141__, "assigning variable phi");}
          } }
      } 
      current_statement__ = 4;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 4;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym116__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym116__);
      
      current_statement__ = 4;
      if (lcm_sym105__) {
        lcm_sym106__ = logical_gte(lcm_sym116__, 1);
        if (lcm_sym106__) {
          lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym116__; ++sym2__) {
            current_statement__ = 4;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym141__, "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym106__) {
            lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym116__; ++sym2__) {
              current_statement__ = 4;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym141__, "assigning variable p");}
          } }
      } 
      current_statement__ = 5;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 5;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      current_statement__ = 5;
      if (lcm_sym105__) {
        lcm_sym104__ = logical_gte(n_occasions, 1);
        if (lcm_sym104__) {
          lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym141__, "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym104__) {
            lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym141__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 14;
      if (lcm_sym105__) {
        lcm_sym147__ = first[(1 - 1)];
        lcm_sym118__ = (lcm_sym147__ - 1);
        if (logical_gte(lcm_sym118__, 1)) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable p");
          for (size_t t = 2; t <= lcm_sym118__; ++t) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable p");}
        } 
        current_statement__ = 12;
        if (logical_gte(lcm_sym116__, lcm_sym147__)) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym147__), nil_index_list())),
            beta[(x[(1 - 1)][(lcm_sym147__ - 1)] - 1)],
            "assigning variable phi");
          lcm_sym124__ = (lcm_sym147__ + 1);
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym147__), nil_index_list())), mean_p,
            "assigning variable p");
          for (size_t t = lcm_sym124__; t <= lcm_sym116__; ++t) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())),
              beta[(x[(1 - 1)][(t - 1)] - 1)], "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_p,
              "assigning variable p");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          lcm_sym146__ = first[(i - 1)];
          lcm_sym117__ = (lcm_sym146__ - 1);
          if (logical_gte(lcm_sym117__, 1)) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable p");
            for (size_t t = 2; t <= lcm_sym117__; ++t) {
              current_statement__ = 6;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable phi");
              current_statement__ = 7;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable p");}
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym116__, lcm_sym146__)) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym146__), nil_index_list())),
              beta[(x[(i - 1)][(lcm_sym146__ - 1)] - 1)],
              "assigning variable phi");
            lcm_sym123__ = (lcm_sym146__ + 1);
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym146__), nil_index_list())),
              mean_p, "assigning variable p");
            for (size_t t = lcm_sym123__; t <= lcm_sym116__; ++t) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())),
                beta[(x[(i - 1)][(t - 1)] - 1)], "assigning variable phi");
              current_statement__ = 10;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_p,
                "assigning variable p");}
          } }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym11__;
      int inline_sym19__;
      
      inline_sym19__ = 0;
      for (size_t inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
        current_statement__ = 15;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym12__;
        inline_sym12__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        
        for (size_t inline_sym14__ = 1; inline_sym14__ <= nind;
             ++inline_sym14__) {
          if (logical_gte(n_occasions, 1)) {
            lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
            assign(inline_sym12__,
              cons_list(index_uni(inline_sym14__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym141__,
              "assigning variable inline_sym12__");
            for (size_t inline_sym13__ = 2; inline_sym13__ <= n_occasions;
                 ++inline_sym13__) {
              current_statement__ = 15;
              assign(inline_sym12__,
                cons_list(index_uni(inline_sym14__),
                  cons_list(index_uni(inline_sym13__), nil_index_list())),
                lcm_sym141__, "assigning variable inline_sym12__");}
          } 
          if (inline_sym19__) {
            break;
          } }
        if (inline_sym19__) {
          break;
        } 
        for (size_t inline_sym18__ = 1; inline_sym18__ <= nind;
             ++inline_sym18__) {
          current_statement__ = 16;
          assign(inline_sym12__,
            cons_list(index_uni(inline_sym18__),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable inline_sym12__");
          if (logical_gte(lcm_sym116__, 1)) {
            int inline_sym15__;
            
            int inline_sym16__;
            
            lcm_sym120__ = (lcm_sym116__ + 1);
            current_statement__ = 19;
            assign(inline_sym12__,
              cons_list(index_uni(inline_sym18__),
                cons_list(index_uni(lcm_sym116__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym18__),
                     cons_list(index_uni(lcm_sym116__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym18__),
                        cons_list(index_uni((lcm_sym120__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(inline_sym12__,
                  cons_list(index_uni(inline_sym18__),
                    cons_list(index_uni(lcm_sym120__), nil_index_list())),
                  "inline_sym12__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym18__),
                      cons_list(index_uni(lcm_sym116__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym12__");
            for (size_t inline_sym17__ = 2; inline_sym17__ <= lcm_sym116__;
                 ++inline_sym17__) {
              int inline_sym15__;
              
              lcm_sym115__ = (n_occasions - inline_sym17__);
              int inline_sym16__;
              
              lcm_sym119__ = (lcm_sym115__ + 1);
              current_statement__ = 19;
              assign(inline_sym12__,
                cons_list(index_uni(inline_sym18__),
                  cons_list(index_uni(lcm_sym115__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym18__),
                       cons_list(index_uni(lcm_sym115__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym18__),
                          cons_list(index_uni((lcm_sym119__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym12__,
                    cons_list(index_uni(inline_sym18__),
                      cons_list(index_uni(lcm_sym119__), nil_index_list())),
                    "inline_sym12__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym18__),
                        cons_list(index_uni(lcm_sym115__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym12__");}
          } 
          if (inline_sym19__) {
            break;
          } }
        if (inline_sym19__) {
          break;
        } 
        inline_sym19__ = 1;
        assign(inline_sym11__, nil_index_list(), inline_sym12__,
          "assigning variable inline_sym11__");
        break;}
      assign(chi, nil_index_list(), inline_sym11__, "assigning variable chi");
      current_statement__ = 3;
      current_statement__ = 3;
      check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      current_statement__ = 3;
      check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      current_statement__ = 4;
      check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      current_statement__ = 4;
      check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      current_statement__ = 5;
      check_greater_or_equal(function__, "chi", inline_sym11__, 0);
      current_statement__ = 5;
      current_statement__ = 5;
      check_less_or_equal(function__, "chi", inline_sym11__, 1);
      {
        current_statement__ = 29;
        if (lcm_sym105__) {
          lcm_sym147__ = first[(1 - 1)];
          if (logical_gt(lcm_sym147__, 0)) {
            lcm_sym149__ = last[(1 - 1)];
            lcm_sym124__ = (lcm_sym147__ + 1);
            if (logical_gte(lcm_sym149__, lcm_sym124__)) {
              current_statement__ = 23;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym124__ - 1)),
                        nil_index_list())), "phi")));
              lcm_sym122__ = (lcm_sym124__ + 1);
              lp_accum__.add(
                bernoulli_log<propto__>(y[(1 - 1)][(lcm_sym124__ - 1)],
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym124__ - 1)),
                        nil_index_list())), "p")));
              for (size_t t = lcm_sym122__; t <= lcm_sym149__; ++t) {
                current_statement__ = 23;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "phi")));
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(1 - 1)][(t - 1)],
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "p")));}
            } 
            current_statement__ = 26;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                rvalue(inline_sym11__,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym149__), nil_index_list())),
                  "inline_sym11__")));
          } 
          for (size_t i = 2; i <= nind; ++i) {
            lcm_sym146__ = first[(i - 1)];
            if (logical_gt(lcm_sym146__, 0)) {
              lcm_sym148__ = last[(i - 1)];
              lcm_sym123__ = (lcm_sym146__ + 1);
              if (logical_gte(lcm_sym148__, lcm_sym123__)) {
                current_statement__ = 23;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym123__ - 1)),
                          nil_index_list())), "phi")));
                lcm_sym121__ = (lcm_sym123__ + 1);
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(i - 1)][(lcm_sym123__ - 1)],
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym123__ - 1)),
                          nil_index_list())), "p")));
                for (size_t t = lcm_sym121__; t <= lcm_sym148__; ++t) {
                  current_statement__ = 23;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      rvalue(phi,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "phi")));
                  current_statement__ = 24;
                  lp_accum__.add(
                    bernoulli_log<propto__>(y[(i - 1)][(t - 1)],
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "p")));}
              } 
              current_statement__ = 26;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(inline_sym11__,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym148__), nil_index_list())),
                    "inline_sym11__")));
            } }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "fails_test_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym102__;
      double lcm_sym101__;
      double lcm_sym100__;
      double lcm_sym99__;
      double lcm_sym98__;
      double lcm_sym97__;
      double lcm_sym96__;
      double lcm_sym95__;
      double lcm_sym94__;
      double lcm_sym93__;
      double lcm_sym92__;
      double lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      double lcm_sym88__;
      double lcm_sym87__;
      double lcm_sym86__;
      double lcm_sym85__;
      double lcm_sym84__;
      double lcm_sym83__;
      double lcm_sym82__;
      double lcm_sym79__;
      double lcm_sym78__;
      int lcm_sym77__;
      int lcm_sym76__;
      int lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      int lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      int lcm_sym69__;
      int lcm_sym68__;
      int lcm_sym67__;
      int lcm_sym66__;
      int lcm_sym65__;
      int lcm_sym64__;
      int lcm_sym63__;
      int lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      double mean_p;
      
      current_statement__ = 1;
      mean_p = in__.scalar();
      current_statement__ = 1;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      current_statement__ = 2;
      validate_non_negative_index("beta", "max_age", max_age);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(max_age);
      
      current_statement__ = 2;
      beta = in__.vector(max_age);
      lcm_sym60__ = logical_gte(max_age, 1);
      if (lcm_sym60__) {
        current_statement__ = 2;
        assign(beta, cons_list(index_uni(1), nil_index_list()),
          stan::math::lub_constrain(beta[(1 - 1)], 0, 1),
          "assigning variable beta");
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(beta[(sym1__ - 1)], 0, 1),
            "assigning variable beta");}
      } 
      current_statement__ = 3;
      validate_non_negative_index("phi", "nind", nind);
      lcm_sym69__ = (n_occasions - 1);
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym69__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym69__);
      
      lcm_sym62__ = logical_gte(nind, 1);
      if (lcm_sym62__) {
        {
          lcm_sym63__ = logical_gte(lcm_sym69__, 1);
          if (lcm_sym63__) {
            lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
              "assigning variable phi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym69__; ++sym2__) {
              current_statement__ = 3;
              assign(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym82__, "assigning variable phi");}
          } 
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 3;
            if (lcm_sym63__) {
              lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym69__; ++sym2__) {
                current_statement__ = 3;
                assign(phi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym82__, "assigning variable phi");}
            } }
        }
      } else {
        lcm_sym63__ = logical_gte(lcm_sym69__, 1);
      }
      current_statement__ = 4;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 4;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym69__);
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, lcm_sym69__);
      
      current_statement__ = 4;
      if (lcm_sym62__) {
        current_statement__ = 4;
        if (lcm_sym63__) {
          lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym69__; ++sym2__) {
            current_statement__ = 4;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym82__,
              "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym63__) {
            lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym69__; ++sym2__) {
              current_statement__ = 4;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym82__, "assigning variable p");}
          } }
      } 
      current_statement__ = 5;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 5;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      current_statement__ = 5;
      if (lcm_sym62__) {
        {
          lcm_sym61__ = logical_gte(n_occasions, 1);
          if (lcm_sym61__) {
            lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              assign(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym82__, "assigning variable chi");}
          } 
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 5;
            if (lcm_sym61__) {
              lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
                "assigning variable chi");
              for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
                current_statement__ = 5;
                assign(chi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym82__, "assigning variable chi");}
            } }
        }
      } else {
        lcm_sym61__ = logical_gte(n_occasions, 1);
      }
      vars__.push_back(mean_p);
      if (lcm_sym60__) {
        vars__.push_back(beta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          vars__.push_back(beta[(sym1__ - 1)]);}
      } 
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 14;
      if (lcm_sym62__) {
        lcm_sym90__ = first[(1 - 1)];
        lcm_sym71__ = (lcm_sym90__ - 1);
        if (logical_gte(lcm_sym71__, 1)) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable p");
          for (size_t t = 2; t <= lcm_sym71__; ++t) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable p");}
        } 
        current_statement__ = 12;
        if (logical_gte(lcm_sym69__, lcm_sym90__)) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym90__), nil_index_list())),
            beta[(x[(1 - 1)][(lcm_sym90__ - 1)] - 1)],
            "assigning variable phi");
          lcm_sym77__ = (lcm_sym90__ + 1);
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym90__), nil_index_list())), mean_p,
            "assigning variable p");
          for (size_t t = lcm_sym77__; t <= lcm_sym69__; ++t) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())),
              beta[(x[(1 - 1)][(t - 1)] - 1)], "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_p,
              "assigning variable p");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          lcm_sym89__ = first[(i - 1)];
          lcm_sym70__ = (lcm_sym89__ - 1);
          if (logical_gte(lcm_sym70__, 1)) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable p");
            for (size_t t = 2; t <= lcm_sym70__; ++t) {
              current_statement__ = 6;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable phi");
              current_statement__ = 7;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable p");}
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym69__, lcm_sym89__)) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym89__), nil_index_list())),
              beta[(x[(i - 1)][(lcm_sym89__ - 1)] - 1)],
              "assigning variable phi");
            lcm_sym76__ = (lcm_sym89__ + 1);
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym89__), nil_index_list())), mean_p,
              "assigning variable p");
            for (size_t t = lcm_sym76__; t <= lcm_sym69__; ++t) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())),
                beta[(x[(i - 1)][(t - 1)] - 1)], "assigning variable phi");
              current_statement__ = 10;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_p,
                "assigning variable p");}
          } }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym9__;
      
      inline_sym9__ = 0;
      for (size_t inline_sym10__ = 1; inline_sym10__ <= 1; ++inline_sym10__) {
        current_statement__ = 15;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym2__;
        inline_sym2__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        
        for (size_t inline_sym4__ = 1; inline_sym4__ <= nind; ++inline_sym4__) {
          if (lcm_sym61__) {
            lcm_sym82__ = std::numeric_limits<double>::quiet_NaN();
            assign(inline_sym2__,
              cons_list(index_uni(inline_sym4__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym82__,
              "assigning variable inline_sym2__");
            for (size_t inline_sym3__ = 2; inline_sym3__ <= n_occasions;
                 ++inline_sym3__) {
              current_statement__ = 15;
              assign(inline_sym2__,
                cons_list(index_uni(inline_sym4__),
                  cons_list(index_uni(inline_sym3__), nil_index_list())),
                lcm_sym82__, "assigning variable inline_sym2__");}
          } 
          if (inline_sym9__) {
            break;
          } }
        if (inline_sym9__) {
          break;
        } 
        for (size_t inline_sym8__ = 1; inline_sym8__ <= nind; ++inline_sym8__) {
          current_statement__ = 16;
          assign(inline_sym2__,
            cons_list(index_uni(inline_sym8__),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable inline_sym2__");
          if (lcm_sym63__) {
            int inline_sym5__;
            
            int inline_sym6__;
            
            lcm_sym75__ = (lcm_sym69__ + 1);
            current_statement__ = 19;
            assign(inline_sym2__,
              cons_list(index_uni(inline_sym8__),
                cons_list(index_uni(lcm_sym69__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym8__),
                     cons_list(index_uni(lcm_sym69__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym8__),
                        cons_list(index_uni((lcm_sym75__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(inline_sym2__,
                  cons_list(index_uni(inline_sym8__),
                    cons_list(index_uni(lcm_sym75__), nil_index_list())),
                  "inline_sym2__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym8__),
                      cons_list(index_uni(lcm_sym69__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym2__");
            for (size_t inline_sym7__ = 2; inline_sym7__ <= lcm_sym69__;
                 ++inline_sym7__) {
              int inline_sym5__;
              
              lcm_sym68__ = (n_occasions - inline_sym7__);
              int inline_sym6__;
              
              lcm_sym74__ = (lcm_sym68__ + 1);
              current_statement__ = 19;
              assign(inline_sym2__,
                cons_list(index_uni(inline_sym8__),
                  cons_list(index_uni(lcm_sym68__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym8__),
                       cons_list(index_uni(lcm_sym68__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym8__),
                          cons_list(index_uni((lcm_sym74__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym2__,
                    cons_list(index_uni(inline_sym8__),
                      cons_list(index_uni(lcm_sym74__), nil_index_list())),
                    "inline_sym2__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym8__),
                        cons_list(index_uni(lcm_sym68__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym2__");}
          } 
          if (inline_sym9__) {
            break;
          } }
        if (inline_sym9__) {
          break;
        } 
        inline_sym9__ = 1;
        assign(inline_sym1__, nil_index_list(), inline_sym2__,
          "assigning variable inline_sym1__");
        break;}
      assign(chi, nil_index_list(), inline_sym1__, "assigning variable chi");
      if (lcm_sym63__) {
        if (lcm_sym62__) {
          vars__.push_back(
            rvalue(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "phi"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "phi"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym69__; ++sym1__) {
          if (lcm_sym62__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(phi,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            }
          } }
      } 
      if (lcm_sym63__) {
        if (lcm_sym62__) {
          vars__.push_back(
            rvalue(p,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "p"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "p"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym69__; ++sym1__) {
          if (lcm_sym62__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(p,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "p"));}
          } }
      } 
      if (lcm_sym61__) {
        if (lcm_sym62__) {
          vars__.push_back(
            rvalue(inline_sym1__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "inline_sym1__"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                "inline_sym1__"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym62__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "inline_sym1__"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(inline_sym1__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "inline_sym1__"));}
          } }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym59__;
      double lcm_sym58__;
      double lcm_sym57__;
      double lcm_sym56__;
      int lcm_sym53__;
      int lcm_sym52__;
      int pos__;
      
      pos__ = 1;
      double mean_p;
      
      current_statement__ = 1;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      current_statement__ = 1;
      mean_p = stan::math::lub_free(mean_p, 0, 1);
      current_statement__ = 2;
      validate_non_negative_index("beta", "max_age", max_age);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(max_age);
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        lcm_sym52__ = logical_gte(max_age, 1);
        if (lcm_sym52__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            beta_flat__[(1 - 1)], "assigning variable beta");
          current_statement__ = 2;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
            current_statement__ = 2;
            assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 2;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 2;
      if (lcm_sym52__) {
        current_statement__ = 2;
        assign(beta, cons_list(index_uni(1), nil_index_list()),
          stan::math::lub_free(beta[(1 - 1)], 0, 1),
          "assigning variable beta");
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_free(beta[(sym1__ - 1)], 0, 1),
            "assigning variable beta");}
      } 
      vars__.push_back(mean_p);
      if (lcm_sym52__) {
        vars__.push_back(beta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= max_age; ++sym1__) {
          vars__.push_back(beta[(sym1__ - 1)]);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mean_p");
    names__.push_back("beta");
    names__.push_back("phi");
    names__.push_back("p");
    names__.push_back("chi");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(max_age);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occ_minus_1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occ_minus_1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_p");
    for (size_t sym181__ = 1; sym181__ <= max_age; ++sym181__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym181__));
      }}
    if (emit_transformed_parameters__) {
      for (size_t sym181__ = 1; sym181__ <= n_occ_minus_1; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
      for (size_t sym181__ = 1; sym181__ <= n_occ_minus_1; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
      for (size_t sym181__ = 1; sym181__ <= n_occasions; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_p");
    for (size_t sym181__ = 1; sym181__ <= max_age; ++sym181__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym181__));
      }}
    if (emit_transformed_parameters__) {
      for (size_t sym181__ = 1; sym181__ <= n_occ_minus_1; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
      for (size_t sym181__ = 1; sym181__ <= n_occ_minus_1; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
      for (size_t sym181__ = 1; sym181__ <= n_occasions; ++sym181__) {
        {
          for (size_t sym182__ = 1; sym182__ <= nind; ++sym182__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym182__) + '.' + std::to_string(sym181__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << max_age << "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << max_age << "},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef fails_test_model_namespace::fails_test_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp inlining-fail2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace inlining_fail2_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'inlining-fail2.stan', line 177, column 2 to column 33)",
                                                      " (in 'inlining-fail2.stan', line 178, column 2 to column 31)",
                                                      " (in 'inlining-fail2.stan', line 179, column 2 to column 45)",
                                                      " (in 'inlining-fail2.stan', line 180, column 2 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 181, column 2 to column 30)",
                                                      " (in 'inlining-fail2.stan', line 187, column 2 to column 50)",
                                                      " (in 'inlining-fail2.stan', line 188, column 2 to column 44)",
                                                      " (in 'inlining-fail2.stan', line 189, column 2 to column 46)",
                                                      " (in 'inlining-fail2.stan', line 194, column 6 to column 58)",
                                                      " (in 'inlining-fail2.stan', line 193, column 4 to line 194, column 58)",
                                                      " (in 'inlining-fail2.stan', line 192, column 2 to line 194, column 58)",
                                                      " (in 'inlining-fail2.stan', line 49, column 4 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 50, column 4 to column 30)",
                                                      " (in 'inlining-fail2.stan', line 51, column 4 to column 35)",
                                                      " (in 'inlining-fail2.stan', line 54, column 6 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 56, column 8 to column 37)",
                                                      " (in 'inlining-fail2.stan', line 57, column 8 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 59, column 8 to line 60, column 65)",
                                                      " (in 'inlining-fail2.stan', line 55, column 37 to line 61, column 7)",
                                                      " (in 'inlining-fail2.stan', line 53, column 23 to line 62, column 5)",
                                                      " (in 'inlining-fail2.stan', line 48, column 47 to line 64, column 3)",
                                                      " (in 'inlining-fail2.stan', line 213, column 2 to column 14)",
                                                      " (in 'inlining-fail2.stan', line 214, column 2 to column 11)",
                                                      " (in 'inlining-fail2.stan', line 215, column 2 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 216, column 2 to column 13)",
                                                      " (in 'inlining-fail2.stan', line 217, column 2 to column 21)",
                                                      " (in 'inlining-fail2.stan', line 218, column 2 to column 21)",
                                                      " (in 'inlining-fail2.stan', line 219, column 2 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 223, column 4 to column 14)",
                                                      " (in 'inlining-fail2.stan', line 224, column 4 to column 13)",
                                                      " (in 'inlining-fail2.stan', line 231, column 6 to column 35)",
                                                      " (in 'inlining-fail2.stan', line 228, column 6 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 227, column 29 to line 232, column 5)",
                                                      " (in 'inlining-fail2.stan', line 226, column 4 to column 38)",
                                                      " (in 'inlining-fail2.stan', line 227, column 4 to line 232, column 5)",
                                                      " (in 'inlining-fail2.stan', line 222, column 17 to line 233, column 3)",
                                                      " (in 'inlining-fail2.stan', line 222, column 2 to line 233, column 3)",
                                                      " (in 'inlining-fail2.stan', line 237, column 4 to column 49)",
                                                      " (in 'inlining-fail2.stan', line 148, column 4 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 149, column 4 to column 24)",
                                                      " (in 'inlining-fail2.stan', line 150, column 4 to column 31)",
                                                      " (in 'inlining-fail2.stan', line 154, column 6 to column 64)",
                                                      " (in 'inlining-fail2.stan', line 153, column 6 to column 55)",
                                                      " (in 'inlining-fail2.stan', line 152, column 19 to line 155, column 5)",
                                                      " (in 'inlining-fail2.stan', line 147, column 33 to line 157, column 3)",
                                                      " (in 'inlining-fail2.stan', line 238, column 4 to column 63)",
                                                      " (in 'inlining-fail2.stan', line 239, column 4 to column 16)",
                                                      " (in 'inlining-fail2.stan', line 240, column 4 to column 18)",
                                                      " (in 'inlining-fail2.stan', line 247, column 6 to column 36)",
                                                      " (in 'inlining-fail2.stan', line 17, column 8 to column 17)",
                                                      " (in 'inlining-fail2.stan', line 16, column 6 to line 17, column 17)",
                                                      " (in 'inlining-fail2.stan', line 14, column 31 to line 19, column 3)",
                                                      " (in 'inlining-fail2.stan', line 250, column 8 to column 26)",
                                                      " (in 'inlining-fail2.stan', line 249, column 6 to line 250, column 26)",
                                                      " (in 'inlining-fail2.stan', line 246, column 19 to line 251, column 5)",
                                                      " (in 'inlining-fail2.stan', line 246, column 4 to line 251, column 5)",
                                                      " (in 'inlining-fail2.stan', line 253, column 6 to column 25)",
                                                      " (in 'inlining-fail2.stan', line 254, column 6 to column 31)",
                                                      " (in 'inlining-fail2.stan', line 252, column 29 to line 255, column 5)",
                                                      " (in 'inlining-fail2.stan', line 252, column 4 to line 255, column 5)",
                                                      " (in 'inlining-fail2.stan', line 257, column 6 to column 26)",
                                                      " (in 'inlining-fail2.stan', line 258, column 6 to column 31)",
                                                      " (in 'inlining-fail2.stan', line 256, column 19 to line 259, column 5)",
                                                      " (in 'inlining-fail2.stan', line 256, column 4 to line 259, column 5)",
                                                      " (in 'inlining-fail2.stan', line 260, column 4 to column 25)",
                                                      " (in 'inlining-fail2.stan', line 236, column 2 to line 261, column 3)",
                                                      " (in 'inlining-fail2.stan', line 206, column 2 to column 29)",
                                                      " (in 'inlining-fail2.stan', line 80, column 4 to column 27)",
                                                      " (in 'inlining-fail2.stan', line 81, column 4 to column 33)",
                                                      " (in 'inlining-fail2.stan', line 82, column 4 to column 45)",
                                                      " (in 'inlining-fail2.stan', line 85, column 6 to column 43)",
                                                      " (in 'inlining-fail2.stan', line 119, column 8 to column 33)",
                                                      " (in 'inlining-fail2.stan', line 127, column 10 to line 130, column 49)",
                                                      " (in 'inlining-fail2.stan', line 132, column 8 to column 63)",
                                                      " (in 'inlining-fail2.stan', line 133, column 8 to column 34)",
                                                      " (in 'inlining-fail2.stan', line 118, column 13 to line 134, column 7)",
                                                      " (in 'inlining-fail2.stan', line 92, column 10 to column 30)",
                                                      " (in 'inlining-fail2.stan', line 101, column 12 to line 105, column 56)",
                                                      " (in 'inlining-fail2.stan', line 106, column 10 to line 108, column 61)",
                                                      " (in 'inlining-fail2.stan', line 109, column 10 to column 36)",
                                                      " (in 'inlining-fail2.stan', line 91, column 15 to line 110, column 9)",
                                                      " (in 'inlining-fail2.stan', line 89, column 27 to line 91, column 9)",
                                                      " (in 'inlining-fail2.stan', line 89, column 8 to line 110, column 9)",
                                                      " (in 'inlining-fail2.stan', line 113, column 10 to column 39)",
                                                      " (in 'inlining-fail2.stan', line 114, column 10 to column 39)",
                                                      " (in 'inlining-fail2.stan', line 112, column 42 to line 115, column 9)",
                                                      " (in 'inlining-fail2.stan', line 117, column 8 to column 39)",
                                                      " (in 'inlining-fail2.stan', line 87, column 20 to line 118, column 7)",
                                                      " (in 'inlining-fail2.stan', line 122, column 8 to line 124, column 47)",
                                                      " (in 'inlining-fail2.stan', line 90, column 10 to column 44)",
                                                      " (in 'inlining-fail2.stan', line 84, column 23 to line 135, column 5)",
                                                      " (in 'inlining-fail2.stan', line 161, column 2 to column 17)",
                                                      " (in 'inlining-fail2.stan', line 162, column 2 to column 27)",
                                                      " (in 'inlining-fail2.stan', line 163, column 2 to column 41)",
                                                      " (in 'inlining-fail2.stan', line 167, column 2 to column 42)",
                                                      " (in 'inlining-fail2.stan', line 168, column 2 to column 41)",
                                                      " (in 'inlining-fail2.stan', line 171, column 4 to column 35)",
                                                      " (in 'inlining-fail2.stan', line 170, column 2 to line 171, column 35)",
                                                      " (in 'inlining-fail2.stan', line 30, column 6 to column 32)",
                                                      " (in 'inlining-fail2.stan', line 33, column 8 to column 17)",
                                                      " (in 'inlining-fail2.stan', line 32, column 6 to line 33, column 17)",
                                                      " (in 'inlining-fail2.stan', line 29, column 37 to line 34, column 5)",
                                                      " (in 'inlining-fail2.stan', line 28, column 30 to line 36, column 3)",
                                                      " (in 'inlining-fail2.stan', line 173, column 4 to column 33)",
                                                      " (in 'inlining-fail2.stan', line 172, column 2 to line 173, column 33)",
                                                      " (in 'inlining-fail2.stan', line 18, column 4 to column 13)",
                                                      " (in 'inlining-fail2.stan', line 35, column 4 to column 13)",
                                                      " (in 'inlining-fail2.stan', line 55, column 6 to line 61, column 7)",
                                                      " (in 'inlining-fail2.stan', line 53, column 4 to line 62, column 5)",
                                                      " (in 'inlining-fail2.stan', line 63, column 4 to column 15)",
                                                      " (in 'inlining-fail2.stan', line 126, column 8 to line 130, column 49)",
                                                      " (in 'inlining-fail2.stan', line 100, column 10 to line 105, column 56)",
                                                      " (in 'inlining-fail2.stan', line 84, column 4 to line 135, column 5)",
                                                      " (in 'inlining-fail2.stan', line 79, column 34 to line 136, column 3)",
                                                      " (in 'inlining-fail2.stan', line 152, column 4 to line 155, column 5)",
                                                      " (in 'inlining-fail2.stan', line 156, column 4 to column 26)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym59__;
    int lcm_sym58__;
    int lcm_sym57__;
    int lcm_sym56__;
    {
      lcm_sym57__ = size(y_i);
      if (logical_gte(lcm_sym57__, 1)) {
        current_statement__ = 51;
        if (y_i[(1 - 1)]) {
          current_statement__ = 50;
          return 1;
        } 
        for (size_t k = 2; k <= lcm_sym57__; ++k) {
          current_statement__ = 51;
          if (y_i[(k - 1)]) {
            current_statement__ = 50;
            return k;
          } }
      } 
      current_statement__ = 106;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym65__;
    int lcm_sym64__;
    int lcm_sym63__;
    int lcm_sym62__;
    int lcm_sym61__;
    int lcm_sym60__;
    {
      lcm_sym63__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym63__, 0)) {
        int k;
        
        lcm_sym62__ = (size(y_i) - 0);
        current_statement__ = 101;
        if (y_i[(lcm_sym62__ - 1)]) {
          current_statement__ = 100;
          return lcm_sym62__;
        } 
        for (size_t k_rev = 1; k_rev <= lcm_sym63__; ++k_rev) {
          int k;
          
          lcm_sym61__ = (size(y_i) - k_rev);
          current_statement__ = 101;
          if (y_i[(lcm_sym61__ - 1)]) {
            current_statement__ = 100;
            return lcm_sym61__;
          } }
      } 
      current_statement__ = 107;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__,
T1__>::type, -1, -1>
prob_uncaptured(const Eigen::Matrix<T0__, -1, -1>& p,
                const Eigen::Matrix<T1__, -1, -1>& phi,
                std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__,
          T1__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    double lcm_sym79__;
    int lcm_sym78__;
    double lcm_sym77__;
    double lcm_sym76__;
    double lcm_sym75__;
    double lcm_sym74__;
    int lcm_sym73__;
    int lcm_sym72__;
    int lcm_sym71__;
    int lcm_sym70__;
    int lcm_sym69__;
    int lcm_sym68__;
    int lcm_sym67__;
    int lcm_sym66__;
    {
      int n_ind;
      
      lcm_sym78__ = rows(p);
      int n_occasions;
      
      lcm_sym73__ = cols(p);
      n_occasions = lcm_sym73__;
      current_statement__ = 14;
      validate_non_negative_index("chi", "n_ind", lcm_sym78__);
      current_statement__ = 14;
      validate_non_negative_index("chi", "n_occasions", lcm_sym73__);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym78__, lcm_sym73__);
      
      lcm_sym68__ = logical_gte(lcm_sym78__, 1);
      if (lcm_sym68__) {
        lcm_sym67__ = logical_gte(lcm_sym73__, 1);
        if (lcm_sym67__) {
          lcm_sym79__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym79__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym73__; ++sym2__) {
            current_statement__ = 14;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym79__,
              "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym78__; ++sym1__) {
          current_statement__ = 14;
          if (lcm_sym67__) {
            lcm_sym79__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym79__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym73__; ++sym2__) {
              current_statement__ = 14;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym79__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 109;
      if (lcm_sym68__) {
        current_statement__ = 15;
        assign(chi,
          cons_list(index_uni(1),
            cons_list(index_uni(lcm_sym73__), nil_index_list())), 1.0,
          "assigning variable chi");
        lcm_sym70__ = (lcm_sym73__ - 1);
        lcm_sym66__ = logical_gte(lcm_sym70__, 1);
        if (lcm_sym66__) {
          int t_curr;
          
          int t_next;
          
          lcm_sym72__ = (lcm_sym70__ + 1);
          current_statement__ = 18;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym70__), nil_index_list())),
            stan::math::fma(
              (rvalue(phi,
                 cons_list(index_uni(1),
                   cons_list(index_uni(lcm_sym70__), nil_index_list())),
                 "phi") *
                (1 -
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym72__), nil_index_list())),
                    "p"))),
              rvalue(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(lcm_sym72__), nil_index_list())),
                "chi"),
              (1 -
                rvalue(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym70__), nil_index_list())),
                  "phi"))), "assigning variable chi");
          for (size_t t = 2; t <= lcm_sym70__; ++t) {
            int t_curr;
            
            lcm_sym69__ = (lcm_sym73__ - t);
            int t_next;
            
            lcm_sym71__ = (lcm_sym69__ + 1);
            current_statement__ = 18;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(lcm_sym69__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(1),
                     cons_list(index_uni(lcm_sym69__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni(lcm_sym71__), nil_index_list())),
                      "p"))),
                rvalue(chi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym71__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym69__), nil_index_list())),
                    "phi"))), "assigning variable chi");}
        } 
        for (size_t i = 2; i <= lcm_sym78__; ++i) {
          current_statement__ = 15;
          assign(chi,
            cons_list(index_uni(i),
              cons_list(index_uni(lcm_sym73__), nil_index_list())), 1.0,
            "assigning variable chi");
          current_statement__ = 108;
          if (lcm_sym66__) {
            int t_curr;
            
            int t_next;
            
            lcm_sym72__ = (lcm_sym70__ + 1);
            current_statement__ = 18;
            assign(chi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym70__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(i),
                     cons_list(index_uni(lcm_sym70__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym72__), nil_index_list())),
                      "p"))),
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(lcm_sym72__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym70__), nil_index_list())),
                    "phi"))), "assigning variable chi");
            for (size_t t = 2; t <= lcm_sym70__; ++t) {
              int t_curr;
              
              lcm_sym69__ = (lcm_sym73__ - t);
              int t_next;
              
              lcm_sym71__ = (lcm_sym69__ + 1);
              current_statement__ = 18;
              assign(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(lcm_sym69__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_uni(lcm_sym69__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni(lcm_sym71__), nil_index_list())),
                        "p"))),
                  rvalue(chi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym71__), nil_index_list())),
                    "chi"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym69__), nil_index_list())),
                      "phi"))), "assigning variable chi");}
          } }
      } 
      current_statement__ = 110;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__,
T1__>::type, -1, -1>
operator()(const Eigen::Matrix<T0__, -1, -1>& p,
           const Eigen::Matrix<T1__, -1, -1>& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(p, phi, pstream__);
}
};

template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T_lp__, typename T_lp_accum__>
void
jolly_seber_lp(const std::vector<std::vector<int>>& y,
               const std::vector<int>& first, const std::vector<int>& last,
               const Eigen::Matrix<T3__, -1, -1>& p,
               const Eigen::Matrix<T4__, -1, -1>& phi,
               const Eigen::Matrix<T5__, -1, 1>& gamma,
               const Eigen::Matrix<T6__, -1, -1>& chi, T_lp__& lp__,
               T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T3__,
          T4__,
          T5__,
          T6__>::type;
  
  try {
    int lcm_sym133__;
    int lcm_sym132__;
    int lcm_sym131__;
    int lcm_sym130__;
    int lcm_sym129__;
    int lcm_sym128__;
    double lcm_sym127__;
    double lcm_sym126__;
    double lcm_sym125__;
    double lcm_sym124__;
    double lcm_sym123__;
    double lcm_sym122__;
    double lcm_sym121__;
    double lcm_sym120__;
    double lcm_sym119__;
    double lcm_sym118__;
    double lcm_sym117__;
    double lcm_sym116__;
    double lcm_sym115__;
    double lcm_sym114__;
    double lcm_sym113__;
    int lcm_sym112__;
    int lcm_sym111__;
    int lcm_sym110__;
    double lcm_sym109__;
    double lcm_sym108__;
    double lcm_sym107__;
    double lcm_sym106__;
    double lcm_sym105__;
    double lcm_sym104__;
    double lcm_sym103__;
    double lcm_sym102__;
    double lcm_sym101__;
    double lcm_sym100__;
    double lcm_sym99__;
    double lcm_sym98__;
    double lcm_sym97__;
    double lcm_sym96__;
    int lcm_sym95__;
    int lcm_sym94__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym93__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym92__;
    Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym91__;
    int lcm_sym90__;
    int lcm_sym89__;
    int lcm_sym88__;
    int lcm_sym87__;
    int lcm_sym86__;
    int lcm_sym85__;
    int lcm_sym84__;
    int lcm_sym83__;
    int lcm_sym82__;
    int lcm_sym81__;
    int lcm_sym80__;
    {
      int n_ind;
      
      lcm_sym132__ = dims(y)[(1 - 1)];
      int n_occasions;
      
      lcm_sym133__ = dims(y)[(2 - 1)];
      n_occasions = lcm_sym133__;
      current_statement__ = 70;
      validate_non_negative_index("qgamma", "n_occasions", lcm_sym133__);
      Eigen::Matrix<double, -1, 1> qgamma;
      qgamma = Eigen::Matrix<double, -1, 1>(lcm_sym133__);
      
      assign(lcm_sym91__, nil_index_list(), subtract(1.0, gamma),
        "assigning variable lcm_sym91__");
      current_statement__ = 113;
      if (logical_gte(lcm_sym132__, 1)) {
        current_statement__ = 71;
        validate_non_negative_index("qp", "n_occasions", lcm_sym133__);
        Eigen::Matrix<double, -1, 1> qp;
        qp = Eigen::Matrix<double, -1, 1>(lcm_sym133__);
        
        assign(lcm_sym93__, nil_index_list(),
          subtract(1.0,
            transpose(
              rvalue(p, cons_list(index_uni(1), nil_index_list()), "p"))),
          "assigning variable lcm_sym93__");
        lcm_sym129__ = first[(1 - 1)];
        if (lcm_sym129__) {
          current_statement__ = 83;
          if (logical_eq(lcm_sym129__, 1)) {
            current_statement__ = 90;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                (gamma[(1 - 1)] *
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(1), nil_index_list())), "p"))));
          } else {
            current_statement__ = 77;
            validate_non_negative_index("lp", "first[(i - 1)]", lcm_sym129__);
            Eigen::Matrix<local_scalar_t__, -1, 1> lp;
            lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym129__);
            
            current_statement__ = 77;
            if (logical_gte(lcm_sym129__, 1)) {
              lcm_sym127__ = std::numeric_limits<double>::quiet_NaN();
              assign(lp, cons_list(index_uni(1), nil_index_list()),
                lcm_sym127__, "assigning variable lp");
              for (size_t sym1__ = 2; sym1__ <= lcm_sym129__; ++sym1__) {
                current_statement__ = 77;
                assign(lp, cons_list(index_uni(sym1__), nil_index_list()),
                  lcm_sym127__, "assigning variable lp");}
            } 
            lcm_sym95__ = (lcm_sym129__ - 1);
            assign(lp, cons_list(index_uni(1), nil_index_list()),
              (((bernoulli_lpmf<false>(1, gamma[(1 - 1)]) +
                  bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(lcm_sym93__,
                        cons_list(index_min_max(1, lcm_sym95__),
                          nil_index_list()), "lcm_sym93__")))) +
                 bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(phi,
                       cons_list(index_uni(1),
                         cons_list(index_min_max(1, lcm_sym95__),
                           nil_index_list())), "phi")))) +
                bernoulli_lpmf<false>(1,
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym129__), nil_index_list())),
                    "p"))), "assigning variable lp");
            current_statement__ = 112;
            if (logical_gte(lcm_sym95__, 2)) {
              current_statement__ = 78;
              assign(lp, cons_list(index_uni(2), nil_index_list()),
                ((((bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym91__,
                          cons_list(index_min_max(1, 1), nil_index_list()),
                          "lcm_sym91__"))) +
                     bernoulli_lpmf<false>(1, gamma[(2 - 1)])) +
                    bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym93__,
                          cons_list(index_min_max(2, lcm_sym95__),
                            nil_index_list()), "lcm_sym93__")))) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(phi,
                         cons_list(index_uni(1),
                           cons_list(index_min_max(2, lcm_sym95__),
                             nil_index_list())), "phi")))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni(lcm_sym129__), nil_index_list())),
                      "p"))), "assigning variable lp");
              for (size_t t = 3; t <= lcm_sym95__; ++t) {
                current_statement__ = 78;
                assign(lp, cons_list(index_uni(t), nil_index_list()),
                  ((((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym91__,
                            cons_list(index_min_max(1, (t - 1)),
                              nil_index_list()), "lcm_sym91__"))) +
                       bernoulli_lpmf<false>(1, gamma[(t - 1)])) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym93__,
                            cons_list(index_min_max(t, lcm_sym95__),
                              nil_index_list()), "lcm_sym93__")))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi,
                           cons_list(index_uni(1),
                             cons_list(index_min_max(t, lcm_sym95__),
                               nil_index_list())), "phi")))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p,
                        cons_list(index_uni(1),
                          cons_list(index_uni(lcm_sym129__),
                            nil_index_list())), "p"))),
                  "assigning variable lp");}
            } 
            current_statement__ = 79;
            assign(lp, cons_list(index_uni(lcm_sym129__), nil_index_list()),
              ((bernoulli_lpmf<false>(1,
                  prod(
                    rvalue(lcm_sym91__,
                      cons_list(index_min_max(1, lcm_sym95__),
                        nil_index_list()), "lcm_sym91__"))) +
                 bernoulli_lpmf<false>(1, gamma[(lcm_sym129__ - 1)])) +
                bernoulli_lpmf<false>(1,
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym129__), nil_index_list())),
                    "p"))), "assigning variable lp");
            current_statement__ = 80;
            lp_accum__.add(log_sum_exp(lp));
          }
          lcm_sym131__ = last[(1 - 1)];
          if (logical_gte(lcm_sym131__, (lcm_sym129__ + 1))) {
            current_statement__ = 84;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                rvalue(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(((lcm_sym129__ + 1) - 1)),
                      nil_index_list())), "phi")));
            lcm_sym111__ = ((lcm_sym129__ + 1) + 1);
            lp_accum__.add(
              bernoulli_log<propto__>(y[(1 - 1)][((lcm_sym129__ + 1) - 1)],
                rvalue(p,
                  cons_list(index_uni(1),
                    cons_list(index_uni((lcm_sym129__ + 1)),
                      nil_index_list())), "p")));
            for (size_t t = lcm_sym111__; t <= lcm_sym131__; ++t) {
              current_statement__ = 84;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni((t - 1)), nil_index_list())),
                    "phi")));
              current_statement__ = 85;
              lp_accum__.add(
                bernoulli_log<propto__>(y[(1 - 1)][(t - 1)],
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni(t), nil_index_list())), "p")));}
          } 
          current_statement__ = 87;
          lp_accum__.add(
            bernoulli_log<propto__>(1,
              rvalue(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(lcm_sym131__), nil_index_list())),
                "chi")));
        } else {
          lcm_sym112__ = (lcm_sym133__ + 1);
          validate_non_negative_index("lp", "(n_occasions + 1)", lcm_sym112__);
          Eigen::Matrix<local_scalar_t__, -1, 1> lp;
          lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym112__);
          
          current_statement__ = 72;
          if (logical_gte(lcm_sym112__, 1)) {
            lcm_sym127__ = std::numeric_limits<double>::quiet_NaN();
            assign(lp, cons_list(index_uni(1), nil_index_list()),
              lcm_sym127__, "assigning variable lp");
            for (size_t sym1__ = 2; sym1__ <= lcm_sym112__; ++sym1__) {
              current_statement__ = 72;
              assign(lp, cons_list(index_uni(sym1__), nil_index_list()),
                lcm_sym127__, "assigning variable lp");}
          } 
          current_statement__ = 89;
          assign(lp, cons_list(index_uni(1), nil_index_list()),
            ((bernoulli_lpmf<false>(1, gamma[(1 - 1)]) +
               bernoulli_lpmf<false>(0,
                 rvalue(p,
                   cons_list(index_uni(1),
                     cons_list(index_uni(1), nil_index_list())), "p"))) +
              bernoulli_lpmf<false>(1,
                rvalue(chi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(1), nil_index_list())), "chi"))),
            "assigning variable lp");
          current_statement__ = 111;
          if (logical_gte(lcm_sym133__, 2)) {
            current_statement__ = 73;
            assign(lp, cons_list(index_uni(2), nil_index_list()),
              (((bernoulli_lpmf<false>(1,
                   prod(
                     rvalue(lcm_sym91__,
                       cons_list(index_min_max(1, 1), nil_index_list()),
                       "lcm_sym91__"))) +
                  bernoulli_lpmf<false>(1, gamma[(2 - 1)])) +
                 bernoulli_lpmf<false>(0,
                   rvalue(p,
                     cons_list(index_uni(1),
                       cons_list(index_uni(2), nil_index_list())), "p"))) +
                bernoulli_lpmf<false>(1,
                  rvalue(chi,
                    cons_list(index_uni(1),
                      cons_list(index_uni(2), nil_index_list())), "chi"))),
              "assigning variable lp");
            for (size_t t = 3; t <= lcm_sym133__; ++t) {
              current_statement__ = 73;
              assign(lp, cons_list(index_uni(t), nil_index_list()),
                (((bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(lcm_sym91__,
                         cons_list(index_min_max(1, (t - 1)),
                           nil_index_list()), "lcm_sym91__"))) +
                    bernoulli_lpmf<false>(1, gamma[(t - 1)])) +
                   bernoulli_lpmf<false>(0,
                     rvalue(p,
                       cons_list(index_uni(1),
                         cons_list(index_uni(t), nil_index_list())), "p"))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(chi,
                      cons_list(index_uni(1),
                        cons_list(index_uni(t), nil_index_list())), "chi"))),
                "assigning variable lp");}
          } 
          current_statement__ = 74;
          assign(lp, cons_list(index_uni(lcm_sym112__), nil_index_list()),
            bernoulli_lpmf<false>(1, prod(lcm_sym91__)),
            "assigning variable lp");
          current_statement__ = 75;
          lp_accum__.add(log_sum_exp(lp));
        }
        for (size_t i = 2; i <= lcm_sym132__; ++i) {
          current_statement__ = 71;
          validate_non_negative_index("qp", "n_occasions", lcm_sym133__);
          Eigen::Matrix<double, -1, 1> qp;
          qp = Eigen::Matrix<double, -1, 1>(lcm_sym133__);
          
          assign(lcm_sym92__, nil_index_list(),
            subtract(1.0,
              transpose(
                rvalue(p, cons_list(index_uni(i), nil_index_list()), "p"))),
            "assigning variable lcm_sym92__");
          lcm_sym128__ = first[(i - 1)];
          if (lcm_sym128__) {
            current_statement__ = 83;
            if (logical_eq(lcm_sym128__, 1)) {
              current_statement__ = 90;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  (gamma[(1 - 1)] *
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(1), nil_index_list())), "p"))));
            } else {
              current_statement__ = 77;
              validate_non_negative_index("lp", "first[(i - 1)]",
                                          lcm_sym128__);
              Eigen::Matrix<local_scalar_t__, -1, 1> lp;
              lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym128__);
              
              current_statement__ = 77;
              if (logical_gte(lcm_sym128__, 1)) {
                lcm_sym127__ = std::numeric_limits<double>::quiet_NaN();
                assign(lp, cons_list(index_uni(1), nil_index_list()),
                  lcm_sym127__, "assigning variable lp");
                for (size_t sym1__ = 2; sym1__ <= lcm_sym128__; ++sym1__) {
                  current_statement__ = 77;
                  assign(lp, cons_list(index_uni(sym1__), nil_index_list()),
                    lcm_sym127__, "assigning variable lp");}
              } 
              lcm_sym94__ = (lcm_sym128__ - 1);
              assign(lp, cons_list(index_uni(1), nil_index_list()),
                (((bernoulli_lpmf<false>(1, gamma[(1 - 1)]) +
                    bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym92__,
                          cons_list(index_min_max(1, lcm_sym94__),
                            nil_index_list()), "lcm_sym92__")))) +
                   bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(phi,
                         cons_list(index_uni(i),
                           cons_list(index_min_max(1, lcm_sym94__),
                             nil_index_list())), "phi")))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym128__), nil_index_list())),
                      "p"))), "assigning variable lp");
              current_statement__ = 112;
              if (logical_gte(lcm_sym94__, 2)) {
                current_statement__ = 78;
                assign(lp, cons_list(index_uni(2), nil_index_list()),
                  ((((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym91__,
                            cons_list(index_min_max(1, 1), nil_index_list()),
                            "lcm_sym91__"))) +
                       bernoulli_lpmf<false>(1, gamma[(2 - 1)])) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym92__,
                            cons_list(index_min_max(2, lcm_sym94__),
                              nil_index_list()), "lcm_sym92__")))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi,
                           cons_list(index_uni(i),
                             cons_list(index_min_max(2, lcm_sym94__),
                               nil_index_list())), "phi")))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni(lcm_sym128__),
                            nil_index_list())), "p"))),
                  "assigning variable lp");
                for (size_t t = 3; t <= lcm_sym94__; ++t) {
                  current_statement__ = 78;
                  assign(lp, cons_list(index_uni(t), nil_index_list()),
                    ((((bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym91__,
                              cons_list(index_min_max(1, (t - 1)),
                                nil_index_list()), "lcm_sym91__"))) +
                         bernoulli_lpmf<false>(1, gamma[(t - 1)])) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym92__,
                              cons_list(index_min_max(t, lcm_sym94__),
                                nil_index_list()), "lcm_sym92__")))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(phi,
                             cons_list(index_uni(i),
                               cons_list(index_min_max(t, lcm_sym94__),
                                 nil_index_list())), "phi")))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(p,
                          cons_list(index_uni(i),
                            cons_list(index_uni(lcm_sym128__),
                              nil_index_list())), "p"))),
                    "assigning variable lp");}
              } 
              current_statement__ = 79;
              assign(lp,
                cons_list(index_uni(lcm_sym128__), nil_index_list()),
                ((bernoulli_lpmf<false>(1,
                    prod(
                      rvalue(lcm_sym91__,
                        cons_list(index_min_max(1, lcm_sym94__),
                          nil_index_list()), "lcm_sym91__"))) +
                   bernoulli_lpmf<false>(1, gamma[(lcm_sym128__ - 1)])) +
                  bernoulli_lpmf<false>(1,
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym128__), nil_index_list())),
                      "p"))), "assigning variable lp");
              current_statement__ = 80;
              lp_accum__.add(log_sum_exp(lp));
            }
            lcm_sym130__ = last[(i - 1)];
            if (logical_gte(lcm_sym130__, (lcm_sym128__ + 1))) {
              current_statement__ = 84;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(((lcm_sym128__ + 1) - 1)),
                        nil_index_list())), "phi")));
              lcm_sym110__ = ((lcm_sym128__ + 1) + 1);
              lp_accum__.add(
                bernoulli_log<propto__>(y[(i - 1)][((lcm_sym128__ + 1) - 1)],
                  rvalue(p,
                    cons_list(index_uni(i),
                      cons_list(index_uni((lcm_sym128__ + 1)),
                        nil_index_list())), "p")));
              for (size_t t = lcm_sym110__; t <= lcm_sym130__; ++t) {
                current_statement__ = 84;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "phi")));
                current_statement__ = 85;
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(i - 1)][(t - 1)],
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni(t), nil_index_list())), "p")));}
            } 
            current_statement__ = 87;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(lcm_sym130__), nil_index_list())),
                  "chi")));
          } else {
            lcm_sym112__ = (lcm_sym133__ + 1);
            validate_non_negative_index("lp", "(n_occasions + 1)",
                                        lcm_sym112__);
            Eigen::Matrix<local_scalar_t__, -1, 1> lp;
            lp = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym112__);
            
            current_statement__ = 72;
            if (logical_gte(lcm_sym112__, 1)) {
              lcm_sym127__ = std::numeric_limits<double>::quiet_NaN();
              assign(lp, cons_list(index_uni(1), nil_index_list()),
                lcm_sym127__, "assigning variable lp");
              for (size_t sym1__ = 2; sym1__ <= lcm_sym112__; ++sym1__) {
                current_statement__ = 72;
                assign(lp, cons_list(index_uni(sym1__), nil_index_list()),
                  lcm_sym127__, "assigning variable lp");}
            } 
            current_statement__ = 89;
            assign(lp, cons_list(index_uni(1), nil_index_list()),
              ((bernoulli_lpmf<false>(1, gamma[(1 - 1)]) +
                 bernoulli_lpmf<false>(0,
                   rvalue(p,
                     cons_list(index_uni(i),
                       cons_list(index_uni(1), nil_index_list())), "p"))) +
                bernoulli_lpmf<false>(1,
                  rvalue(chi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(1), nil_index_list())), "chi"))),
              "assigning variable lp");
            current_statement__ = 111;
            if (logical_gte(lcm_sym133__, 2)) {
              current_statement__ = 73;
              assign(lp, cons_list(index_uni(2), nil_index_list()),
                (((bernoulli_lpmf<false>(1,
                     prod(
                       rvalue(lcm_sym91__,
                         cons_list(index_min_max(1, 1), nil_index_list()),
                         "lcm_sym91__"))) +
                    bernoulli_lpmf<false>(1, gamma[(2 - 1)])) +
                   bernoulli_lpmf<false>(0,
                     rvalue(p,
                       cons_list(index_uni(i),
                         cons_list(index_uni(2), nil_index_list())), "p"))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(chi,
                      cons_list(index_uni(i),
                        cons_list(index_uni(2), nil_index_list())), "chi"))),
                "assigning variable lp");
              for (size_t t = 3; t <= lcm_sym133__; ++t) {
                current_statement__ = 73;
                assign(lp, cons_list(index_uni(t), nil_index_list()),
                  (((bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym91__,
                           cons_list(index_min_max(1, (t - 1)),
                             nil_index_list()), "lcm_sym91__"))) +
                      bernoulli_lpmf<false>(1, gamma[(t - 1)])) +
                     bernoulli_lpmf<false>(0,
                       rvalue(p,
                         cons_list(index_uni(i),
                           cons_list(index_uni(t), nil_index_list())), "p")))
                    +
                    bernoulli_lpmf<false>(1,
                      rvalue(chi,
                        cons_list(index_uni(i),
                          cons_list(index_uni(t), nil_index_list())), "chi"))),
                  "assigning variable lp");}
            } 
            current_statement__ = 74;
            assign(lp, cons_list(index_uni(lcm_sym112__), nil_index_list()),
              bernoulli_lpmf<false>(1, prod(lcm_sym91__)),
              "assigning variable lp");
            current_statement__ = 75;
            lp_accum__.add(log_sum_exp(lp));
          }}
      } 
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct jolly_seber_lp_functor__ {
template <bool propto__, typename T3__, typename T4__, typename T5__,
typename T6__, typename T_lp__, typename T_lp_accum__>
void
operator()(const std::vector<std::vector<int>>& y,
           const std::vector<int>& first, const std::vector<int>& last,
           const Eigen::Matrix<T3__, -1, -1>& p,
           const Eigen::Matrix<T4__, -1, -1>& phi,
           const Eigen::Matrix<T5__, -1, 1>& gamma,
           const Eigen::Matrix<T6__, -1, -1>& chi, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return jolly_seber_lp(y, first, last, p, phi, gamma, chi, lp__, lp_accum__,
         pstream__);
}
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, -1, 1>
seq_cprob(const Eigen::Matrix<T0__, -1, 1>& gamma, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    double lcm_sym141__;
    int lcm_sym140__;
    Eigen::Matrix<double, -1, 1> lcm_sym139__;
    double lcm_sym138__;
    double lcm_sym137__;
    double lcm_sym136__;
    double lcm_sym135__;
    int lcm_sym134__;
    {
      int N;
      
      lcm_sym140__ = rows(gamma);
      N = lcm_sym140__;
      current_statement__ = 40;
      validate_non_negative_index("log_cprob", "N", lcm_sym140__);
      Eigen::Matrix<local_scalar_t__, -1, 1> log_cprob;
      log_cprob = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym140__);
      
      lcm_sym134__ = logical_gte(lcm_sym140__, 1);
      if (lcm_sym134__) {
        lcm_sym141__ = std::numeric_limits<double>::quiet_NaN();
        assign(log_cprob, cons_list(index_uni(1), nil_index_list()),
          lcm_sym141__, "assigning variable log_cprob");
        for (size_t sym1__ = 2; sym1__ <= lcm_sym140__; ++sym1__) {
          current_statement__ = 40;
          assign(log_cprob, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym141__, "assigning variable log_cprob");}
      } 
      local_scalar_t__ log_residual_prob;
      
      current_statement__ = 115;
      if (lcm_sym134__) {
        current_statement__ = 43;
        assign(log_cprob, cons_list(index_uni(1), nil_index_list()),
          (stan::math::log(gamma[(1 - 1)]) + 0),
          "assigning variable log_cprob");
        current_statement__ = 42;
        log_residual_prob = (0 + log1m(gamma[(1 - 1)]));
        for (size_t n = 2; n <= lcm_sym140__; ++n) {
          current_statement__ = 43;
          assign(log_cprob, cons_list(index_uni(n), nil_index_list()),
            (stan::math::log(gamma[(n - 1)]) + log_residual_prob),
            "assigning variable log_cprob");
          current_statement__ = 42;
          log_residual_prob = (log_residual_prob + log1m(gamma[(n - 1)]));}
      } 
      current_statement__ = 116;
      return stan::math::exp(log_cprob);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct seq_cprob_functor__ {
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, -1, 1>
operator()(const Eigen::Matrix<T0__, -1, 1>& gamma, std::ostream* pstream__)  const 
{
return seq_cprob(gamma, pstream__);
}
};

class inlining_fail2_model : public model_base_crtp<inlining_fail2_model> {

 private:
  int lcm_sym343__;
  int lcm_sym342__;
  int lcm_sym341__;
  int lcm_sym340__;
  int lcm_sym339__;
  int lcm_sym338__;
  int lcm_sym337__;
  int lcm_sym336__;
  int lcm_sym335__;
  int lcm_sym334__;
  int lcm_sym333__;
  int lcm_sym332__;
  int lcm_sym331__;
  int lcm_sym330__;
  int lcm_sym329__;
  int lcm_sym328__;
  int lcm_sym327__;
  int lcm_sym326__;
  int lcm_sym325__;
  int lcm_sym324__;
  int lcm_sym323__;
  int lcm_sym322__;
  int lcm_sym321__;
  int pos__;
  int M;
  int n_occasions;
  std::vector<std::vector<int>> y;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~inlining_fail2_model() { }
  
  std::string model_name() const { return "inlining_fail2_model"; }
  
  inlining_fail2_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "inlining_fail2_model_namespace::inlining_fail2_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","M","int",
          context__.to_vec());
      
      current_statement__ = 92;
      M = context__.vals_i("M")[(1 - 1)];
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      
      current_statement__ = 93;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 94;
      validate_non_negative_index("y", "M", M);
      current_statement__ = 94;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(M, n_occasions));
      y = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, 0));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 94;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 94;
        pos__ = 1;
        lcm_sym322__ = logical_gte(n_occasions, 1);
        if (lcm_sym322__) {
          {
            lcm_sym321__ = logical_gte(M, 1);
            if (lcm_sym321__) {
              current_statement__ = 94;
              assign(y,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())),
                y_flat__[(1 - 1)], "assigning variable y");
              current_statement__ = 94;
              pos__ = 2;
              for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
                current_statement__ = 94;
                assign(y,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(1), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 94;
                pos__ = (pos__ + 1);}
            } 
            for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 94;
              if (lcm_sym321__) {
                current_statement__ = 94;
                assign(y,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 94;
                pos__ = (pos__ + 1);
                for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
                  current_statement__ = 94;
                  assign(y,
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list())),
                    y_flat__[(pos__ - 1)], "assigning variable y");
                  current_statement__ = 94;
                  pos__ = (pos__ + 1);}
              } }
          }
        } else {
          lcm_sym321__ = logical_gte(M, 1);
        }
      }
      current_statement__ = 95;
      validate_non_negative_index("first", "M", M);
      first = std::vector<int>(M, 0);
      
      current_statement__ = 96;
      validate_non_negative_index("last", "M", M);
      last = std::vector<int>(M, 0);
      
      current_statement__ = 98;
      if (lcm_sym321__) {
        int inline_sym47__;
        int inline_sym49__;
        
        inline_sym49__ = 0;
        for (size_t inline_sym50__ = 1; inline_sym50__ <= 1; ++inline_sym50__) {
          lcm_sym329__ = size(y[(1 - 1)]);
          for (size_t inline_sym48__ = 1; inline_sym48__ <= lcm_sym329__;
               ++inline_sym48__) {
            current_statement__ = 51;
            if (y[(1 - 1)][(inline_sym48__ - 1)]) {
              inline_sym49__ = 1;
              inline_sym47__ = inline_sym48__;
              break;
            } }
          if (inline_sym49__) {
            break;
          } 
          inline_sym49__ = 1;
          inline_sym47__ = 0;
          break;}
        assign(first, cons_list(index_uni(1), nil_index_list()),
          inline_sym47__, "assigning variable first");
        for (size_t i = 2; i <= M; ++i) {
          int inline_sym47__;
          int inline_sym49__;
          
          inline_sym49__ = 0;
          for (size_t inline_sym50__ = 1; inline_sym50__ <= 1;
               ++inline_sym50__) {
            lcm_sym328__ = size(y[(i - 1)]);
            for (size_t inline_sym48__ = 1; inline_sym48__ <= lcm_sym328__;
                 ++inline_sym48__) {
              current_statement__ = 51;
              if (y[(i - 1)][(inline_sym48__ - 1)]) {
                inline_sym49__ = 1;
                inline_sym47__ = inline_sym48__;
                break;
              } }
            if (inline_sym49__) {
              break;
            } 
            inline_sym49__ = 1;
            inline_sym47__ = 0;
            break;}
          assign(first, cons_list(index_uni(i), nil_index_list()),
            inline_sym47__, "assigning variable first");}
      } 
      current_statement__ = 105;
      if (lcm_sym321__) {
        int inline_sym51__;
        int inline_sym54__;
        
        inline_sym54__ = 0;
        for (size_t inline_sym55__ = 1; inline_sym55__ <= 1; ++inline_sym55__) {
          lcm_sym329__ = size(y[(1 - 1)]);
          lcm_sym326__ = (lcm_sym329__ - 1);
          for (size_t inline_sym53__ = 0; inline_sym53__ <= lcm_sym326__;
               ++inline_sym53__) {
            int inline_sym52__;
            
            lcm_sym325__ = (lcm_sym329__ - inline_sym53__);
            inline_sym52__ = lcm_sym325__;
            current_statement__ = 101;
            if (y[(1 - 1)][(lcm_sym325__ - 1)]) {
              inline_sym54__ = 1;
              inline_sym51__ = lcm_sym325__;
              break;
            } }
          if (inline_sym54__) {
            break;
          } 
          inline_sym54__ = 1;
          inline_sym51__ = 0;
          break;}
        assign(last, cons_list(index_uni(1), nil_index_list()),
          inline_sym51__, "assigning variable last");
        for (size_t i = 2; i <= M; ++i) {
          int inline_sym51__;
          int inline_sym54__;
          
          inline_sym54__ = 0;
          for (size_t inline_sym55__ = 1; inline_sym55__ <= 1;
               ++inline_sym55__) {
            lcm_sym328__ = size(y[(i - 1)]);
            lcm_sym324__ = (lcm_sym328__ - 1);
            for (size_t inline_sym53__ = 0; inline_sym53__ <= lcm_sym324__;
                 ++inline_sym53__) {
              int inline_sym52__;
              
              lcm_sym323__ = (lcm_sym328__ - inline_sym53__);
              inline_sym52__ = lcm_sym323__;
              current_statement__ = 101;
              if (y[(i - 1)][(lcm_sym323__ - 1)]) {
                inline_sym54__ = 1;
                inline_sym51__ = lcm_sym323__;
                break;
              } }
            if (inline_sym54__) {
              break;
            } 
            inline_sym54__ = 1;
            inline_sym51__ = 0;
            break;}
          assign(last, cons_list(index_uni(i), nil_index_list()),
            inline_sym51__, "assigning variable last");}
      } 
      current_statement__ = 92;
      current_statement__ = 92;
      check_greater_or_equal(function__, "M", M, 0);
      current_statement__ = 93;
      current_statement__ = 93;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 0);
      current_statement__ = 94;
      if (lcm_sym321__) {
        current_statement__ = 94;
        if (lcm_sym322__) {
          current_statement__ = 94;
          current_statement__ = 94;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 94;
            current_statement__ = 94;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 94;
          if (lcm_sym322__) {
            current_statement__ = 94;
            current_statement__ = 94;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 94;
              current_statement__ = 94;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 94;
      if (lcm_sym321__) {
        current_statement__ = 94;
        if (lcm_sym322__) {
          current_statement__ = 94;
          current_statement__ = 94;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 94;
            current_statement__ = 94;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 94;
          if (lcm_sym322__) {
            current_statement__ = 94;
            current_statement__ = 94;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 94;
              current_statement__ = 94;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      current_statement__ = 95;
      if (lcm_sym321__) {
        current_statement__ = 95;
        current_statement__ = 95;
        check_greater_or_equal(function__, "first[sym1__]", first[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 95;
          current_statement__ = 95;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 95;
      if (lcm_sym321__) {
        current_statement__ = 95;
        current_statement__ = 95;
        check_less_or_equal(function__, "first[sym1__]", first[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 95;
          current_statement__ = 95;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);}
      } 
      current_statement__ = 96;
      if (lcm_sym321__) {
        current_statement__ = 96;
        current_statement__ = 96;
        check_greater_or_equal(function__, "last[sym1__]", last[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 96;
          current_statement__ = 96;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 96;
      if (lcm_sym321__) {
        current_statement__ = 96;
        current_statement__ = 96;
        check_less_or_equal(function__, "last[sym1__]", last[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 96;
          current_statement__ = 96;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 3;
      validate_non_negative_index("gamma", "n_occasions", n_occasions);
      num_params_r__ += n_occasions;
      current_statement__ = 4;
      validate_non_negative_index("epsilon", "(n_occasions - 1)",
                                  (n_occasions - 1));
      num_params_r__ += (n_occasions - 1);
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "inlining_fail2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      int lcm_sym320__;
      int lcm_sym319__;
      int lcm_sym318__;
      int lcm_sym317__;
      local_scalar_t__ lcm_sym312__;
      double lcm_sym310__;
      int lcm_sym316__;
      int lcm_sym315__;
      double lcm_sym313__;
      int lcm_sym308__;
      Eigen::Matrix<local_scalar_t__, -1, -1> lcm_sym307__;
      double lcm_sym306__;
      double lcm_sym305__;
      local_scalar_t__ lcm_sym304__;
      local_scalar_t__ lcm_sym303__;
      double lcm_sym302__;
      double lcm_sym301__;
      int lcm_sym300__;
      double lcm_sym299__;
      double lcm_sym298__;
      double lcm_sym297__;
      double lcm_sym296__;
      double lcm_sym295__;
      double lcm_sym294__;
      double lcm_sym293__;
      double lcm_sym292__;
      double lcm_sym291__;
      double lcm_sym290__;
      double lcm_sym289__;
      double lcm_sym288__;
      double lcm_sym287__;
      int lcm_sym286__;
      int lcm_sym285__;
      int lcm_sym284__;
      double lcm_sym283__;
      double lcm_sym282__;
      double lcm_sym281__;
      double lcm_sym280__;
      double lcm_sym279__;
      double lcm_sym278__;
      double lcm_sym277__;
      double lcm_sym276__;
      double lcm_sym275__;
      double lcm_sym274__;
      double lcm_sym273__;
      double lcm_sym272__;
      double lcm_sym271__;
      double lcm_sym270__;
      int lcm_sym269__;
      int lcm_sym268__;
      int lcm_sym267__;
      int lcm_sym266__;
      int lcm_sym265__;
      int lcm_sym264__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym263__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym262__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym261__;
      int lcm_sym314__;
      int lcm_sym259__;
      int lcm_sym258__;
      int lcm_sym257__;
      int lcm_sym256__;
      int lcm_sym255__;
      int lcm_sym254__;
      int lcm_sym253__;
      int lcm_sym252__;
      int lcm_sym251__;
      int lcm_sym250__;
      int lcm_sym249__;
      int lcm_sym248__;
      int lcm_sym247__;
      int lcm_sym246__;
      int lcm_sym245__;
      int lcm_sym244__;
      local_scalar_t__ mean_phi;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      }
      local_scalar_t__ mean_p;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      current_statement__ = 3;
      validate_non_negative_index("gamma", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> gamma;
      gamma = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      
      current_statement__ = 3;
      gamma = in__.vector(n_occasions);
      lcm_sym247__ = logical_gte(n_occasions, 1);
      if (lcm_sym247__) {
        current_statement__ = 3;
        if (jacobian__) {
          current_statement__ = 3;
          assign(gamma, cons_list(index_uni(1), nil_index_list()),
            stan::math::lub_constrain(gamma[(1 - 1)], 0, 1, lp__),
            "assigning variable gamma");
        } else {
          current_statement__ = 3;
          assign(gamma, cons_list(index_uni(1), nil_index_list()),
            stan::math::lub_constrain(gamma[(1 - 1)], 0, 1),
            "assigning variable gamma");
        }
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 3;
          if (jacobian__) {
            current_statement__ = 3;
            assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
              stan::math::lub_constrain(gamma[(sym1__ - 1)], 0, 1, lp__),
              "assigning variable gamma");
          } else {
            current_statement__ = 3;
            assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
              stan::math::lub_constrain(gamma[(sym1__ - 1)], 0, 1),
              "assigning variable gamma");
          }}
      } 
      lcm_sym314__ = (n_occasions - 1);
      validate_non_negative_index("epsilon", "(n_occasions - 1)",
                                  lcm_sym314__);
      Eigen::Matrix<local_scalar_t__, -1, 1> epsilon;
      epsilon = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym314__);
      
      current_statement__ = 4;
      epsilon = in__.vector(lcm_sym314__);
      local_scalar_t__ sigma;
      
      current_statement__ = 5;
      sigma = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        sigma = stan::math::lub_constrain(sigma, 0, 5, lp__);
      } else {
        current_statement__ = 5;
        sigma = stan::math::lub_constrain(sigma, 0, 5);
      }
      current_statement__ = 6;
      validate_non_negative_index("phi", "M", M);
      current_statement__ = 6;
      validate_non_negative_index("phi", "(n_occasions - 1)", lcm_sym314__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, lcm_sym314__);
      
      lcm_sym246__ = logical_gte(M, 1);
      if (lcm_sym246__) {
        {
          lcm_sym248__ = logical_gte(lcm_sym314__, 1);
          if (lcm_sym248__) {
            lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym313__,
              "assigning variable phi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym314__; ++sym2__) {
              current_statement__ = 6;
              assign(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym313__, "assigning variable phi");}
          } 
          for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
            current_statement__ = 6;
            if (lcm_sym248__) {
              lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym313__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym314__; ++sym2__) {
                current_statement__ = 6;
                assign(phi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym313__, "assigning variable phi");}
            } }
        }
      } else {
        lcm_sym248__ = logical_gte(lcm_sym314__, 1);
      }
      current_statement__ = 7;
      validate_non_negative_index("p", "M", M);
      current_statement__ = 7;
      validate_non_negative_index("p", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      
      current_statement__ = 7;
      if (lcm_sym246__) {
        current_statement__ = 7;
        if (lcm_sym247__) {
          lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym313__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym313__, "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym247__) {
            lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym313__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym313__, "assigning variable p");}
          } }
      } 
      current_statement__ = 8;
      validate_non_negative_index("chi", "M", M);
      current_statement__ = 8;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      
      current_statement__ = 8;
      if (lcm_sym246__) {
        current_statement__ = 8;
        if (lcm_sym247__) {
          lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym313__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym313__, "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym247__) {
            lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym313__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym313__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 11;
      if (lcm_sym248__) {
        current_statement__ = 10;
        if (lcm_sym246__) {
          lcm_sym304__ = inv_logit((logit(mean_phi) + epsilon[(1 - 1)]));
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym304__,
            "assigning variable phi");
          for (size_t i = 2; i <= M; ++i) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), lcm_sym304__,
              "assigning variable phi");}
        } 
        for (size_t t = 2; t <= lcm_sym314__; ++t) {
          current_statement__ = 10;
          if (lcm_sym246__) {
            lcm_sym303__ = inv_logit((logit(mean_phi) + epsilon[(t - 1)]));
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), lcm_sym303__,
              "assigning variable phi");
            for (size_t i = 2; i <= M; ++i) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), lcm_sym303__,
                "assigning variable phi");}
          } }
      } 
      assign(lcm_sym307__, nil_index_list(),
        rep_matrix(mean_p, M, n_occasions), "assigning variable lcm_sym307__");
      assign(p, nil_index_list(), lcm_sym307__, "assigning variable p");
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym25__;
      int inline_sym35__;
      
      inline_sym35__ = 0;
      for (size_t inline_sym36__ = 1; inline_sym36__ <= 1; ++inline_sym36__) {
        int inline_sym26__;
        
        lcm_sym308__ = rows(lcm_sym307__);
        int inline_sym27__;
        
        lcm_sym300__ = cols(lcm_sym307__);
        current_statement__ = 14;
        validate_non_negative_index("chi", "n_ind", lcm_sym308__);
        current_statement__ = 14;
        validate_non_negative_index("chi", "n_occasions", lcm_sym300__);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym28__;
        inline_sym28__ = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym308__, lcm_sym300__);
        
        for (size_t inline_sym30__ = 1; inline_sym30__ <= lcm_sym308__;
             ++inline_sym30__) {
          if (logical_gte(lcm_sym300__, 1)) {
            lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
            assign(inline_sym28__,
              cons_list(index_uni(inline_sym30__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym313__,
              "assigning variable inline_sym28__");
            for (size_t inline_sym29__ = 2; inline_sym29__ <= lcm_sym300__;
                 ++inline_sym29__) {
              current_statement__ = 14;
              assign(inline_sym28__,
                cons_list(index_uni(inline_sym30__),
                  cons_list(index_uni(inline_sym29__), nil_index_list())),
                lcm_sym313__, "assigning variable inline_sym28__");}
          } 
          if (inline_sym35__) {
            break;
          } }
        if (inline_sym35__) {
          break;
        } 
        for (size_t inline_sym34__ = 1; inline_sym34__ <= lcm_sym308__;
             ++inline_sym34__) {
          current_statement__ = 15;
          assign(inline_sym28__,
            cons_list(index_uni(inline_sym34__),
              cons_list(index_uni(lcm_sym300__), nil_index_list())), 1.0,
            "assigning variable inline_sym28__");
          lcm_sym265__ = (lcm_sym300__ - 1);
          if (logical_gte(lcm_sym265__, 1)) {
            int inline_sym31__;
            
            int inline_sym32__;
            
            lcm_sym269__ = (lcm_sym265__ + 1);
            current_statement__ = 18;
            assign(inline_sym28__,
              cons_list(index_uni(inline_sym34__),
                cons_list(index_uni(lcm_sym265__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym34__),
                     cons_list(index_uni(lcm_sym265__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(lcm_sym307__,
                      cons_list(index_uni(inline_sym34__),
                        cons_list(index_uni(lcm_sym269__), nil_index_list())),
                      "lcm_sym307__"))),
                rvalue(inline_sym28__,
                  cons_list(index_uni(inline_sym34__),
                    cons_list(index_uni(lcm_sym269__), nil_index_list())),
                  "inline_sym28__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym34__),
                      cons_list(index_uni(lcm_sym265__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym28__");
            for (size_t inline_sym33__ = 2; inline_sym33__ <= lcm_sym265__;
                 ++inline_sym33__) {
              int inline_sym31__;
              
              lcm_sym264__ = (lcm_sym300__ - inline_sym33__);
              int inline_sym32__;
              
              lcm_sym268__ = (lcm_sym264__ + 1);
              current_statement__ = 18;
              assign(inline_sym28__,
                cons_list(index_uni(inline_sym34__),
                  cons_list(index_uni(lcm_sym264__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym34__),
                       cons_list(index_uni(lcm_sym264__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(lcm_sym307__,
                        cons_list(index_uni(inline_sym34__),
                          cons_list(index_uni(lcm_sym268__),
                            nil_index_list())), "lcm_sym307__"))),
                  rvalue(inline_sym28__,
                    cons_list(index_uni(inline_sym34__),
                      cons_list(index_uni(lcm_sym268__), nil_index_list())),
                    "inline_sym28__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym34__),
                        cons_list(index_uni(lcm_sym264__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym28__");}
          } 
          if (inline_sym35__) {
            break;
          } }
        if (inline_sym35__) {
          break;
        } 
        inline_sym35__ = 1;
        assign(inline_sym25__, nil_index_list(), inline_sym28__,
          "assigning variable inline_sym25__");
        break;}
      assign(chi, nil_index_list(), inline_sym25__, "assigning variable chi");
      current_statement__ = 6;
      current_statement__ = 6;
      check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 6;
      current_statement__ = 6;
      check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 7;
      current_statement__ = 7;
      check_greater_or_equal(function__, "p", lcm_sym307__, 0);
      current_statement__ = 7;
      current_statement__ = 7;
      check_less_or_equal(function__, "p", lcm_sym307__, 1);
      current_statement__ = 8;
      current_statement__ = 8;
      check_greater_or_equal(function__, "chi", inline_sym25__, 0);
      current_statement__ = 8;
      current_statement__ = 8;
      check_less_or_equal(function__, "chi", inline_sym25__, 1);
      {
        current_statement__ = 67;
        lp_accum__.add(normal_log<propto__>(epsilon, 0, sigma));
        int inline_sym45__;
        
        {
          int inline_sym37__;
          
          lcm_sym319__ = dims(y)[(1 - 1)];
          int inline_sym38__;
          
          lcm_sym320__ = dims(y)[(2 - 1)];
          current_statement__ = 70;
          validate_non_negative_index("qgamma", "n_occasions", lcm_sym320__);
          Eigen::Matrix<double, -1, 1> inline_sym39__;
          inline_sym39__ = Eigen::Matrix<double, -1, 1>(lcm_sym320__);
          
          assign(lcm_sym261__, nil_index_list(), subtract(1.0, gamma),
            "assigning variable lcm_sym261__");
          lcm_sym258__ = logical_gte(lcm_sym319__, 1);
          if (lcm_sym258__) {
            current_statement__ = 71;
            validate_non_negative_index("qp", "n_occasions", lcm_sym320__);
            Eigen::Matrix<double, -1, 1> inline_sym41__;
            inline_sym41__ = Eigen::Matrix<double, -1, 1>(lcm_sym320__);
            
            assign(lcm_sym263__, nil_index_list(),
              subtract(1.0,
                transpose(
                  rvalue(lcm_sym307__,
                    cons_list(index_uni(1), nil_index_list()),
                    "lcm_sym307__"))), "assigning variable lcm_sym263__");
            lcm_sym316__ = first[(1 - 1)];
            if (lcm_sym316__) {
              current_statement__ = 83;
              if (logical_eq(lcm_sym316__, 1)) {
                lcm_sym312__ = gamma[(1 - 1)];
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    (lcm_sym312__ *
                      rvalue(lcm_sym307__,
                        cons_list(index_uni(1),
                          cons_list(index_uni(1), nil_index_list())),
                        "lcm_sym307__"))));
              } else {
                current_statement__ = 77;
                validate_non_negative_index("lp", "first[(i - 1)]",
                                            lcm_sym316__);
                Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym42__;
                inline_sym42__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym316__);
                
                if (logical_gte(lcm_sym316__, 1)) {
                  lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
                  assign(inline_sym42__,
                    cons_list(index_uni(1), nil_index_list()), lcm_sym313__,
                    "assigning variable inline_sym42__");
                  for (size_t inline_sym40__ = 2;
                       inline_sym40__ <= lcm_sym316__; ++inline_sym40__) {
                    current_statement__ = 77;
                    assign(inline_sym42__,
                      cons_list(index_uni(inline_sym40__), nil_index_list()),
                      lcm_sym313__, "assigning variable inline_sym42__");}
                } 
                lcm_sym312__ = gamma[(1 - 1)];
                lcm_sym267__ = (lcm_sym316__ - 1);
                assign(inline_sym42__,
                  cons_list(index_uni(1), nil_index_list()),
                  (((bernoulli_lpmf<false>(1, lcm_sym312__) +
                      bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym263__,
                            cons_list(index_min_max(1, lcm_sym267__),
                              nil_index_list()), "lcm_sym263__")))) +
                     bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(phi,
                           cons_list(index_uni(1),
                             cons_list(index_min_max(1, lcm_sym267__),
                               nil_index_list())), "phi")))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(lcm_sym307__,
                        cons_list(index_uni(1),
                          cons_list(index_uni(lcm_sym316__),
                            nil_index_list())), "lcm_sym307__"))),
                  "assigning variable inline_sym42__");
                if (logical_gte(lcm_sym267__, 2)) {
                  current_statement__ = 78;
                  assign(inline_sym42__,
                    cons_list(index_uni(2), nil_index_list()),
                    ((((bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym261__,
                              cons_list(index_min_max(1, 1),
                                nil_index_list()), "lcm_sym261__"))) +
                         bernoulli_lpmf<false>(1, gamma[(2 - 1)])) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym263__,
                              cons_list(index_min_max(2, lcm_sym267__),
                                nil_index_list()), "lcm_sym263__")))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(phi,
                             cons_list(index_uni(1),
                               cons_list(index_min_max(2, lcm_sym267__),
                                 nil_index_list())), "phi")))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(lcm_sym307__,
                          cons_list(index_uni(1),
                            cons_list(index_uni(lcm_sym316__),
                              nil_index_list())), "lcm_sym307__"))),
                    "assigning variable inline_sym42__");
                  for (size_t inline_sym43__ = 3;
                       inline_sym43__ <= lcm_sym267__; ++inline_sym43__) {
                    current_statement__ = 78;
                    assign(inline_sym42__,
                      cons_list(index_uni(inline_sym43__), nil_index_list()),
                      ((((bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym261__,
                                cons_list(
                                  index_min_max(1, (inline_sym43__ - 1)),
                                  nil_index_list()), "lcm_sym261__"))) +
                           bernoulli_lpmf<false>(1,
                             gamma[(inline_sym43__ - 1)])) +
                          bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym263__,
                                cons_list(
                                  index_min_max(inline_sym43__, lcm_sym267__),
                                  nil_index_list()), "lcm_sym263__")))) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(phi,
                               cons_list(index_uni(1),
                                 cons_list(
                                   index_min_max(inline_sym43__, lcm_sym267__),
                                   nil_index_list())), "phi")))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(lcm_sym307__,
                            cons_list(index_uni(1),
                              cons_list(index_uni(lcm_sym316__),
                                nil_index_list())), "lcm_sym307__"))),
                      "assigning variable inline_sym42__");}
                } 
                current_statement__ = 79;
                assign(inline_sym42__,
                  cons_list(index_uni(lcm_sym316__), nil_index_list()),
                  ((bernoulli_lpmf<false>(1,
                      prod(
                        rvalue(lcm_sym261__,
                          cons_list(index_min_max(1, lcm_sym267__),
                            nil_index_list()), "lcm_sym261__"))) +
                     bernoulli_lpmf<false>(1, gamma[(lcm_sym316__ - 1)])) +
                    bernoulli_lpmf<false>(1,
                      rvalue(lcm_sym307__,
                        cons_list(index_uni(1),
                          cons_list(index_uni(lcm_sym316__),
                            nil_index_list())), "lcm_sym307__"))),
                  "assigning variable inline_sym42__");
                current_statement__ = 80;
                lp_accum__.add(log_sum_exp(inline_sym42__));
              }
              lcm_sym318__ = last[(1 - 1)];
              if (logical_gte(lcm_sym318__, (lcm_sym316__ + 1))) {
                current_statement__ = 84;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(1),
                        cons_list(index_uni(((lcm_sym316__ + 1) - 1)),
                          nil_index_list())), "phi")));
                lcm_sym285__ = ((lcm_sym316__ + 1) + 1);
                lp_accum__.add(
                  bernoulli_log<propto__>(
                    y[(1 - 1)][((lcm_sym316__ + 1) - 1)],
                    rvalue(lcm_sym307__,
                      cons_list(index_uni(1),
                        cons_list(index_uni((lcm_sym316__ + 1)),
                          nil_index_list())), "lcm_sym307__")));
                for (size_t inline_sym43__ = lcm_sym285__;
                     inline_sym43__ <= lcm_sym318__; ++inline_sym43__) {
                  current_statement__ = 84;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      rvalue(phi,
                        cons_list(index_uni(1),
                          cons_list(index_uni((inline_sym43__ - 1)),
                            nil_index_list())), "phi")));
                  current_statement__ = 85;
                  lp_accum__.add(
                    bernoulli_log<propto__>(y[(1 - 1)][(inline_sym43__ - 1)],
                      rvalue(lcm_sym307__,
                        cons_list(index_uni(1),
                          cons_list(index_uni(inline_sym43__),
                            nil_index_list())), "lcm_sym307__")));}
              } 
              current_statement__ = 87;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(inline_sym25__,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym318__), nil_index_list())),
                    "inline_sym25__")));
            } else {
              lcm_sym286__ = (lcm_sym320__ + 1);
              validate_non_negative_index("lp", "(n_occasions + 1)",
                                          lcm_sym286__);
              Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym42__;
              inline_sym42__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym286__);
              
              if (logical_gte(lcm_sym286__, 1)) {
                lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
                assign(inline_sym42__,
                  cons_list(index_uni(1), nil_index_list()), lcm_sym313__,
                  "assigning variable inline_sym42__");
                for (size_t inline_sym40__ = 2;
                     inline_sym40__ <= lcm_sym286__; ++inline_sym40__) {
                  current_statement__ = 72;
                  assign(inline_sym42__,
                    cons_list(index_uni(inline_sym40__), nil_index_list()),
                    lcm_sym313__, "assigning variable inline_sym42__");}
              } 
              lcm_sym312__ = gamma[(1 - 1)];
              assign(inline_sym42__,
                cons_list(index_uni(1), nil_index_list()),
                ((bernoulli_lpmf<false>(1, lcm_sym312__) +
                   bernoulli_lpmf<false>(0,
                     rvalue(lcm_sym307__,
                       cons_list(index_uni(1),
                         cons_list(index_uni(1), nil_index_list())),
                       "lcm_sym307__"))) +
                  bernoulli_lpmf<false>(1,
                    rvalue(inline_sym25__,
                      cons_list(index_uni(1),
                        cons_list(index_uni(1), nil_index_list())),
                      "inline_sym25__"))),
                "assigning variable inline_sym42__");
              if (logical_gte(lcm_sym320__, 2)) {
                current_statement__ = 73;
                assign(inline_sym42__,
                  cons_list(index_uni(2), nil_index_list()),
                  (((bernoulli_lpmf<false>(1,
                       prod(
                         rvalue(lcm_sym261__,
                           cons_list(index_min_max(1, 1), nil_index_list()),
                           "lcm_sym261__"))) +
                      bernoulli_lpmf<false>(1, gamma[(2 - 1)])) +
                     bernoulli_lpmf<false>(0,
                       rvalue(lcm_sym307__,
                         cons_list(index_uni(1),
                           cons_list(index_uni(2), nil_index_list())),
                         "lcm_sym307__"))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(inline_sym25__,
                        cons_list(index_uni(1),
                          cons_list(index_uni(2), nil_index_list())),
                        "inline_sym25__"))),
                  "assigning variable inline_sym42__");
                for (size_t inline_sym43__ = 3;
                     inline_sym43__ <= lcm_sym320__; ++inline_sym43__) {
                  current_statement__ = 73;
                  assign(inline_sym42__,
                    cons_list(index_uni(inline_sym43__), nil_index_list()),
                    (((bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym261__,
                             cons_list(
                               index_min_max(1, (inline_sym43__ - 1)),
                               nil_index_list()), "lcm_sym261__"))) +
                        bernoulli_lpmf<false>(1, gamma[(inline_sym43__ - 1)]))
                       +
                       bernoulli_lpmf<false>(0,
                         rvalue(lcm_sym307__,
                           cons_list(index_uni(1),
                             cons_list(index_uni(inline_sym43__),
                               nil_index_list())), "lcm_sym307__"))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(inline_sym25__,
                          cons_list(index_uni(1),
                            cons_list(index_uni(inline_sym43__),
                              nil_index_list())), "inline_sym25__"))),
                    "assigning variable inline_sym42__");}
              } 
              current_statement__ = 74;
              assign(inline_sym42__,
                cons_list(index_uni(lcm_sym286__), nil_index_list()),
                bernoulli_lpmf<false>(1, prod(lcm_sym261__)),
                "assigning variable inline_sym42__");
              current_statement__ = 75;
              lp_accum__.add(log_sum_exp(inline_sym42__));
            }
            for (size_t inline_sym44__ = 2; inline_sym44__ <= lcm_sym319__;
                 ++inline_sym44__) {
              current_statement__ = 71;
              validate_non_negative_index("qp", "n_occasions", lcm_sym320__);
              Eigen::Matrix<double, -1, 1> inline_sym41__;
              inline_sym41__ = Eigen::Matrix<double, -1, 1>(lcm_sym320__);
              
              assign(lcm_sym262__, nil_index_list(),
                subtract(1.0,
                  transpose(
                    rvalue(lcm_sym307__,
                      cons_list(index_uni(inline_sym44__), nil_index_list()),
                      "lcm_sym307__"))), "assigning variable lcm_sym262__");
              lcm_sym315__ = first[(inline_sym44__ - 1)];
              if (lcm_sym315__) {
                current_statement__ = 83;
                if (logical_eq(lcm_sym315__, 1)) {
                  current_statement__ = 90;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      (lcm_sym312__ *
                        rvalue(lcm_sym307__,
                          cons_list(index_uni(inline_sym44__),
                            cons_list(index_uni(1), nil_index_list())),
                          "lcm_sym307__"))));
                } else {
                  current_statement__ = 77;
                  validate_non_negative_index("lp", "first[(i - 1)]",
                                              lcm_sym315__);
                  Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym42__;
                  inline_sym42__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym315__);
                  
                  if (logical_gte(lcm_sym315__, 1)) {
                    lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
                    assign(inline_sym42__,
                      cons_list(index_uni(1), nil_index_list()),
                      lcm_sym313__, "assigning variable inline_sym42__");
                    for (size_t inline_sym40__ = 2;
                         inline_sym40__ <= lcm_sym315__; ++inline_sym40__) {
                      current_statement__ = 77;
                      assign(inline_sym42__,
                        cons_list(index_uni(inline_sym40__),
                          nil_index_list()), lcm_sym313__,
                        "assigning variable inline_sym42__");}
                  } 
                  lcm_sym266__ = (lcm_sym315__ - 1);
                  assign(inline_sym42__,
                    cons_list(index_uni(1), nil_index_list()),
                    (((bernoulli_lpmf<false>(1, lcm_sym312__) +
                        bernoulli_lpmf<false>(1,
                          prod(
                            rvalue(lcm_sym262__,
                              cons_list(index_min_max(1, lcm_sym266__),
                                nil_index_list()), "lcm_sym262__")))) +
                       bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(phi,
                             cons_list(index_uni(inline_sym44__),
                               cons_list(index_min_max(1, lcm_sym266__),
                                 nil_index_list())), "phi")))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(lcm_sym307__,
                          cons_list(index_uni(inline_sym44__),
                            cons_list(index_uni(lcm_sym315__),
                              nil_index_list())), "lcm_sym307__"))),
                    "assigning variable inline_sym42__");
                  if (logical_gte(lcm_sym266__, 2)) {
                    current_statement__ = 78;
                    assign(inline_sym42__,
                      cons_list(index_uni(2), nil_index_list()),
                      ((((bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym261__,
                                cons_list(index_min_max(1, 1),
                                  nil_index_list()), "lcm_sym261__"))) +
                           bernoulli_lpmf<false>(1, gamma[(2 - 1)])) +
                          bernoulli_lpmf<false>(1,
                            prod(
                              rvalue(lcm_sym262__,
                                cons_list(index_min_max(2, lcm_sym266__),
                                  nil_index_list()), "lcm_sym262__")))) +
                         bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(phi,
                               cons_list(index_uni(inline_sym44__),
                                 cons_list(index_min_max(2, lcm_sym266__),
                                   nil_index_list())), "phi")))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(lcm_sym307__,
                            cons_list(index_uni(inline_sym44__),
                              cons_list(index_uni(lcm_sym315__),
                                nil_index_list())), "lcm_sym307__"))),
                      "assigning variable inline_sym42__");
                    for (size_t inline_sym43__ = 3;
                         inline_sym43__ <= lcm_sym266__; ++inline_sym43__) {
                      current_statement__ = 78;
                      assign(inline_sym42__,
                        cons_list(index_uni(inline_sym43__),
                          nil_index_list()),
                        ((((bernoulli_lpmf<false>(1,
                              prod(
                                rvalue(lcm_sym261__,
                                  cons_list(
                                    index_min_max(1, (inline_sym43__ - 1)),
                                    nil_index_list()), "lcm_sym261__"))) +
                             bernoulli_lpmf<false>(1,
                               gamma[(inline_sym43__ - 1)])) +
                            bernoulli_lpmf<false>(1,
                              prod(
                                rvalue(lcm_sym262__,
                                  cons_list(
                                    index_min_max(inline_sym43__, lcm_sym266__),
                                    nil_index_list()), "lcm_sym262__")))) +
                           bernoulli_lpmf<false>(1,
                             prod(
                               rvalue(phi,
                                 cons_list(index_uni(inline_sym44__),
                                   cons_list(
                                     index_min_max(inline_sym43__, lcm_sym266__),
                                     nil_index_list())), "phi")))) +
                          bernoulli_lpmf<false>(1,
                            rvalue(lcm_sym307__,
                              cons_list(index_uni(inline_sym44__),
                                cons_list(index_uni(lcm_sym315__),
                                  nil_index_list())), "lcm_sym307__"))),
                        "assigning variable inline_sym42__");}
                  } 
                  current_statement__ = 79;
                  assign(inline_sym42__,
                    cons_list(index_uni(lcm_sym315__), nil_index_list()),
                    ((bernoulli_lpmf<false>(1,
                        prod(
                          rvalue(lcm_sym261__,
                            cons_list(index_min_max(1, lcm_sym266__),
                              nil_index_list()), "lcm_sym261__"))) +
                       bernoulli_lpmf<false>(1, gamma[(lcm_sym315__ - 1)])) +
                      bernoulli_lpmf<false>(1,
                        rvalue(lcm_sym307__,
                          cons_list(index_uni(inline_sym44__),
                            cons_list(index_uni(lcm_sym315__),
                              nil_index_list())), "lcm_sym307__"))),
                    "assigning variable inline_sym42__");
                  current_statement__ = 80;
                  lp_accum__.add(log_sum_exp(inline_sym42__));
                }
                lcm_sym317__ = last[(inline_sym44__ - 1)];
                if (logical_gte(lcm_sym317__, (lcm_sym315__ + 1))) {
                  current_statement__ = 84;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      rvalue(phi,
                        cons_list(index_uni(inline_sym44__),
                          cons_list(index_uni(((lcm_sym315__ + 1) - 1)),
                            nil_index_list())), "phi")));
                  lcm_sym284__ = ((lcm_sym315__ + 1) + 1);
                  lp_accum__.add(
                    bernoulli_log<propto__>(
                      y[(inline_sym44__ - 1)][((lcm_sym315__ + 1) - 1)],
                      rvalue(lcm_sym307__,
                        cons_list(index_uni(inline_sym44__),
                          cons_list(index_uni((lcm_sym315__ + 1)),
                            nil_index_list())), "lcm_sym307__")));
                  for (size_t inline_sym43__ = lcm_sym284__;
                       inline_sym43__ <= lcm_sym317__; ++inline_sym43__) {
                    current_statement__ = 84;
                    lp_accum__.add(
                      bernoulli_log<propto__>(1,
                        rvalue(phi,
                          cons_list(index_uni(inline_sym44__),
                            cons_list(index_uni((inline_sym43__ - 1)),
                              nil_index_list())), "phi")));
                    current_statement__ = 85;
                    lp_accum__.add(
                      bernoulli_log<propto__>(
                        y[(inline_sym44__ - 1)][(inline_sym43__ - 1)],
                        rvalue(lcm_sym307__,
                          cons_list(index_uni(inline_sym44__),
                            cons_list(index_uni(inline_sym43__),
                              nil_index_list())), "lcm_sym307__")));}
                } 
                current_statement__ = 87;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(inline_sym25__,
                      cons_list(index_uni(inline_sym44__),
                        cons_list(index_uni(lcm_sym317__), nil_index_list())),
                      "inline_sym25__")));
              } else {
                lcm_sym286__ = (lcm_sym320__ + 1);
                validate_non_negative_index("lp", "(n_occasions + 1)",
                                            lcm_sym286__);
                Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym42__;
                inline_sym42__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym286__);
                
                if (logical_gte(lcm_sym286__, 1)) {
                  lcm_sym313__ = std::numeric_limits<double>::quiet_NaN();
                  assign(inline_sym42__,
                    cons_list(index_uni(1), nil_index_list()), lcm_sym313__,
                    "assigning variable inline_sym42__");
                  for (size_t inline_sym40__ = 2;
                       inline_sym40__ <= lcm_sym286__; ++inline_sym40__) {
                    current_statement__ = 72;
                    assign(inline_sym42__,
                      cons_list(index_uni(inline_sym40__), nil_index_list()),
                      lcm_sym313__, "assigning variable inline_sym42__");}
                } 
                current_statement__ = 89;
                assign(inline_sym42__,
                  cons_list(index_uni(1), nil_index_list()),
                  ((bernoulli_lpmf<false>(1, lcm_sym312__) +
                     bernoulli_lpmf<false>(0,
                       rvalue(lcm_sym307__,
                         cons_list(index_uni(inline_sym44__),
                           cons_list(index_uni(1), nil_index_list())),
                         "lcm_sym307__"))) +
                    bernoulli_lpmf<false>(1,
                      rvalue(inline_sym25__,
                        cons_list(index_uni(inline_sym44__),
                          cons_list(index_uni(1), nil_index_list())),
                        "inline_sym25__"))),
                  "assigning variable inline_sym42__");
                if (logical_gte(lcm_sym320__, 2)) {
                  current_statement__ = 73;
                  assign(inline_sym42__,
                    cons_list(index_uni(2), nil_index_list()),
                    (((bernoulli_lpmf<false>(1,
                         prod(
                           rvalue(lcm_sym261__,
                             cons_list(index_min_max(1, 1), nil_index_list()),
                             "lcm_sym261__"))) +
                        bernoulli_lpmf<false>(1, gamma[(2 - 1)])) +
                       bernoulli_lpmf<false>(0,
                         rvalue(lcm_sym307__,
                           cons_list(index_uni(inline_sym44__),
                             cons_list(index_uni(2), nil_index_list())),
                           "lcm_sym307__"))) +
                      bernoulli_lpmf<false>(1,
                        rvalue(inline_sym25__,
                          cons_list(index_uni(inline_sym44__),
                            cons_list(index_uni(2), nil_index_list())),
                          "inline_sym25__"))),
                    "assigning variable inline_sym42__");
                  for (size_t inline_sym43__ = 3;
                       inline_sym43__ <= lcm_sym320__; ++inline_sym43__) {
                    current_statement__ = 73;
                    assign(inline_sym42__,
                      cons_list(index_uni(inline_sym43__), nil_index_list()),
                      (((bernoulli_lpmf<false>(1,
                           prod(
                             rvalue(lcm_sym261__,
                               cons_list(
                                 index_min_max(1, (inline_sym43__ - 1)),
                                 nil_index_list()), "lcm_sym261__"))) +
                          bernoulli_lpmf<false>(1,
                            gamma[(inline_sym43__ - 1)])) +
                         bernoulli_lpmf<false>(0,
                           rvalue(lcm_sym307__,
                             cons_list(index_uni(inline_sym44__),
                               cons_list(index_uni(inline_sym43__),
                                 nil_index_list())), "lcm_sym307__"))) +
                        bernoulli_lpmf<false>(1,
                          rvalue(inline_sym25__,
                            cons_list(index_uni(inline_sym44__),
                              cons_list(index_uni(inline_sym43__),
                                nil_index_list())), "inline_sym25__"))),
                      "assigning variable inline_sym42__");}
                } 
                current_statement__ = 74;
                assign(inline_sym42__,
                  cons_list(index_uni(lcm_sym286__), nil_index_list()),
                  bernoulli_lpmf<false>(1, prod(lcm_sym261__)),
                  "assigning variable inline_sym42__");
                current_statement__ = 75;
                lp_accum__.add(log_sum_exp(inline_sym42__));
              }}
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "inlining_fail2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      int lcm_sym243__;
      int lcm_sym242__;
      double lcm_sym241__;
      double lcm_sym240__;
      double lcm_sym239__;
      double lcm_sym238__;
      double lcm_sym237__;
      double lcm_sym236__;
      int lcm_sym235__;
      int lcm_sym234__;
      int lcm_sym233__;
      int lcm_sym232__;
      double lcm_sym231__;
      double lcm_sym230__;
      double lcm_sym229__;
      double lcm_sym228__;
      double lcm_sym227__;
      double lcm_sym226__;
      double lcm_sym225__;
      double lcm_sym224__;
      local_scalar_t__ lcm_sym186__;
      double lcm_sym223__;
      double lcm_sym222__;
      double lcm_sym221__;
      double lcm_sym220__;
      int lcm_sym219__;
      int lcm_sym218__;
      int lcm_sym217__;
      int lcm_sym216__;
      double lcm_sym214__;
      int lcm_sym211__;
      int lcm_sym210__;
      int lcm_sym209__;
      int lcm_sym208__;
      int lcm_sym207__;
      int lcm_sym206__;
      local_scalar_t__ lcm_sym205__;
      int lcm_sym204__;
      double lcm_sym203__;
      int lcm_sym202__;
      int lcm_sym201__;
      int lcm_sym200__;
      int lcm_sym199__;
      Eigen::Matrix<double, -1, -1> lcm_sym198__;
      std::vector<std::vector<int>> lcm_sym197__;
      local_scalar_t__ lcm_sym196__;
      local_scalar_t__ lcm_sym195__;
      local_scalar_t__ lcm_sym194__;
      local_scalar_t__ lcm_sym193__;
      local_scalar_t__ lcm_sym192__;
      local_scalar_t__ lcm_sym191__;
      double lcm_sym190__;
      double lcm_sym189__;
      Eigen::Matrix<double, -1, 1> lcm_sym188__;
      int lcm_sym187__;
      int lcm_sym181__;
      int lcm_sym180__;
      int lcm_sym179__;
      int lcm_sym178__;
      double lcm_sym177__;
      double lcm_sym176__;
      int lcm_sym175__;
      int lcm_sym174__;
      double lcm_sym173__;
      double lcm_sym172__;
      int lcm_sym171__;
      int lcm_sym170__;
      int lcm_sym169__;
      int lcm_sym168__;
      int lcm_sym167__;
      int lcm_sym166__;
      int lcm_sym215__;
      int lcm_sym164__;
      int lcm_sym163__;
      int lcm_sym162__;
      int lcm_sym161__;
      int lcm_sym160__;
      int lcm_sym159__;
      int lcm_sym158__;
      int lcm_sym157__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym156__;
      double mean_phi;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      double mean_p;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      current_statement__ = 3;
      validate_non_negative_index("gamma", "n_occasions", n_occasions);
      Eigen::Matrix<double, -1, 1> gamma;
      gamma = Eigen::Matrix<double, -1, 1>(n_occasions);
      
      current_statement__ = 3;
      gamma = in__.vector(n_occasions);
      lcm_sym158__ = logical_gte(n_occasions, 1);
      if (lcm_sym158__) {
        current_statement__ = 3;
        assign(gamma, cons_list(index_uni(1), nil_index_list()),
          stan::math::lub_constrain(gamma[(1 - 1)], 0, 1),
          "assigning variable gamma");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 3;
          assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_constrain(gamma[(sym1__ - 1)], 0, 1),
            "assigning variable gamma");}
      } 
      lcm_sym215__ = (n_occasions - 1);
      validate_non_negative_index("epsilon", "(n_occasions - 1)",
                                  lcm_sym215__);
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(lcm_sym215__);
      
      current_statement__ = 4;
      epsilon = in__.vector(lcm_sym215__);
      double sigma;
      
      current_statement__ = 5;
      sigma = in__.scalar();
      current_statement__ = 5;
      sigma = stan::math::lub_constrain(sigma, 0, 5);
      current_statement__ = 6;
      validate_non_negative_index("phi", "M", M);
      current_statement__ = 6;
      validate_non_negative_index("phi", "(n_occasions - 1)", lcm_sym215__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, lcm_sym215__);
      
      lcm_sym157__ = logical_gte(M, 1);
      if (lcm_sym157__) {
        {
          lcm_sym160__ = logical_gte(lcm_sym215__, 1);
          if (lcm_sym160__) {
            {
              lcm_sym214__ = std::numeric_limits<double>::quiet_NaN();
              assign(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym214__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym215__; ++sym2__) {
                current_statement__ = 6;
                assign(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym214__, "assigning variable phi");}
            }
          } else {
            lcm_sym214__ = std::numeric_limits<double>::quiet_NaN();
          }
          for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
            current_statement__ = 6;
            if (lcm_sym160__) {
              current_statement__ = 6;
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym214__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym215__; ++sym2__) {
                current_statement__ = 6;
                assign(phi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym214__, "assigning variable phi");}
            } }
        }
      } else {
        lcm_sym214__ = std::numeric_limits<double>::quiet_NaN();
        lcm_sym160__ = logical_gte(lcm_sym215__, 1);
      }
      current_statement__ = 7;
      validate_non_negative_index("p", "M", M);
      current_statement__ = 7;
      validate_non_negative_index("p", "n_occasions", n_occasions);
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(M, n_occasions);
      
      current_statement__ = 7;
      if (lcm_sym157__) {
        current_statement__ = 7;
        if (lcm_sym158__) {
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym214__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym214__, "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 7;
          if (lcm_sym158__) {
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym214__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 7;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym214__, "assigning variable p");}
          } }
      } 
      current_statement__ = 8;
      validate_non_negative_index("chi", "M", M);
      current_statement__ = 8;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(M, n_occasions);
      
      current_statement__ = 8;
      if (lcm_sym157__) {
        current_statement__ = 8;
        if (lcm_sym158__) {
          current_statement__ = 8;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym214__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 8;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym214__, "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= M; ++sym1__) {
          current_statement__ = 8;
          if (lcm_sym158__) {
            current_statement__ = 8;
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym214__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 8;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym214__, "assigning variable chi");}
          } }
      } 
      vars__.push_back(mean_phi);
      vars__.push_back(mean_p);
      if (lcm_sym158__) {
        vars__.push_back(gamma[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(gamma[(sym1__ - 1)]);}
      } 
      if (lcm_sym160__) {
        vars__.push_back(epsilon[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= lcm_sym215__; ++sym1__) {
          vars__.push_back(epsilon[(sym1__ - 1)]);}
      } 
      vars__.push_back(sigma);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 11;
      if (lcm_sym160__) {
        current_statement__ = 10;
        if (lcm_sym157__) {
          lcm_sym196__ = inv_logit((logit(mean_phi) + epsilon[(1 - 1)]));
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym196__,
            "assigning variable phi");
          for (size_t i = 2; i <= M; ++i) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), lcm_sym196__,
              "assigning variable phi");}
        } 
        for (size_t t = 2; t <= lcm_sym215__; ++t) {
          current_statement__ = 10;
          if (lcm_sym157__) {
            lcm_sym195__ = inv_logit((logit(mean_phi) + epsilon[(t - 1)]));
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), lcm_sym195__,
              "assigning variable phi");
            for (size_t i = 2; i <= M; ++i) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), lcm_sym195__,
                "assigning variable phi");}
          } }
      } 
      assign(lcm_sym198__, nil_index_list(),
        rep_matrix(mean_p, M, n_occasions), "assigning variable lcm_sym198__");
      assign(p, nil_index_list(), lcm_sym198__, "assigning variable p");
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym11__;
      
      inline_sym11__ = 0;
      for (size_t inline_sym12__ = 1; inline_sym12__ <= 1; ++inline_sym12__) {
        int inline_sym2__;
        
        lcm_sym200__ = rows(lcm_sym198__);
        int inline_sym3__;
        
        lcm_sym187__ = cols(lcm_sym198__);
        current_statement__ = 14;
        validate_non_negative_index("chi", "n_ind", lcm_sym200__);
        current_statement__ = 14;
        validate_non_negative_index("chi", "n_occasions", lcm_sym187__);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym4__;
        inline_sym4__ = Eigen::Matrix<local_scalar_t__, -1, -1>(lcm_sym200__, lcm_sym187__);
        
        for (size_t inline_sym6__ = 1; inline_sym6__ <= lcm_sym200__;
             ++inline_sym6__) {
          if (logical_gte(lcm_sym187__, 1)) {
            current_statement__ = 14;
            assign(inline_sym4__,
              cons_list(index_uni(inline_sym6__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym214__,
              "assigning variable inline_sym4__");
            for (size_t inline_sym5__ = 2; inline_sym5__ <= lcm_sym187__;
                 ++inline_sym5__) {
              current_statement__ = 14;
              assign(inline_sym4__,
                cons_list(index_uni(inline_sym6__),
                  cons_list(index_uni(inline_sym5__), nil_index_list())),
                lcm_sym214__, "assigning variable inline_sym4__");}
          } 
          if (inline_sym11__) {
            break;
          } }
        if (inline_sym11__) {
          break;
        } 
        for (size_t inline_sym10__ = 1; inline_sym10__ <= lcm_sym200__;
             ++inline_sym10__) {
          current_statement__ = 15;
          assign(inline_sym4__,
            cons_list(index_uni(inline_sym10__),
              cons_list(index_uni(lcm_sym187__), nil_index_list())), 1.0,
            "assigning variable inline_sym4__");
          lcm_sym169__ = (lcm_sym187__ - 1);
          if (logical_gte(lcm_sym169__, 1)) {
            int inline_sym7__;
            
            int inline_sym8__;
            
            lcm_sym175__ = (lcm_sym169__ + 1);
            current_statement__ = 18;
            assign(inline_sym4__,
              cons_list(index_uni(inline_sym10__),
                cons_list(index_uni(lcm_sym169__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym10__),
                     cons_list(index_uni(lcm_sym169__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(lcm_sym198__,
                      cons_list(index_uni(inline_sym10__),
                        cons_list(index_uni(lcm_sym175__), nil_index_list())),
                      "lcm_sym198__"))),
                rvalue(inline_sym4__,
                  cons_list(index_uni(inline_sym10__),
                    cons_list(index_uni(lcm_sym175__), nil_index_list())),
                  "inline_sym4__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym10__),
                      cons_list(index_uni(lcm_sym169__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym4__");
            for (size_t inline_sym9__ = 2; inline_sym9__ <= lcm_sym169__;
                 ++inline_sym9__) {
              int inline_sym7__;
              
              lcm_sym168__ = (lcm_sym187__ - inline_sym9__);
              int inline_sym8__;
              
              lcm_sym174__ = (lcm_sym168__ + 1);
              current_statement__ = 18;
              assign(inline_sym4__,
                cons_list(index_uni(inline_sym10__),
                  cons_list(index_uni(lcm_sym168__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym10__),
                       cons_list(index_uni(lcm_sym168__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(lcm_sym198__,
                        cons_list(index_uni(inline_sym10__),
                          cons_list(index_uni(lcm_sym174__),
                            nil_index_list())), "lcm_sym198__"))),
                  rvalue(inline_sym4__,
                    cons_list(index_uni(inline_sym10__),
                      cons_list(index_uni(lcm_sym174__), nil_index_list())),
                    "inline_sym4__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym10__),
                        cons_list(index_uni(lcm_sym168__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym4__");}
          } 
          if (inline_sym11__) {
            break;
          } }
        if (inline_sym11__) {
          break;
        } 
        inline_sym11__ = 1;
        assign(inline_sym1__, nil_index_list(), inline_sym4__,
          "assigning variable inline_sym1__");
        break;}
      assign(chi, nil_index_list(), inline_sym1__, "assigning variable chi");
      if (lcm_sym160__) {
        if (lcm_sym157__) {
          vars__.push_back(
            rvalue(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "phi"));
          for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "phi"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym215__; ++sym1__) {
          if (lcm_sym157__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
              vars__.push_back(
                rvalue(phi,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            }
          } }
      } 
      if (lcm_sym158__) {
        if (lcm_sym157__) {
          vars__.push_back(
            rvalue(lcm_sym198__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "lcm_sym198__"));
          for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
            vars__.push_back(
              rvalue(lcm_sym198__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "lcm_sym198__"));
          }
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym157__) {
            vars__.push_back(
              rvalue(lcm_sym198__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "lcm_sym198__"));
            for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
              vars__.push_back(
                rvalue(lcm_sym198__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "lcm_sym198__"));}
          } }
      } 
      if (lcm_sym158__) {
        if (lcm_sym157__) {
          vars__.push_back(
            rvalue(inline_sym1__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "inline_sym1__"));
          for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                "inline_sym1__"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym157__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "inline_sym1__"));
            for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
              vars__.push_back(
                rvalue(inline_sym1__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "inline_sym1__"));}
          } }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      double sigma2;
      
      current_statement__ = 22;
      sigma2 = lcm_sym214__;
      local_scalar_t__ psi;
      
      current_statement__ = 23;
      psi = lcm_sym214__;
      current_statement__ = 24;
      validate_non_negative_index("b", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, 1> b;
      b = Eigen::Matrix<local_scalar_t__, -1, 1>(n_occasions);
      
      current_statement__ = 24;
      if (lcm_sym158__) {
        current_statement__ = 24;
        assign(b, cons_list(index_uni(1), nil_index_list()), lcm_sym214__,
          "assigning variable b");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 24;
          assign(b, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym214__, "assigning variable b");}
      } 
      int Nsuper;
      
      current_statement__ = 26;
      validate_non_negative_index("N", "n_occasions", n_occasions);
      std::vector<int> N;
      N = std::vector<int>(n_occasions, 0);
      
      current_statement__ = 27;
      validate_non_negative_index("B", "n_occasions", n_occasions);
      std::vector<int> B;
      B = std::vector<int>(n_occasions, 0);
      
      current_statement__ = 28;
      validate_non_negative_index("z", "M", M);
      current_statement__ = 28;
      validate_non_negative_index("z", "n_occasions", n_occasions);
      std::vector<std::vector<int>> z;
      z = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, 0));
      
      current_statement__ = 37;
      if (lcm_sym157__) {
        int q;
        
        double mu2;
        
        lcm_sym186__ = gamma[(1 - 1)];
        assign(z,
          cons_list(index_uni(1), cons_list(index_uni(1), nil_index_list())),
          bernoulli_rng(lcm_sym186__, base_rng__), "assigning variable z");
        lcm_sym159__ = logical_gte(n_occasions, 2);
        if (lcm_sym159__) {
          lcm_sym235__ = z[(1 - 1)][(1 - 1)];
          lcm_sym181__ = (1 * (1 - lcm_sym235__));
          q = lcm_sym181__;
          lcm_sym193__ = stan::math::fma(
                           rvalue(phi,
                             cons_list(index_uni(1),
                               cons_list(index_uni(1), nil_index_list())),
                             "phi"), lcm_sym235__,
                           (gamma[(2 - 1)] * lcm_sym181__));
          current_statement__ = 31;
          assign(z,
            cons_list(index_uni(1),
              cons_list(index_uni(2), nil_index_list())),
            bernoulli_rng(lcm_sym193__, base_rng__), "assigning variable z");
          for (size_t t = 3; t <= n_occasions; ++t) {
            current_statement__ = 32;
            q = (q * (1 - z[(1 - 1)][((t - 1) - 1)]));
            lcm_sym194__ = stan::math::fma(
                             rvalue(phi,
                               cons_list(index_uni(1),
                                 cons_list(index_uni((t - 1)),
                                   nil_index_list())), "phi"),
                             z[(1 - 1)][((t - 1) - 1)], (gamma[(t - 1)] * q));
            current_statement__ = 31;
            assign(z,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())),
              bernoulli_rng(lcm_sym194__, base_rng__), "assigning variable z");
          }
        } 
        for (size_t i = 2; i <= M; ++i) {
          int q;
          
          double mu2;
          
          current_statement__ = 34;
          assign(z,
            cons_list(index_uni(i),
              cons_list(index_uni(1), nil_index_list())),
            bernoulli_rng(lcm_sym186__, base_rng__), "assigning variable z");
          current_statement__ = 35;
          if (lcm_sym159__) {
            lcm_sym180__ = (1 * (1 - z[(i - 1)][(1 - 1)]));
            q = lcm_sym180__;
            lcm_sym191__ = stan::math::fma(
                             rvalue(phi,
                               cons_list(index_uni(i),
                                 cons_list(index_uni(1), nil_index_list())),
                               "phi"), z[(i - 1)][(1 - 1)],
                             (gamma[(2 - 1)] * lcm_sym180__));
            current_statement__ = 31;
            assign(z,
              cons_list(index_uni(i),
                cons_list(index_uni(2), nil_index_list())),
              bernoulli_rng(lcm_sym191__, base_rng__), "assigning variable z");
            for (size_t t = 3; t <= n_occasions; ++t) {
              current_statement__ = 32;
              q = (q * (1 - z[(i - 1)][((t - 1) - 1)]));
              lcm_sym192__ = stan::math::fma(
                               rvalue(phi,
                                 cons_list(index_uni(i),
                                   cons_list(index_uni((t - 1)),
                                     nil_index_list())), "phi"),
                               z[(i - 1)][((t - 1) - 1)],
                               (gamma[(t - 1)] * q));
              current_statement__ = 31;
              assign(z,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())),
                bernoulli_rng(lcm_sym192__, base_rng__),
                "assigning variable z");}
          } }
      } 
      {
        current_statement__ = 38;
        validate_non_negative_index("cprob", "n_occasions", n_occasions);
        Eigen::Matrix<double, -1, 1> cprob;
        cprob = Eigen::Matrix<double, -1, 1>(n_occasions);
        
        Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym13__;
        int inline_sym19__;
        
        inline_sym19__ = 0;
        for (size_t inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
          int inline_sym14__;
          
          lcm_sym199__ = rows(gamma);
          current_statement__ = 40;
          validate_non_negative_index("log_cprob", "N", lcm_sym199__);
          Eigen::Matrix<local_scalar_t__, -1, 1> inline_sym15__;
          inline_sym15__ = Eigen::Matrix<local_scalar_t__, -1, 1>(lcm_sym199__);
          
          lcm_sym163__ = logical_gte(lcm_sym199__, 1);
          if (lcm_sym163__) {
            current_statement__ = 40;
            assign(inline_sym15__, cons_list(index_uni(1), nil_index_list()),
              lcm_sym214__, "assigning variable inline_sym15__");
            for (size_t inline_sym16__ = 2; inline_sym16__ <= lcm_sym199__;
                 ++inline_sym16__) {
              current_statement__ = 40;
              assign(inline_sym15__,
                cons_list(index_uni(inline_sym16__), nil_index_list()),
                lcm_sym214__, "assigning variable inline_sym15__");}
          } 
          if (inline_sym19__) {
            break;
          } 
          local_scalar_t__ inline_sym17__;
          
          if (lcm_sym163__) {
            lcm_sym186__ = gamma[(1 - 1)];
            assign(inline_sym15__, cons_list(index_uni(1), nil_index_list()),
              (stan::math::log(lcm_sym186__) + 0),
              "assigning variable inline_sym15__");
            current_statement__ = 42;
            inline_sym17__ = (0 + log1m(lcm_sym186__));
            for (size_t inline_sym18__ = 2; inline_sym18__ <= lcm_sym199__;
                 ++inline_sym18__) {
              current_statement__ = 43;
              assign(inline_sym15__,
                cons_list(index_uni(inline_sym18__), nil_index_list()),
                (stan::math::log(gamma[(inline_sym18__ - 1)]) +
                  inline_sym17__), "assigning variable inline_sym15__");
              current_statement__ = 42;
              inline_sym17__ = (inline_sym17__ +
                                 log1m(gamma[(inline_sym18__ - 1)]));}
          } 
          if (inline_sym19__) {
            break;
          } 
          inline_sym19__ = 1;
          assign(inline_sym13__, nil_index_list(),
            stan::math::exp(inline_sym15__),
            "assigning variable inline_sym13__");
          break;}
        current_statement__ = 46;
        validate_non_negative_index("recruit", "M", M);
        current_statement__ = 46;
        validate_non_negative_index("recruit", "n_occasions", n_occasions);
        std::vector<std::vector<int>> recruit;
        recruit = std::vector<std::vector<int>>(M, std::vector<int>(n_occasions, 0));
        
        current_statement__ = 46;
        assign(recruit, nil_index_list(), rep_array(0, M, n_occasions),
          "assigning variable recruit");
        current_statement__ = 47;
        validate_non_negative_index("Nind", "M", M);
        std::vector<int> Nind;
        Nind = std::vector<int>(M, 0);
        
        current_statement__ = 48;
        validate_non_negative_index("Nalive", "M", M);
        std::vector<int> Nalive;
        Nalive = std::vector<int>(M, 0);
        
        lcm_sym203__ = square(sigma);
        sigma2 = lcm_sym203__;
        lcm_sym205__ = sum(inline_sym13__);
        psi = lcm_sym205__;
        assign(lcm_sym156__, nil_index_list(),
          divide(inline_sym13__, lcm_sym205__),
          "assigning variable lcm_sym156__");
        assign(b, nil_index_list(), lcm_sym156__, "assigning variable b");
        current_statement__ = 56;
        if (lcm_sym157__) {
          int f;
          
          int inline_sym21__;
          int inline_sym23__;
          
          inline_sym23__ = 0;
          for (size_t inline_sym24__ = 1; inline_sym24__ <= 1;
               ++inline_sym24__) {
            lcm_sym202__ = size(z[(1 - 1)]);
            for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym202__;
                 ++inline_sym22__) {
              current_statement__ = 51;
              if (z[(1 - 1)][(inline_sym22__ - 1)]) {
                inline_sym23__ = 1;
                inline_sym21__ = inline_sym22__;
                break;
              } }
            if (inline_sym23__) {
              break;
            } 
            inline_sym23__ = 1;
            inline_sym21__ = 0;
            break;}
          current_statement__ = 54;
          if (logical_gt(inline_sym21__, 0)) {
            current_statement__ = 53;
            assign(recruit,
              cons_list(index_uni(1),
                cons_list(index_uni(inline_sym21__), nil_index_list())), 1,
              "assigning variable recruit");
          } 
          for (size_t i = 2; i <= M; ++i) {
            int f;
            
            int inline_sym21__;
            int inline_sym23__;
            
            inline_sym23__ = 0;
            for (size_t inline_sym24__ = 1; inline_sym24__ <= 1;
                 ++inline_sym24__) {
              lcm_sym201__ = size(z[(i - 1)]);
              for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym201__;
                   ++inline_sym22__) {
                current_statement__ = 51;
                if (z[(i - 1)][(inline_sym22__ - 1)]) {
                  inline_sym23__ = 1;
                  inline_sym21__ = inline_sym22__;
                  break;
                } }
              if (inline_sym23__) {
                break;
              } 
              inline_sym23__ = 1;
              inline_sym21__ = 0;
              break;}
            current_statement__ = 54;
            if (logical_gt(inline_sym21__, 0)) {
              current_statement__ = 53;
              assign(recruit,
                cons_list(index_uni(i),
                  cons_list(index_uni(inline_sym21__), nil_index_list())), 1,
                "assigning variable recruit");
            } }
        } 
        current_statement__ = 60;
        if (lcm_sym158__) {
          current_statement__ = 57;
          assign(N, cons_list(index_uni(1), nil_index_list()),
            sum(
              rvalue(z,
                cons_list(index_omni(),
                  cons_list(index_uni(1), nil_index_list())), "z")),
            "assigning variable N");
          current_statement__ = 58;
          assign(B, cons_list(index_uni(1), nil_index_list()),
            sum(
              rvalue(recruit,
                cons_list(index_omni(),
                  cons_list(index_uni(1), nil_index_list())), "recruit")),
            "assigning variable B");
          for (size_t t = 2; t <= n_occasions; ++t) {
            current_statement__ = 57;
            assign(N, cons_list(index_uni(t), nil_index_list()),
              sum(
                rvalue(z,
                  cons_list(index_omni(),
                    cons_list(index_uni(t), nil_index_list())), "z")),
              "assigning variable N");
            current_statement__ = 58;
            assign(B, cons_list(index_uni(t), nil_index_list()),
              sum(
                rvalue(recruit,
                  cons_list(index_omni(),
                    cons_list(index_uni(t), nil_index_list())), "recruit")),
              "assigning variable B");}
        } 
        current_statement__ = 64;
        if (lcm_sym157__) {
          current_statement__ = 61;
          assign(Nind, cons_list(index_uni(1), nil_index_list()),
            sum(z[(1 - 1)]), "assigning variable Nind");
          current_statement__ = 62;
          assign(Nalive, cons_list(index_uni(1), nil_index_list()),
            (1 - logical_negation(Nind[(1 - 1)])),
            "assigning variable Nalive");
          for (size_t i = 2; i <= M; ++i) {
            current_statement__ = 61;
            assign(Nind, cons_list(index_uni(i), nil_index_list()),
              sum(z[(i - 1)]), "assigning variable Nind");
            current_statement__ = 62;
            assign(Nalive, cons_list(index_uni(i), nil_index_list()),
              (1 - logical_negation(Nind[(i - 1)])),
              "assigning variable Nalive");}
        } 
        current_statement__ = 65;
        Nsuper = sum(Nalive);
      }
      vars__.push_back(lcm_sym203__);
      vars__.push_back(lcm_sym205__);
      if (lcm_sym158__) {
        vars__.push_back(lcm_sym156__[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(lcm_sym156__[(sym1__ - 1)]);}
      } 
      vars__.push_back(Nsuper);
      if (lcm_sym158__) {
        vars__.push_back(N[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(N[(sym1__ - 1)]);}
      } 
      if (lcm_sym158__) {
        vars__.push_back(B[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(B[(sym1__ - 1)]);}
      } 
      if (lcm_sym158__) {
        if (lcm_sym157__) {
          vars__.push_back(z[(1 - 1)][(1 - 1)]);
          for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
            vars__.push_back(z[(sym2__ - 1)][(1 - 1)]);}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym157__) {
            vars__.push_back(z[(1 - 1)][(sym1__ - 1)]);
            for (size_t sym2__ = 2; sym2__ <= M; ++sym2__) {
              vars__.push_back(z[(sym2__ - 1)][(sym1__ - 1)]);}
          } }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym155__;
      double lcm_sym154__;
      double lcm_sym153__;
      double lcm_sym152__;
      double lcm_sym151__;
      double lcm_sym150__;
      double lcm_sym149__;
      double lcm_sym148__;
      int lcm_sym145__;
      int lcm_sym144__;
      int lcm_sym143__;
      int lcm_sym142__;
      int pos__;
      
      pos__ = 1;
      double mean_phi;
      
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      current_statement__ = 1;
      mean_phi = stan::math::lub_free(mean_phi, 0, 1);
      double mean_p;
      
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      current_statement__ = 2;
      mean_p = stan::math::lub_free(mean_p, 0, 1);
      current_statement__ = 3;
      validate_non_negative_index("gamma", "n_occasions", n_occasions);
      Eigen::Matrix<double, -1, 1> gamma;
      gamma = Eigen::Matrix<double, -1, 1>(n_occasions);
      
      {
        std::vector<double> gamma_flat__;
        current_statement__ = 3;
        assign(gamma_flat__, nil_index_list(), context__.vals_r("gamma"),
          "assigning variable gamma_flat__");
        current_statement__ = 3;
        pos__ = 1;
        lcm_sym142__ = logical_gte(n_occasions, 1);
        if (lcm_sym142__) {
          current_statement__ = 3;
          assign(gamma, cons_list(index_uni(1), nil_index_list()),
            gamma_flat__[(1 - 1)], "assigning variable gamma");
          current_statement__ = 3;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
            current_statement__ = 3;
            assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
              gamma_flat__[(pos__ - 1)], "assigning variable gamma");
            current_statement__ = 3;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 3;
      if (lcm_sym142__) {
        current_statement__ = 3;
        assign(gamma, cons_list(index_uni(1), nil_index_list()),
          stan::math::lub_free(gamma[(1 - 1)], 0, 1),
          "assigning variable gamma");
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          current_statement__ = 3;
          assign(gamma, cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lub_free(gamma[(sym1__ - 1)], 0, 1),
            "assigning variable gamma");}
      } 
      lcm_sym144__ = (n_occasions - 1);
      validate_non_negative_index("epsilon", "(n_occasions - 1)",
                                  lcm_sym144__);
      Eigen::Matrix<double, -1, 1> epsilon;
      epsilon = Eigen::Matrix<double, -1, 1>(lcm_sym144__);
      
      {
        std::vector<double> epsilon_flat__;
        current_statement__ = 4;
        assign(epsilon_flat__, nil_index_list(), context__.vals_r("epsilon"),
          "assigning variable epsilon_flat__");
        current_statement__ = 4;
        pos__ = 1;
        lcm_sym143__ = logical_gte(lcm_sym144__, 1);
        if (lcm_sym143__) {
          current_statement__ = 4;
          assign(epsilon, cons_list(index_uni(1), nil_index_list()),
            epsilon_flat__[(1 - 1)], "assigning variable epsilon");
          current_statement__ = 4;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= lcm_sym144__; ++sym1__) {
            current_statement__ = 4;
            assign(epsilon, cons_list(index_uni(sym1__), nil_index_list()),
              epsilon_flat__[(pos__ - 1)], "assigning variable epsilon");
            current_statement__ = 4;
            pos__ = (pos__ + 1);}
        } 
      }
      double sigma;
      
      current_statement__ = 5;
      sigma = context__.vals_r("sigma")[(1 - 1)];
      current_statement__ = 5;
      sigma = stan::math::lub_free(sigma, 0, 5);
      vars__.push_back(mean_phi);
      vars__.push_back(mean_p);
      if (lcm_sym142__) {
        vars__.push_back(gamma[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          vars__.push_back(gamma[(sym1__ - 1)]);}
      } 
      if (lcm_sym143__) {
        vars__.push_back(epsilon[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= lcm_sym144__; ++sym1__) {
          vars__.push_back(epsilon[(sym1__ - 1)]);}
      } 
      vars__.push_back(sigma);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mean_phi");
    names__.push_back("mean_p");
    names__.push_back("gamma");
    names__.push_back("epsilon");
    names__.push_back("sigma");
    names__.push_back("phi");
    names__.push_back("p");
    names__.push_back("chi");
    names__.push_back("sigma2");
    names__.push_back("psi");
    names__.push_back("b");
    names__.push_back("Nsuper");
    names__.push_back("N");
    names__.push_back("B");
    names__.push_back("z");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back((n_occasions - 1));
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    
    dims__.push_back((n_occasions - 1));
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(M);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_phi");
    param_names__.push_back(std::string() + "mean_p");
    for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
      {
        param_names__.push_back(std::string() + "gamma" + '.' + std::to_string(sym344__));
      }}
    for (size_t sym344__ = 1; sym344__ <= (n_occasions - 1); ++sym344__) {
      {
        param_names__.push_back(std::string() + "epsilon" + '.' + std::to_string(sym344__));
      }}
    param_names__.push_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (size_t sym344__ = 1; sym344__ <= (n_occasions - 1); ++sym344__) {
        {
          for (size_t sym345__ = 1; sym345__ <= M; ++sym345__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym345__) + '.' + std::to_string(sym344__));
            }}
        }}
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          for (size_t sym345__ = 1; sym345__ <= M; ++sym345__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym345__) + '.' + std::to_string(sym344__));
            }}
        }}
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          for (size_t sym345__ = 1; sym345__ <= M; ++sym345__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym345__) + '.' + std::to_string(sym344__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "sigma2");
      param_names__.push_back(std::string() + "psi");
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          param_names__.push_back(std::string() + "b" + '.' + std::to_string(sym344__));
        }}
      param_names__.push_back(std::string() + "Nsuper");
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          param_names__.push_back(std::string() + "N" + '.' + std::to_string(sym344__));
        }}
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          param_names__.push_back(std::string() + "B" + '.' + std::to_string(sym344__));
        }}
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          for (size_t sym345__ = 1; sym345__ <= M; ++sym345__) {
            {
              param_names__.push_back(std::string() + "z" + '.' + std::to_string(sym345__) + '.' + std::to_string(sym344__));
            }}
        }}
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_phi");
    param_names__.push_back(std::string() + "mean_p");
    for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
      {
        param_names__.push_back(std::string() + "gamma" + '.' + std::to_string(sym344__));
      }}
    for (size_t sym344__ = 1; sym344__ <= (n_occasions - 1); ++sym344__) {
      {
        param_names__.push_back(std::string() + "epsilon" + '.' + std::to_string(sym344__));
      }}
    param_names__.push_back(std::string() + "sigma");
    if (emit_transformed_parameters__) {
      for (size_t sym344__ = 1; sym344__ <= (n_occasions - 1); ++sym344__) {
        {
          for (size_t sym345__ = 1; sym345__ <= M; ++sym345__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym345__) + '.' + std::to_string(sym344__));
            }}
        }}
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          for (size_t sym345__ = 1; sym345__ <= M; ++sym345__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym345__) + '.' + std::to_string(sym344__));
            }}
        }}
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          for (size_t sym345__ = 1; sym345__ <= M; ++sym345__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym345__) + '.' + std::to_string(sym344__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "sigma2");
      param_names__.push_back(std::string() + "psi");
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          param_names__.push_back(std::string() + "b" + '.' + std::to_string(sym344__));
        }}
      param_names__.push_back(std::string() + "Nsuper");
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          param_names__.push_back(std::string() + "N" + '.' + std::to_string(sym344__));
        }}
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          param_names__.push_back(std::string() + "B" + '.' + std::to_string(sym344__));
        }}
      for (size_t sym344__ = 1; sym344__ <= n_occasions; ++sym344__) {
        {
          for (size_t sym345__ = 1; sym345__ <= M; ++sym345__) {
            {
              param_names__.push_back(std::string() + "z" + '.' + std::to_string(sym345__) + '.' + std::to_string(sym344__));
            }}
        }}
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << (n_occasions - 1) << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << (n_occasions - 1) << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"gamma\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"parameters\"},{\"name\":\"epsilon\",\"type\":{\"name\":\"vector\",\"length\":" << (n_occasions - 1) << "},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << (n_occasions - 1) << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << M << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"},{\"name\":\"sigma2\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"psi\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"},{\"name\":\"b\",\"type\":{\"name\":\"vector\",\"length\":" << n_occasions << "},\"block\":\"generated_quantities\"},{\"name\":\"Nsuper\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"N\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"B\",\"type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << M << ",\"element_type\":{\"name\":\"array\",\"length\":" << n_occasions << ",\"element_type\":{\"name\":\"int\"}}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef inlining_fail2_model_namespace::inlining_fail2_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp lcm-experiment.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lcm-experiment.stan', line 2, column 2 to column 8)",
                                                      " (in 'lcm-experiment.stan', line 5, column 2 to column 13)",
                                                      " (in 'lcm-experiment.stan', line 6, column 2 to column 9)",
                                                      " (in 'lcm-experiment.stan', line 8, column 4 to column 27)",
                                                      " (in 'lcm-experiment.stan', line 7, column 2 to line 10, column 3)",
                                                      " (in 'lcm-experiment.stan', line 11, column 2 to column 38)"};



class lcm_experiment_model : public model_base_crtp<lcm_experiment_model> {

 private:
  double lcm_sym4__;
  double lcm_sym3__;
  int pos__;
  int j;
  double z;
  double x;
  double i;
 
 public:
  ~lcm_experiment_model() { }
  
  std::string model_name() const { return "lcm_experiment_model"; }
  
  lcm_experiment_model(stan::io::var_context& context__,
                       unsigned int random_seed__ = 0,
                       std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lcm_experiment_model_namespace::lcm_experiment_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","j","int",
          context__.to_vec());
      
      current_statement__ = 1;
      j = context__.vals_i("j")[(1 - 1)];
      
      lcm_sym4__ = std::numeric_limits<double>::quiet_NaN();
      z = lcm_sym4__;
      current_statement__ = 2;
      z = 1;
      
      current_statement__ = 3;
      x = lcm_sym4__;
      {
        current_statement__ = 4;
        x = normal_rng(123, 1, base_rng__);
        lcm_sym3__ = stan::math::fma(stan::math::sqrt(j), 2, 1);
        z = normal_rng(lcm_sym3__, 1, base_rng__);
      }
      
      current_statement__ = 6;
      i = lcm_sym4__;
      current_statement__ = 6;
      i = normal_rng(lcm_sym3__, 1, base_rng__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lcm_experiment_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lcm_experiment_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef lcm_experiment_model_namespace::lcm_experiment_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp lcm-experiment2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_experiment2_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lcm-experiment2.stan', line 2, column 2 to column 9)",
                                                      " (in 'lcm-experiment2.stan', line 5, column 2 to column 18)",
                                                      " (in 'lcm-experiment2.stan', line 7, column 4 to column 11)",
                                                      " (in 'lcm-experiment2.stan', line 6, column 2 to line 8, column 3)",
                                                      " (in 'lcm-experiment2.stan', line 10, column 4 to column 11)",
                                                      " (in 'lcm-experiment2.stan', line 9, column 2 to line 10, column 11)",
                                                      " (in 'lcm-experiment2.stan', line 11, column 2 to column 14)"};



class lcm_experiment2_model : public model_base_crtp<lcm_experiment2_model> {

 private:
  int pos__;
 
 public:
  ~lcm_experiment2_model() { }
  
  std::string model_name() const { return "lcm_experiment2_model"; }
  
  lcm_experiment2_model(stan::io::var_context& context__,
                        unsigned int random_seed__ = 0,
                        std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lcm_experiment2_model_namespace::lcm_experiment2_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lcm_experiment2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      local_scalar_t__ lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      local_scalar_t__ x;
      
      current_statement__ = 1;
      x = in__.scalar();
      {
        local_scalar_t__ y;
        
        lcm_sym5__ = stan::math::log(x);
        {
          current_statement__ = 3;
          y = (lcm_sym5__ + 1);
        }
        {
          current_statement__ = 5;
          y = (y + 1);
        }
        current_statement__ = 7;
        lp_accum__.add(y);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lcm_experiment2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      int lcm_sym2__;
      int lcm_sym1__;
      double x;
      
      current_statement__ = 1;
      x = in__.scalar();
      vars__.push_back(x);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      
      pos__ = 1;
      double x;
      
      current_statement__ = 1;
      x = context__.vals_r("x")[(1 - 1)];
      vars__.push_back(x);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("x");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "x");
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef lcm_experiment2_model_namespace::lcm_experiment2_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp lcm-fails.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lcm-fails.stan', line 6, column 2 to column 16)",
                                                      " (in 'lcm-fails.stan', line 9, column 2 to column 22)",
                                                      " (in 'lcm-fails.stan', line 2, column 2 to column 17)",
                                                      " (in 'lcm-fails.stan', line 3, column 2 to column 12)"};



class lcm_fails_model : public model_base_crtp<lcm_fails_model> {

 private:
  int pos__;
  int J;
  std::vector<double> y;
 
 public:
  ~lcm_fails_model() { }
  
  std::string model_name() const { return "lcm_fails_model"; }
  
  lcm_fails_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lcm_fails_model_namespace::lcm_fails_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      pos__ = 1;
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      
      current_statement__ = 3;
      J = context__.vals_i("J")[(1 - 1)];
      current_statement__ = 4;
      validate_non_negative_index("y", "J", J);
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(J));
      y = std::vector<double>(J, 0);
      
      current_statement__ = 4;
      assign(y, nil_index_list(), context__.vals_r("y"),
        "assigning variable y");
      current_statement__ = 3;
      current_statement__ = 3;
      check_greater_or_equal(function__, "J", J, 0);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("theta", "J", J);
      num_params_r__ += J;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lcm_fails_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym10__;
      int lcm_sym9__;
      current_statement__ = 1;
      validate_non_negative_index("theta", "J", J);
      std::vector<local_scalar_t__> theta;
      theta = std::vector<local_scalar_t__>(J, 0);
      
      current_statement__ = 1;
      if (logical_gte(J, 1)) {
        current_statement__ = 1;
        assign(theta, cons_list(index_uni(1), nil_index_list()),
          in__.scalar(), "assigning variable theta");
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 1;
          assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
            in__.scalar(), "assigning variable theta");}
      } 
      {
        current_statement__ = 2;
        lp_accum__.add(normal_log<propto__>(y, theta, 1));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lcm_fails_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym8__;
      double lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      current_statement__ = 1;
      validate_non_negative_index("theta", "J", J);
      std::vector<double> theta;
      theta = std::vector<double>(J, 0);
      
      lcm_sym4__ = logical_gte(J, 1);
      if (lcm_sym4__) {
        current_statement__ = 1;
        assign(theta, cons_list(index_uni(1), nil_index_list()),
          in__.scalar(), "assigning variable theta");
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 1;
          assign(theta, cons_list(index_uni(sym1__), nil_index_list()),
            in__.scalar(), "assigning variable theta");}
      } 
      if (lcm_sym4__) {
        vars__.push_back(theta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(theta[(sym1__ - 1)]);}
      } 
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym3__;
      double lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("theta", "J", J);
      std::vector<double> theta;
      theta = std::vector<double>(J, 0);
      
      current_statement__ = 1;
      assign(theta, nil_index_list(), context__.vals_r("theta"),
        "assigning variable theta");
      if (logical_gte(J, 1)) {
        vars__.push_back(theta[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(theta[(sym1__ - 1)]);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("theta");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(J);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    for (size_t sym11__ = 1; sym11__ <= J; ++sym11__) {
      {
        param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym11__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    for (size_t sym11__ = 1; sym11__ <= J; ++sym11__) {
      {
        param_names__.push_back(std::string() + "theta" + '.' + std::to_string(sym11__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << J << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef lcm_fails_model_namespace::lcm_fails_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp lcm-fails2.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lcm_fails2_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lcm-fails2.stan', line 69, column 2 to column 33)",
                                                      " (in 'lcm-fails2.stan', line 70, column 2 to column 31)",
                                                      " (in 'lcm-fails2.stan', line 74, column 2 to column 51)",
                                                      " (in 'lcm-fails2.stan', line 75, column 2 to column 49)",
                                                      " (in 'lcm-fails2.stan', line 76, column 2 to column 49)",
                                                      " (in 'lcm-fails2.stan', line 81, column 6 to column 20)",
                                                      " (in 'lcm-fails2.stan', line 82, column 6 to column 18)",
                                                      " (in 'lcm-fails2.stan', line 80, column 32 to line 83, column 5)",
                                                      " (in 'lcm-fails2.stan', line 85, column 6 to column 27)",
                                                      " (in 'lcm-fails2.stan', line 86, column 6 to column 23)",
                                                      " (in 'lcm-fails2.stan', line 84, column 38 to line 87, column 5)",
                                                      " (in 'lcm-fails2.stan', line 84, column 4 to line 87, column 5)",
                                                      " (in 'lcm-fails2.stan', line 79, column 20 to line 88, column 3)",
                                                      " (in 'lcm-fails2.stan', line 79, column 2 to line 88, column 3)",
                                                      " (in 'lcm-fails2.stan', line 26, column 4 to column 34)",
                                                      " (in 'lcm-fails2.stan', line 29, column 6 to column 32)",
                                                      " (in 'lcm-fails2.stan', line 32, column 8 to column 37)",
                                                      " (in 'lcm-fails2.stan', line 33, column 8 to column 32)",
                                                      " (in 'lcm-fails2.stan', line 41, column 8 to line 42, column 83)",
                                                      " (in 'lcm-fails2.stan', line 30, column 37 to line 43, column 7)",
                                                      " (in 'lcm-fails2.stan', line 28, column 22 to line 44, column 5)",
                                                      " (in 'lcm-fails2.stan', line 25, column 47 to line 46, column 3)",
                                                      " (in 'lcm-fails2.stan', line 103, column 8 to column 37)",
                                                      " (in 'lcm-fails2.stan', line 104, column 8 to column 41)",
                                                      " (in 'lcm-fails2.stan', line 102, column 40 to line 105, column 7)",
                                                      " (in 'lcm-fails2.stan', line 106, column 6 to column 37)",
                                                      " (in 'lcm-fails2.stan', line 101, column 22 to line 107, column 5)",
                                                      " (in 'lcm-fails2.stan', line 100, column 20 to line 108, column 3)",
                                                      " (in 'lcm-fails2.stan', line 100, column 2 to line 108, column 3)",
                                                      " (in 'lcm-fails2.stan', line 50, column 2 to column 20)",
                                                      " (in 'lcm-fails2.stan', line 51, column 2 to column 27)",
                                                      " (in 'lcm-fails2.stan', line 52, column 2 to column 44)",
                                                      " (in 'lcm-fails2.stan', line 56, column 2 to column 38)",
                                                      " (in 'lcm-fails2.stan', line 58, column 2 to column 45)",
                                                      " (in 'lcm-fails2.stan', line 59, column 2 to column 44)",
                                                      " (in 'lcm-fails2.stan', line 8, column 8 to column 17)",
                                                      " (in 'lcm-fails2.stan', line 7, column 6 to line 8, column 17)",
                                                      " (in 'lcm-fails2.stan', line 5, column 31 to line 10, column 3)",
                                                      " (in 'lcm-fails2.stan', line 63, column 4 to column 35)",
                                                      " (in 'lcm-fails2.stan', line 62, column 2 to line 63, column 35)",
                                                      " (in 'lcm-fails2.stan', line 15, column 6 to column 32)",
                                                      " (in 'lcm-fails2.stan', line 19, column 8 to column 17)",
                                                      " (in 'lcm-fails2.stan', line 18, column 6 to line 19, column 17)",
                                                      " (in 'lcm-fails2.stan', line 13, column 37 to line 20, column 5)",
                                                      " (in 'lcm-fails2.stan', line 12, column 30 to line 22, column 3)",
                                                      " (in 'lcm-fails2.stan', line 65, column 4 to column 33)",
                                                      " (in 'lcm-fails2.stan', line 64, column 2 to line 65, column 33)",
                                                      " (in 'lcm-fails2.stan', line 9, column 4 to column 13)",
                                                      " (in 'lcm-fails2.stan', line 21, column 4 to column 13)",
                                                      " (in 'lcm-fails2.stan', line 30, column 6 to line 43, column 7)",
                                                      " (in 'lcm-fails2.stan', line 28, column 4 to line 44, column 5)",
                                                      " (in 'lcm-fails2.stan', line 45, column 4 to column 15)"};


int
first_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym33__;
    int lcm_sym32__;
    int lcm_sym31__;
    int lcm_sym30__;
    {
      lcm_sym31__ = size(y_i);
      if (logical_gte(lcm_sym31__, 1)) {
        current_statement__ = 37;
        if (y_i[(1 - 1)]) {
          current_statement__ = 36;
          return 1;
        } 
        for (size_t k = 2; k <= lcm_sym31__; ++k) {
          current_statement__ = 37;
          if (y_i[(k - 1)]) {
            current_statement__ = 36;
            return k;
          } }
      } 
      current_statement__ = 48;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct first_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return first_capture(y_i, pstream__);
}
};

int
last_capture(const std::vector<int>& y_i, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym39__;
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    int lcm_sym35__;
    int lcm_sym34__;
    {
      lcm_sym37__ = (size(y_i) - 1);
      if (logical_gte(lcm_sym37__, 0)) {
        int k;
        
        lcm_sym36__ = (size(y_i) - 0);
        current_statement__ = 43;
        if (y_i[(lcm_sym36__ - 1)]) {
          current_statement__ = 42;
          return lcm_sym36__;
        } 
        for (size_t k_rev = 1; k_rev <= lcm_sym37__; ++k_rev) {
          int k;
          
          lcm_sym35__ = (size(y_i) - k_rev);
          current_statement__ = 43;
          if (y_i[(lcm_sym35__ - 1)]) {
            current_statement__ = 42;
            return lcm_sym35__;
          } }
      } 
      current_statement__ = 49;
      return 0;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct last_capture_functor__ {
int
operator()(const std::vector<int>& y_i, std::ostream* pstream__)  const 
{
return last_capture(y_i, pstream__);
}
};

template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__,
T3__>::type, -1, -1>
prob_uncaptured(const int& nind, const int& n_occasions,
                const Eigen::Matrix<T2__, -1, -1>& p,
                const Eigen::Matrix<T3__, -1, -1>& phi,
                std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T2__,
          T3__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    double lcm_sym51__;
    double lcm_sym50__;
    double lcm_sym49__;
    double lcm_sym48__;
    double lcm_sym47__;
    int lcm_sym46__;
    int lcm_sym45__;
    int lcm_sym44__;
    int lcm_sym43__;
    int lcm_sym42__;
    int lcm_sym41__;
    int lcm_sym40__;
    {
      current_statement__ = 15;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 15;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      lcm_sym41__ = logical_gte(nind, 1);
      if (lcm_sym41__) {
        lcm_sym40__ = logical_gte(n_occasions, 1);
        if (lcm_sym40__) {
          lcm_sym51__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym51__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 15;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym51__,
              "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 15;
          if (lcm_sym40__) {
            lcm_sym51__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym51__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 15;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym51__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 51;
      if (lcm_sym41__) {
        current_statement__ = 16;
        assign(chi,
          cons_list(index_uni(1),
            cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
          "assigning variable chi");
        lcm_sym44__ = (n_occasions - 1);
        lcm_sym42__ = logical_gte(lcm_sym44__, 1);
        if (lcm_sym42__) {
          int t_curr;
          
          int t_next;
          
          lcm_sym46__ = (lcm_sym44__ + 1);
          current_statement__ = 19;
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym44__), nil_index_list())),
            stan::math::fma(
              (rvalue(phi,
                 cons_list(index_uni(1),
                   cons_list(index_uni(lcm_sym44__), nil_index_list())),
                 "phi") *
                (1 -
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym46__ - 1)),
                        nil_index_list())), "p"))),
              rvalue(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(lcm_sym46__), nil_index_list())),
                "chi"),
              (1 -
                rvalue(phi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym44__), nil_index_list())),
                  "phi"))), "assigning variable chi");
          for (size_t t = 2; t <= lcm_sym44__; ++t) {
            int t_curr;
            
            lcm_sym43__ = (n_occasions - t);
            int t_next;
            
            lcm_sym45__ = (lcm_sym43__ + 1);
            current_statement__ = 19;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(lcm_sym43__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(1),
                     cons_list(index_uni(lcm_sym43__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((lcm_sym45__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(chi,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym45__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni(lcm_sym43__), nil_index_list())),
                    "phi"))), "assigning variable chi");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          current_statement__ = 16;
          assign(chi,
            cons_list(index_uni(i),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable chi");
          current_statement__ = 50;
          if (lcm_sym42__) {
            int t_curr;
            
            int t_next;
            
            lcm_sym46__ = (lcm_sym44__ + 1);
            current_statement__ = 19;
            assign(chi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym44__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(i),
                     cons_list(index_uni(lcm_sym44__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym46__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(chi,
                  cons_list(index_uni(i),
                    cons_list(index_uni(lcm_sym46__), nil_index_list())),
                  "chi"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym44__), nil_index_list())),
                    "phi"))), "assigning variable chi");
            for (size_t t = 2; t <= lcm_sym44__; ++t) {
              int t_curr;
              
              lcm_sym43__ = (n_occasions - t);
              int t_next;
              
              lcm_sym45__ = (lcm_sym43__ + 1);
              current_statement__ = 19;
              assign(chi,
                cons_list(index_uni(i),
                  cons_list(index_uni(lcm_sym43__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(i),
                       cons_list(index_uni(lcm_sym43__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni((lcm_sym45__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(chi,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym45__), nil_index_list())),
                    "chi"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni(lcm_sym43__), nil_index_list())),
                      "phi"))), "assigning variable chi");}
          } }
      } 
      current_statement__ = 52;
      return chi;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct prob_uncaptured_functor__ {
template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__,
T3__>::type, -1, -1>
operator()(const int& nind, const int& n_occasions,
           const Eigen::Matrix<T2__, -1, -1>& p,
           const Eigen::Matrix<T3__, -1, -1>& phi, std::ostream* pstream__)  const 
{
return prob_uncaptured(nind, n_occasions, p, phi, pstream__);
}
};

class lcm_fails2_model : public model_base_crtp<lcm_fails2_model> {

 private:
  int lcm_sym147__;
  int lcm_sym146__;
  int lcm_sym145__;
  int lcm_sym144__;
  int lcm_sym143__;
  int lcm_sym142__;
  int lcm_sym141__;
  int lcm_sym140__;
  int lcm_sym139__;
  int lcm_sym138__;
  int lcm_sym137__;
  int lcm_sym136__;
  int lcm_sym135__;
  int lcm_sym134__;
  int lcm_sym133__;
  int lcm_sym132__;
  int lcm_sym131__;
  int lcm_sym130__;
  int lcm_sym129__;
  int lcm_sym128__;
  int lcm_sym127__;
  int lcm_sym126__;
  int lcm_sym125__;
  int lcm_sym124__;
  int pos__;
  int nind;
  int n_occasions;
  std::vector<std::vector<int>> y;
  int n_occ_minus_1;
  std::vector<int> first;
  std::vector<int> last;
 
 public:
  ~lcm_fails2_model() { }
  
  std::string model_name() const { return "lcm_fails2_model"; }
  
  lcm_fails2_model(stan::io::var_context& context__,
                   unsigned int random_seed__ = 0,
                   std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "lcm_fails2_model_namespace::lcm_fails2_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","nind","int",
          context__.to_vec());
      
      current_statement__ = 30;
      nind = context__.vals_i("nind")[(1 - 1)];
      context__.validate_dims("data initialization","n_occasions","int",
          context__.to_vec());
      
      current_statement__ = 31;
      n_occasions = context__.vals_i("n_occasions")[(1 - 1)];
      current_statement__ = 32;
      validate_non_negative_index("y", "nind", nind);
      current_statement__ = 32;
      validate_non_negative_index("y", "n_occasions", n_occasions);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(nind, n_occasions));
      y = std::vector<std::vector<int>>(nind, std::vector<int>(n_occasions, 0));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 32;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 32;
        pos__ = 1;
        lcm_sym124__ = logical_gte(n_occasions, 1);
        if (lcm_sym124__) {
          {
            lcm_sym125__ = logical_gte(nind, 1);
            if (lcm_sym125__) {
              current_statement__ = 32;
              assign(y,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())),
                y_flat__[(1 - 1)], "assigning variable y");
              current_statement__ = 32;
              pos__ = 2;
              for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                current_statement__ = 32;
                assign(y,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(1), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 32;
                pos__ = (pos__ + 1);}
            } 
            for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
              current_statement__ = 32;
              if (lcm_sym125__) {
                current_statement__ = 32;
                assign(y,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 32;
                pos__ = (pos__ + 1);
                for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
                  current_statement__ = 32;
                  assign(y,
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list())),
                    y_flat__[(pos__ - 1)], "assigning variable y");
                  current_statement__ = 32;
                  pos__ = (pos__ + 1);}
              } }
          }
        } else {
          lcm_sym125__ = logical_gte(nind, 1);
        }
      }
      
      current_statement__ = 33;
      n_occ_minus_1 = (n_occasions - 1);
      current_statement__ = 34;
      validate_non_negative_index("first", "nind", nind);
      first = std::vector<int>(nind, 0);
      
      current_statement__ = 35;
      validate_non_negative_index("last", "nind", nind);
      last = std::vector<int>(nind, 0);
      
      current_statement__ = 40;
      if (lcm_sym125__) {
        int inline_sym21__;
        int inline_sym23__;
        
        inline_sym23__ = 0;
        for (size_t inline_sym24__ = 1; inline_sym24__ <= 1; ++inline_sym24__) {
          lcm_sym133__ = size(y[(1 - 1)]);
          for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym133__;
               ++inline_sym22__) {
            current_statement__ = 37;
            if (y[(1 - 1)][(inline_sym22__ - 1)]) {
              inline_sym23__ = 1;
              inline_sym21__ = inline_sym22__;
              break;
            } }
          if (inline_sym23__) {
            break;
          } 
          inline_sym23__ = 1;
          inline_sym21__ = 0;
          break;}
        assign(first, cons_list(index_uni(1), nil_index_list()),
          inline_sym21__, "assigning variable first");
        for (size_t i = 2; i <= nind; ++i) {
          int inline_sym21__;
          int inline_sym23__;
          
          inline_sym23__ = 0;
          for (size_t inline_sym24__ = 1; inline_sym24__ <= 1;
               ++inline_sym24__) {
            lcm_sym132__ = size(y[(i - 1)]);
            for (size_t inline_sym22__ = 1; inline_sym22__ <= lcm_sym132__;
                 ++inline_sym22__) {
              current_statement__ = 37;
              if (y[(i - 1)][(inline_sym22__ - 1)]) {
                inline_sym23__ = 1;
                inline_sym21__ = inline_sym22__;
                break;
              } }
            if (inline_sym23__) {
              break;
            } 
            inline_sym23__ = 1;
            inline_sym21__ = 0;
            break;}
          assign(first, cons_list(index_uni(i), nil_index_list()),
            inline_sym21__, "assigning variable first");}
      } 
      current_statement__ = 47;
      if (lcm_sym125__) {
        int inline_sym25__;
        int inline_sym28__;
        
        inline_sym28__ = 0;
        for (size_t inline_sym29__ = 1; inline_sym29__ <= 1; ++inline_sym29__) {
          lcm_sym133__ = size(y[(1 - 1)]);
          lcm_sym130__ = (lcm_sym133__ - 1);
          for (size_t inline_sym27__ = 0; inline_sym27__ <= lcm_sym130__;
               ++inline_sym27__) {
            int inline_sym26__;
            
            lcm_sym129__ = (lcm_sym133__ - inline_sym27__);
            inline_sym26__ = lcm_sym129__;
            current_statement__ = 43;
            if (y[(1 - 1)][(lcm_sym129__ - 1)]) {
              inline_sym28__ = 1;
              inline_sym25__ = lcm_sym129__;
              break;
            } }
          if (inline_sym28__) {
            break;
          } 
          inline_sym28__ = 1;
          inline_sym25__ = 0;
          break;}
        assign(last, cons_list(index_uni(1), nil_index_list()),
          inline_sym25__, "assigning variable last");
        for (size_t i = 2; i <= nind; ++i) {
          int inline_sym25__;
          int inline_sym28__;
          
          inline_sym28__ = 0;
          for (size_t inline_sym29__ = 1; inline_sym29__ <= 1;
               ++inline_sym29__) {
            lcm_sym132__ = size(y[(i - 1)]);
            lcm_sym128__ = (lcm_sym132__ - 1);
            for (size_t inline_sym27__ = 0; inline_sym27__ <= lcm_sym128__;
                 ++inline_sym27__) {
              int inline_sym26__;
              
              lcm_sym127__ = (lcm_sym132__ - inline_sym27__);
              inline_sym26__ = lcm_sym127__;
              current_statement__ = 43;
              if (y[(i - 1)][(lcm_sym127__ - 1)]) {
                inline_sym28__ = 1;
                inline_sym25__ = lcm_sym127__;
                break;
              } }
            if (inline_sym28__) {
              break;
            } 
            inline_sym28__ = 1;
            inline_sym25__ = 0;
            break;}
          assign(last, cons_list(index_uni(i), nil_index_list()),
            inline_sym25__, "assigning variable last");}
      } 
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "nind", nind, 0);
      current_statement__ = 31;
      current_statement__ = 31;
      check_greater_or_equal(function__, "n_occasions", n_occasions, 2);
      current_statement__ = 32;
      if (lcm_sym125__) {
        current_statement__ = 32;
        if (lcm_sym124__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 32;
          if (lcm_sym124__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 32;
              current_statement__ = 32;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 32;
      if (lcm_sym125__) {
        current_statement__ = 32;
        if (lcm_sym124__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 32;
          if (lcm_sym124__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 32;
              current_statement__ = 32;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      current_statement__ = 34;
      if (lcm_sym125__) {
        current_statement__ = 34;
        current_statement__ = 34;
        check_greater_or_equal(function__, "first[sym1__]", first[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_greater_or_equal(function__, "first[sym1__]",
                                 first[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 34;
      if (lcm_sym125__) {
        current_statement__ = 34;
        current_statement__ = 34;
        check_less_or_equal(function__, "first[sym1__]", first[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_less_or_equal(function__, "first[sym1__]",
                              first[(sym1__ - 1)], n_occasions);}
      } 
      current_statement__ = 35;
      if (lcm_sym125__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_greater_or_equal(function__, "last[sym1__]", last[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 35;
          current_statement__ = 35;
          check_greater_or_equal(function__, "last[sym1__]",
                                 last[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 35;
      if (lcm_sym125__) {
        current_statement__ = 35;
        current_statement__ = 35;
        check_less_or_equal(function__, "last[sym1__]", last[(1 - 1)],
                            n_occasions);
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 35;
          current_statement__ = 35;
          check_less_or_equal(function__, "last[sym1__]", last[(sym1__ - 1)],
                              n_occasions);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "lcm_fails2_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      int lcm_sym123__;
      int lcm_sym122__;
      int lcm_sym121__;
      int lcm_sym120__;
      double lcm_sym119__;
      double lcm_sym118__;
      double lcm_sym117__;
      double lcm_sym116__;
      double lcm_sym115__;
      double lcm_sym114__;
      double lcm_sym113__;
      double lcm_sym112__;
      double lcm_sym111__;
      double lcm_sym110__;
      double lcm_sym109__;
      double lcm_sym108__;
      double lcm_sym107__;
      int lcm_sym106__;
      int lcm_sym105__;
      int lcm_sym104__;
      int lcm_sym103__;
      int lcm_sym102__;
      int lcm_sym101__;
      int lcm_sym100__;
      int lcm_sym99__;
      int lcm_sym98__;
      int lcm_sym97__;
      int lcm_sym96__;
      int lcm_sym95__;
      int lcm_sym94__;
      int lcm_sym93__;
      int lcm_sym92__;
      int lcm_sym91__;
      int lcm_sym90__;
      int lcm_sym89__;
      int lcm_sym88__;
      int lcm_sym87__;
      int lcm_sym86__;
      local_scalar_t__ mean_phi;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      if (jacobian__) {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1, lp__);
      } else {
        current_statement__ = 1;
        mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      }
      local_scalar_t__ mean_p;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      if (jacobian__) {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1, lp__);
      } else {
        current_statement__ = 2;
        mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      }
      current_statement__ = 3;
      validate_non_negative_index("phi", "nind", nind);
      lcm_sym98__ = (n_occasions - 1);
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym98__);
      Eigen::Matrix<local_scalar_t__, -1, -1> phi;
      phi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym98__);
      
      lcm_sym87__ = logical_gte(nind, 1);
      if (lcm_sym87__) {
        lcm_sym88__ = logical_gte(lcm_sym98__, 1);
        if (lcm_sym88__) {
          lcm_sym119__ = std::numeric_limits<double>::quiet_NaN();
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym119__,
            "assigning variable phi");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym98__; ++sym2__) {
            current_statement__ = 3;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym119__, "assigning variable phi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 3;
          if (lcm_sym88__) {
            lcm_sym119__ = std::numeric_limits<double>::quiet_NaN();
            assign(phi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym119__,
              "assigning variable phi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym98__; ++sym2__) {
              current_statement__ = 3;
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym119__, "assigning variable phi");}
          } }
      } 
      current_statement__ = 4;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 4;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym98__);
      Eigen::Matrix<local_scalar_t__, -1, -1> p;
      p = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, lcm_sym98__);
      
      current_statement__ = 4;
      if (lcm_sym87__) {
        lcm_sym88__ = logical_gte(lcm_sym98__, 1);
        if (lcm_sym88__) {
          lcm_sym119__ = std::numeric_limits<double>::quiet_NaN();
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym119__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym98__; ++sym2__) {
            current_statement__ = 4;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym119__, "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym88__) {
            lcm_sym119__ = std::numeric_limits<double>::quiet_NaN();
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym119__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym98__; ++sym2__) {
              current_statement__ = 4;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym119__, "assigning variable p");}
          } }
      } 
      current_statement__ = 5;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 5;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      current_statement__ = 5;
      if (lcm_sym87__) {
        lcm_sym86__ = logical_gte(n_occasions, 1);
        if (lcm_sym86__) {
          lcm_sym119__ = std::numeric_limits<double>::quiet_NaN();
          assign(chi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym119__,
            "assigning variable chi");
          for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
            current_statement__ = 5;
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())),
              lcm_sym119__, "assigning variable chi");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 5;
          if (lcm_sym86__) {
            lcm_sym119__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym119__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym119__, "assigning variable chi");}
          } }
      } 
      current_statement__ = 14;
      if (lcm_sym87__) {
        lcm_sym121__ = first[(1 - 1)];
        lcm_sym100__ = (lcm_sym121__ - 1);
        if (logical_gte(lcm_sym100__, 1)) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable p");
          for (size_t t = 2; t <= lcm_sym100__; ++t) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable p");}
        } 
        current_statement__ = 12;
        if (logical_gte(lcm_sym98__, lcm_sym121__)) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym121__), nil_index_list())),
            mean_phi, "assigning variable phi");
          lcm_sym106__ = (lcm_sym121__ + 1);
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym121__), nil_index_list())), mean_p,
            "assigning variable p");
          for (size_t t = lcm_sym106__; t <= lcm_sym98__; ++t) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_phi,
              "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_p,
              "assigning variable p");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          lcm_sym120__ = first[(i - 1)];
          lcm_sym99__ = (lcm_sym120__ - 1);
          if (logical_gte(lcm_sym99__, 1)) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable p");
            for (size_t t = 2; t <= lcm_sym99__; ++t) {
              current_statement__ = 6;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable phi");
              current_statement__ = 7;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable p");}
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym98__, lcm_sym120__)) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym120__), nil_index_list())),
              mean_phi, "assigning variable phi");
            lcm_sym105__ = (lcm_sym120__ + 1);
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym120__), nil_index_list())),
              mean_p, "assigning variable p");
            for (size_t t = lcm_sym105__; t <= lcm_sym98__; ++t) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_phi,
                "assigning variable phi");
              current_statement__ = 10;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_p,
                "assigning variable p");}
          } }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym11__;
      int inline_sym19__;
      
      inline_sym19__ = 0;
      for (size_t inline_sym20__ = 1; inline_sym20__ <= 1; ++inline_sym20__) {
        current_statement__ = 15;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym12__;
        inline_sym12__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        
        for (size_t inline_sym14__ = 1; inline_sym14__ <= nind;
             ++inline_sym14__) {
          if (logical_gte(n_occasions, 1)) {
            lcm_sym119__ = std::numeric_limits<double>::quiet_NaN();
            assign(inline_sym12__,
              cons_list(index_uni(inline_sym14__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym119__,
              "assigning variable inline_sym12__");
            for (size_t inline_sym13__ = 2; inline_sym13__ <= n_occasions;
                 ++inline_sym13__) {
              current_statement__ = 15;
              assign(inline_sym12__,
                cons_list(index_uni(inline_sym14__),
                  cons_list(index_uni(inline_sym13__), nil_index_list())),
                lcm_sym119__, "assigning variable inline_sym12__");}
          } 
          if (inline_sym19__) {
            break;
          } }
        if (inline_sym19__) {
          break;
        } 
        for (size_t inline_sym18__ = 1; inline_sym18__ <= nind;
             ++inline_sym18__) {
          current_statement__ = 16;
          assign(inline_sym12__,
            cons_list(index_uni(inline_sym18__),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable inline_sym12__");
          if (logical_gte(lcm_sym98__, 1)) {
            int inline_sym15__;
            
            int inline_sym16__;
            
            lcm_sym102__ = (lcm_sym98__ + 1);
            current_statement__ = 19;
            assign(inline_sym12__,
              cons_list(index_uni(inline_sym18__),
                cons_list(index_uni(lcm_sym98__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym18__),
                     cons_list(index_uni(lcm_sym98__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym18__),
                        cons_list(index_uni((lcm_sym102__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(inline_sym12__,
                  cons_list(index_uni(inline_sym18__),
                    cons_list(index_uni(lcm_sym102__), nil_index_list())),
                  "inline_sym12__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym18__),
                      cons_list(index_uni(lcm_sym98__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym12__");
            for (size_t inline_sym17__ = 2; inline_sym17__ <= lcm_sym98__;
                 ++inline_sym17__) {
              int inline_sym15__;
              
              lcm_sym97__ = (n_occasions - inline_sym17__);
              int inline_sym16__;
              
              lcm_sym101__ = (lcm_sym97__ + 1);
              current_statement__ = 19;
              assign(inline_sym12__,
                cons_list(index_uni(inline_sym18__),
                  cons_list(index_uni(lcm_sym97__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym18__),
                       cons_list(index_uni(lcm_sym97__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym18__),
                          cons_list(index_uni((lcm_sym101__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym12__,
                    cons_list(index_uni(inline_sym18__),
                      cons_list(index_uni(lcm_sym101__), nil_index_list())),
                    "inline_sym12__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym18__),
                        cons_list(index_uni(lcm_sym97__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym12__");}
          } 
          if (inline_sym19__) {
            break;
          } }
        if (inline_sym19__) {
          break;
        } 
        inline_sym19__ = 1;
        assign(inline_sym11__, nil_index_list(), inline_sym12__,
          "assigning variable inline_sym11__");
        break;}
      assign(chi, nil_index_list(), inline_sym11__, "assigning variable chi");
      current_statement__ = 3;
      current_statement__ = 3;
      check_greater_or_equal(function__, "phi", phi, 0);
      current_statement__ = 3;
      current_statement__ = 3;
      check_less_or_equal(function__, "phi", phi, 1);
      current_statement__ = 4;
      current_statement__ = 4;
      check_greater_or_equal(function__, "p", p, 0);
      current_statement__ = 4;
      current_statement__ = 4;
      check_less_or_equal(function__, "p", p, 1);
      current_statement__ = 5;
      current_statement__ = 5;
      check_greater_or_equal(function__, "chi", inline_sym11__, 0);
      current_statement__ = 5;
      current_statement__ = 5;
      check_less_or_equal(function__, "chi", inline_sym11__, 1);
      {
        current_statement__ = 29;
        if (lcm_sym87__) {
          lcm_sym121__ = first[(1 - 1)];
          if (logical_gt(lcm_sym121__, 0)) {
            lcm_sym123__ = last[(1 - 1)];
            lcm_sym106__ = (lcm_sym121__ + 1);
            if (logical_gte(lcm_sym123__, lcm_sym106__)) {
              current_statement__ = 23;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(phi,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym106__ - 1)),
                        nil_index_list())), "phi")));
              lcm_sym104__ = (lcm_sym106__ + 1);
              lp_accum__.add(
                bernoulli_log<propto__>(y[(1 - 1)][(lcm_sym106__ - 1)],
                  rvalue(p,
                    cons_list(index_uni(1),
                      cons_list(index_uni((lcm_sym106__ - 1)),
                        nil_index_list())), "p")));
              for (size_t t = lcm_sym104__; t <= lcm_sym123__; ++t) {
                current_statement__ = 23;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "phi")));
                current_statement__ = 24;
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(1 - 1)][(t - 1)],
                    rvalue(p,
                      cons_list(index_uni(1),
                        cons_list(index_uni((t - 1)), nil_index_list())),
                      "p")));}
            } 
            current_statement__ = 26;
            lp_accum__.add(
              bernoulli_log<propto__>(1,
                rvalue(inline_sym11__,
                  cons_list(index_uni(1),
                    cons_list(index_uni(lcm_sym123__), nil_index_list())),
                  "inline_sym11__")));
          } 
          for (size_t i = 2; i <= nind; ++i) {
            lcm_sym120__ = first[(i - 1)];
            if (logical_gt(lcm_sym120__, 0)) {
              lcm_sym122__ = last[(i - 1)];
              lcm_sym105__ = (lcm_sym120__ + 1);
              if (logical_gte(lcm_sym122__, lcm_sym105__)) {
                current_statement__ = 23;
                lp_accum__.add(
                  bernoulli_log<propto__>(1,
                    rvalue(phi,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym105__ - 1)),
                          nil_index_list())), "phi")));
                lcm_sym103__ = (lcm_sym105__ + 1);
                lp_accum__.add(
                  bernoulli_log<propto__>(y[(i - 1)][(lcm_sym105__ - 1)],
                    rvalue(p,
                      cons_list(index_uni(i),
                        cons_list(index_uni((lcm_sym105__ - 1)),
                          nil_index_list())), "p")));
                for (size_t t = lcm_sym103__; t <= lcm_sym122__; ++t) {
                  current_statement__ = 23;
                  lp_accum__.add(
                    bernoulli_log<propto__>(1,
                      rvalue(phi,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "phi")));
                  current_statement__ = 24;
                  lp_accum__.add(
                    bernoulli_log<propto__>(y[(i - 1)][(t - 1)],
                      rvalue(p,
                        cons_list(index_uni(i),
                          cons_list(index_uni((t - 1)), nil_index_list())),
                        "p")));}
              } 
              current_statement__ = 26;
              lp_accum__.add(
                bernoulli_log<propto__>(1,
                  rvalue(inline_sym11__,
                    cons_list(index_uni(i),
                      cons_list(index_uni(lcm_sym122__), nil_index_list())),
                    "inline_sym11__")));
            } }
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "lcm_fails2_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym85__;
      double lcm_sym84__;
      double lcm_sym83__;
      double lcm_sym82__;
      double lcm_sym81__;
      double lcm_sym80__;
      double lcm_sym79__;
      double lcm_sym78__;
      double lcm_sym77__;
      double lcm_sym76__;
      double lcm_sym75__;
      double lcm_sym74__;
      int lcm_sym73__;
      int lcm_sym72__;
      double lcm_sym71__;
      double lcm_sym70__;
      double lcm_sym69__;
      int lcm_sym68__;
      int lcm_sym67__;
      int lcm_sym66__;
      int lcm_sym65__;
      int lcm_sym64__;
      int lcm_sym63__;
      int lcm_sym62__;
      int lcm_sym61__;
      int lcm_sym60__;
      int lcm_sym59__;
      int lcm_sym58__;
      int lcm_sym57__;
      int lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      int lcm_sym53__;
      int lcm_sym52__;
      double mean_phi;
      
      current_statement__ = 1;
      mean_phi = in__.scalar();
      current_statement__ = 1;
      mean_phi = stan::math::lub_constrain(mean_phi, 0, 1);
      double mean_p;
      
      current_statement__ = 2;
      mean_p = in__.scalar();
      current_statement__ = 2;
      mean_p = stan::math::lub_constrain(mean_p, 0, 1);
      current_statement__ = 3;
      validate_non_negative_index("phi", "nind", nind);
      lcm_sym60__ = (n_occasions - 1);
      validate_non_negative_index("phi", "n_occ_minus_1", lcm_sym60__);
      Eigen::Matrix<double, -1, -1> phi;
      phi = Eigen::Matrix<double, -1, -1>(nind, lcm_sym60__);
      
      lcm_sym53__ = logical_gte(nind, 1);
      if (lcm_sym53__) {
        {
          lcm_sym54__ = logical_gte(lcm_sym60__, 1);
          if (lcm_sym54__) {
            lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
              "assigning variable phi");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym60__; ++sym2__) {
              current_statement__ = 3;
              assign(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym71__, "assigning variable phi");}
          } 
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 3;
            if (lcm_sym54__) {
              lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
              assign(phi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
                "assigning variable phi");
              for (size_t sym2__ = 2; sym2__ <= lcm_sym60__; ++sym2__) {
                current_statement__ = 3;
                assign(phi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym71__, "assigning variable phi");}
            } }
        }
      } else {
        lcm_sym54__ = logical_gte(lcm_sym60__, 1);
      }
      current_statement__ = 4;
      validate_non_negative_index("p", "nind", nind);
      current_statement__ = 4;
      validate_non_negative_index("p", "n_occ_minus_1", lcm_sym60__);
      Eigen::Matrix<double, -1, -1> p;
      p = Eigen::Matrix<double, -1, -1>(nind, lcm_sym60__);
      
      current_statement__ = 4;
      if (lcm_sym53__) {
        current_statement__ = 4;
        if (lcm_sym54__) {
          lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
            "assigning variable p");
          for (size_t sym2__ = 2; sym2__ <= lcm_sym60__; ++sym2__) {
            current_statement__ = 4;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym71__,
              "assigning variable p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
          current_statement__ = 4;
          if (lcm_sym54__) {
            lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
            assign(p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
              "assigning variable p");
            for (size_t sym2__ = 2; sym2__ <= lcm_sym60__; ++sym2__) {
              current_statement__ = 4;
              assign(p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym71__, "assigning variable p");}
          } }
      } 
      current_statement__ = 5;
      validate_non_negative_index("chi", "nind", nind);
      current_statement__ = 5;
      validate_non_negative_index("chi", "n_occasions", n_occasions);
      Eigen::Matrix<local_scalar_t__, -1, -1> chi;
      chi = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
      
      current_statement__ = 5;
      if (lcm_sym53__) {
        {
          lcm_sym52__ = logical_gte(n_occasions, 1);
          if (lcm_sym52__) {
            lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
            assign(chi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
              "assigning variable chi");
            for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
              current_statement__ = 5;
              assign(chi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym71__, "assigning variable chi");}
          } 
          for (size_t sym1__ = 2; sym1__ <= nind; ++sym1__) {
            current_statement__ = 5;
            if (lcm_sym52__) {
              lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
              assign(chi,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
                "assigning variable chi");
              for (size_t sym2__ = 2; sym2__ <= n_occasions; ++sym2__) {
                current_statement__ = 5;
                assign(chi,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym71__, "assigning variable chi");}
            } }
        }
      } else {
        lcm_sym52__ = logical_gte(n_occasions, 1);
      }
      vars__.push_back(mean_phi);
      vars__.push_back(mean_p);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 14;
      if (lcm_sym53__) {
        lcm_sym73__ = first[(1 - 1)];
        lcm_sym62__ = (lcm_sym73__ - 1);
        if (logical_gte(lcm_sym62__, 1)) {
          current_statement__ = 6;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable phi");
          current_statement__ = 7;
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), 0,
            "assigning variable p");
          for (size_t t = 2; t <= lcm_sym62__; ++t) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), 0,
              "assigning variable p");}
        } 
        current_statement__ = 12;
        if (logical_gte(lcm_sym60__, lcm_sym73__)) {
          current_statement__ = 9;
          assign(phi,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym73__), nil_index_list())), mean_phi,
            "assigning variable phi");
          lcm_sym68__ = (lcm_sym73__ + 1);
          assign(p,
            cons_list(index_uni(1),
              cons_list(index_uni(lcm_sym73__), nil_index_list())), mean_p,
            "assigning variable p");
          for (size_t t = lcm_sym68__; t <= lcm_sym60__; ++t) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_phi,
              "assigning variable phi");
            current_statement__ = 10;
            assign(p,
              cons_list(index_uni(1),
                cons_list(index_uni(t), nil_index_list())), mean_p,
              "assigning variable p");}
        } 
        for (size_t i = 2; i <= nind; ++i) {
          lcm_sym72__ = first[(i - 1)];
          lcm_sym61__ = (lcm_sym72__ - 1);
          if (logical_gte(lcm_sym61__, 1)) {
            current_statement__ = 6;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable phi");
            current_statement__ = 7;
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(1), nil_index_list())), 0,
              "assigning variable p");
            for (size_t t = 2; t <= lcm_sym61__; ++t) {
              current_statement__ = 6;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable phi");
              current_statement__ = 7;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), 0,
                "assigning variable p");}
          } 
          current_statement__ = 12;
          if (logical_gte(lcm_sym60__, lcm_sym72__)) {
            current_statement__ = 9;
            assign(phi,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym72__), nil_index_list())),
              mean_phi, "assigning variable phi");
            lcm_sym67__ = (lcm_sym72__ + 1);
            assign(p,
              cons_list(index_uni(i),
                cons_list(index_uni(lcm_sym72__), nil_index_list())), mean_p,
              "assigning variable p");
            for (size_t t = lcm_sym67__; t <= lcm_sym60__; ++t) {
              current_statement__ = 9;
              assign(phi,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_phi,
                "assigning variable phi");
              current_statement__ = 10;
              assign(p,
                cons_list(index_uni(i),
                  cons_list(index_uni(t), nil_index_list())), mean_p,
                "assigning variable p");}
          } }
      } 
      Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym1__;
      int inline_sym9__;
      
      inline_sym9__ = 0;
      for (size_t inline_sym10__ = 1; inline_sym10__ <= 1; ++inline_sym10__) {
        current_statement__ = 15;
        validate_non_negative_index("chi", "nind", nind);
        current_statement__ = 15;
        validate_non_negative_index("chi", "n_occasions", n_occasions);
        Eigen::Matrix<local_scalar_t__, -1, -1> inline_sym2__;
        inline_sym2__ = Eigen::Matrix<local_scalar_t__, -1, -1>(nind, n_occasions);
        
        for (size_t inline_sym4__ = 1; inline_sym4__ <= nind; ++inline_sym4__) {
          if (lcm_sym52__) {
            lcm_sym71__ = std::numeric_limits<double>::quiet_NaN();
            assign(inline_sym2__,
              cons_list(index_uni(inline_sym4__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym71__,
              "assigning variable inline_sym2__");
            for (size_t inline_sym3__ = 2; inline_sym3__ <= n_occasions;
                 ++inline_sym3__) {
              current_statement__ = 15;
              assign(inline_sym2__,
                cons_list(index_uni(inline_sym4__),
                  cons_list(index_uni(inline_sym3__), nil_index_list())),
                lcm_sym71__, "assigning variable inline_sym2__");}
          } 
          if (inline_sym9__) {
            break;
          } }
        if (inline_sym9__) {
          break;
        } 
        for (size_t inline_sym8__ = 1; inline_sym8__ <= nind; ++inline_sym8__) {
          current_statement__ = 16;
          assign(inline_sym2__,
            cons_list(index_uni(inline_sym8__),
              cons_list(index_uni(n_occasions), nil_index_list())), 1.0,
            "assigning variable inline_sym2__");
          if (lcm_sym54__) {
            int inline_sym5__;
            
            int inline_sym6__;
            
            lcm_sym66__ = (lcm_sym60__ + 1);
            current_statement__ = 19;
            assign(inline_sym2__,
              cons_list(index_uni(inline_sym8__),
                cons_list(index_uni(lcm_sym60__), nil_index_list())),
              stan::math::fma(
                (rvalue(phi,
                   cons_list(index_uni(inline_sym8__),
                     cons_list(index_uni(lcm_sym60__), nil_index_list())),
                   "phi") *
                  (1 -
                    rvalue(p,
                      cons_list(index_uni(inline_sym8__),
                        cons_list(index_uni((lcm_sym66__ - 1)),
                          nil_index_list())), "p"))),
                rvalue(inline_sym2__,
                  cons_list(index_uni(inline_sym8__),
                    cons_list(index_uni(lcm_sym66__), nil_index_list())),
                  "inline_sym2__"),
                (1 -
                  rvalue(phi,
                    cons_list(index_uni(inline_sym8__),
                      cons_list(index_uni(lcm_sym60__), nil_index_list())),
                    "phi"))), "assigning variable inline_sym2__");
            for (size_t inline_sym7__ = 2; inline_sym7__ <= lcm_sym60__;
                 ++inline_sym7__) {
              int inline_sym5__;
              
              lcm_sym59__ = (n_occasions - inline_sym7__);
              int inline_sym6__;
              
              lcm_sym65__ = (lcm_sym59__ + 1);
              current_statement__ = 19;
              assign(inline_sym2__,
                cons_list(index_uni(inline_sym8__),
                  cons_list(index_uni(lcm_sym59__), nil_index_list())),
                stan::math::fma(
                  (rvalue(phi,
                     cons_list(index_uni(inline_sym8__),
                       cons_list(index_uni(lcm_sym59__), nil_index_list())),
                     "phi") *
                    (1 -
                      rvalue(p,
                        cons_list(index_uni(inline_sym8__),
                          cons_list(index_uni((lcm_sym65__ - 1)),
                            nil_index_list())), "p"))),
                  rvalue(inline_sym2__,
                    cons_list(index_uni(inline_sym8__),
                      cons_list(index_uni(lcm_sym65__), nil_index_list())),
                    "inline_sym2__"),
                  (1 -
                    rvalue(phi,
                      cons_list(index_uni(inline_sym8__),
                        cons_list(index_uni(lcm_sym59__), nil_index_list())),
                      "phi"))), "assigning variable inline_sym2__");}
          } 
          if (inline_sym9__) {
            break;
          } }
        if (inline_sym9__) {
          break;
        } 
        inline_sym9__ = 1;
        assign(inline_sym1__, nil_index_list(), inline_sym2__,
          "assigning variable inline_sym1__");
        break;}
      assign(chi, nil_index_list(), inline_sym1__, "assigning variable chi");
      if (lcm_sym54__) {
        if (lcm_sym53__) {
          vars__.push_back(
            rvalue(phi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "phi"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "phi"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym60__; ++sym1__) {
          if (lcm_sym53__) {
            vars__.push_back(
              rvalue(phi,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(phi,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "phi"));
            }
          } }
      } 
      if (lcm_sym54__) {
        if (lcm_sym53__) {
          vars__.push_back(
            rvalue(p,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "p"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "p"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= lcm_sym60__; ++sym1__) {
          if (lcm_sym53__) {
            vars__.push_back(
              rvalue(p,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())), "p"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(p,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())), "p"));}
          } }
      } 
      if (lcm_sym52__) {
        if (lcm_sym53__) {
          vars__.push_back(
            rvalue(inline_sym1__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "inline_sym1__"));
          for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                "inline_sym1__"));}
        } 
        for (size_t sym1__ = 2; sym1__ <= n_occasions; ++sym1__) {
          if (lcm_sym53__) {
            vars__.push_back(
              rvalue(inline_sym1__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "inline_sym1__"));
            for (size_t sym2__ = 2; sym2__ <= nind; ++sym2__) {
              vars__.push_back(
                rvalue(inline_sym1__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "inline_sym1__"));}
          } }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      
      pos__ = 1;
      double mean_phi;
      
      current_statement__ = 1;
      mean_phi = context__.vals_r("mean_phi")[(1 - 1)];
      current_statement__ = 1;
      mean_phi = stan::math::lub_free(mean_phi, 0, 1);
      double mean_p;
      
      current_statement__ = 2;
      mean_p = context__.vals_r("mean_p")[(1 - 1)];
      current_statement__ = 2;
      mean_p = stan::math::lub_free(mean_p, 0, 1);
      vars__.push_back(mean_phi);
      vars__.push_back(mean_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("mean_phi");
    names__.push_back("mean_p");
    names__.push_back("phi");
    names__.push_back("p");
    names__.push_back("chi");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occ_minus_1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occ_minus_1);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(nind);
    
    dims__.push_back(n_occasions);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_phi");
    param_names__.push_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (size_t sym148__ = 1; sym148__ <= n_occ_minus_1; ++sym148__) {
        {
          for (size_t sym149__ = 1; sym149__ <= nind; ++sym149__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym149__) + '.' + std::to_string(sym148__));
            }}
        }}
      for (size_t sym148__ = 1; sym148__ <= n_occ_minus_1; ++sym148__) {
        {
          for (size_t sym149__ = 1; sym149__ <= nind; ++sym149__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym149__) + '.' + std::to_string(sym148__));
            }}
        }}
      for (size_t sym148__ = 1; sym148__ <= n_occasions; ++sym148__) {
        {
          for (size_t sym149__ = 1; sym149__ <= nind; ++sym149__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym149__) + '.' + std::to_string(sym148__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "mean_phi");
    param_names__.push_back(std::string() + "mean_p");
    if (emit_transformed_parameters__) {
      for (size_t sym148__ = 1; sym148__ <= n_occ_minus_1; ++sym148__) {
        {
          for (size_t sym149__ = 1; sym149__ <= nind; ++sym149__) {
            {
              param_names__.push_back(std::string() + "phi" + '.' + std::to_string(sym149__) + '.' + std::to_string(sym148__));
            }}
        }}
      for (size_t sym148__ = 1; sym148__ <= n_occ_minus_1; ++sym148__) {
        {
          for (size_t sym149__ = 1; sym149__ <= nind; ++sym149__) {
            {
              param_names__.push_back(std::string() + "p" + '.' + std::to_string(sym149__) + '.' + std::to_string(sym148__));
            }}
        }}
      for (size_t sym148__ = 1; sym148__ <= n_occasions; ++sym148__) {
        {
          for (size_t sym149__ = 1; sym149__ <= nind; ++sym149__) {
            {
              param_names__.push_back(std::string() + "chi" + '.' + std::to_string(sym149__) + '.' + std::to_string(sym148__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"mean_phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mean_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"p\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occ_minus_1 << "},\"block\":\"transformed_parameters\"},{\"name\":\"chi\",\"type\":{\"name\":\"matrix\",\"rows\":" << nind << ",\"cols\":" << n_occasions << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef lcm_fails2_model_namespace::lcm_fails2_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp off-dce.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_dce_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'off-dce.stan', line 23, column 2 to column 17)",
                                                      " (in 'off-dce.stan', line 24, column 2 to column 16)",
                                                      " (in 'off-dce.stan', line 25, column 2 to column 15)",
                                                      " (in 'off-dce.stan', line 26, column 2 to column 14)",
                                                      " (in 'off-dce.stan', line 30, column 2 to column 22)",
                                                      " (in 'off-dce.stan', line 31, column 2 to column 23)",
                                                      " (in 'off-dce.stan', line 58, column 2 to column 13)",
                                                      " (in 'off-dce.stan', line 59, column 2 to column 18)",
                                                      " (in 'off-dce.stan', line 60, column 2 to column 11)",
                                                      " (in 'off-dce.stan', line 70, column 6 to column 21)",
                                                      " (in 'off-dce.stan', line 71, column 6 to column 15)",
                                                      " (in 'off-dce.stan', line 69, column 11 to line 72, column 5)",
                                                      " (in 'off-dce.stan', line 64, column 6 to column 41)",
                                                      " (in 'off-dce.stan', line 65, column 6 to column 44)",
                                                      " (in 'off-dce.stan', line 66, column 6 to column 26)",
                                                      " (in 'off-dce.stan', line 67, column 6 to column 55)",
                                                      " (in 'off-dce.stan', line 68, column 6 to column 39)",
                                                      " (in 'off-dce.stan', line 63, column 23 to line 69, column 5)",
                                                      " (in 'off-dce.stan', line 63, column 4 to line 72, column 5)",
                                                      " (in 'off-dce.stan', line 62, column 17 to line 73, column 3)",
                                                      " (in 'off-dce.stan', line 62, column 2 to line 73, column 3)",
                                                      " (in 'off-dce.stan', line 49, column 6 to line 52, column 68)",
                                                      " (in 'off-dce.stan', line 47, column 11 to line 53, column 5)",
                                                      " (in 'off-dce.stan', line 45, column 6 to column 40)",
                                                      " (in 'off-dce.stan', line 46, column 6 to column 41)",
                                                      " (in 'off-dce.stan', line 44, column 18 to line 47, column 5)",
                                                      " (in 'off-dce.stan', line 44, column 4 to line 53, column 5)",
                                                      " (in 'off-dce.stan', line 43, column 17 to line 54, column 3)",
                                                      " (in 'off-dce.stan', line 43, column 2 to line 54, column 3)",
                                                      " (in 'off-dce.stan', line 4, column 2 to column 17)",
                                                      " (in 'off-dce.stan', line 5, column 2 to column 17)",
                                                      " (in 'off-dce.stan', line 6, column 2 to column 31)",
                                                      " (in 'off-dce.stan', line 7, column 2 to column 14)",
                                                      " (in 'off-dce.stan', line 11, column 2 to column 32)",
                                                      " (in 'off-dce.stan', line 12, column 2 to column 31)",
                                                      " (in 'off-dce.stan', line 14, column 2 to column 14)",
                                                      " (in 'off-dce.stan', line 16, column 4 to column 25)",
                                                      " (in 'off-dce.stan', line 18, column 6 to column 28)",
                                                      " (in 'off-dce.stan', line 17, column 4 to line 18, column 28)",
                                                      " (in 'off-dce.stan', line 15, column 17 to line 19, column 3)",
                                                      " (in 'off-dce.stan', line 15, column 2 to line 19, column 3)"};



class off_dce_model : public model_base_crtp<off_dce_model> {

 private:
  int lcm_sym60__;
  int lcm_sym59__;
  int lcm_sym58__;
  int lcm_sym57__;
  int lcm_sym56__;
  int lcm_sym55__;
  int lcm_sym54__;
  int lcm_sym53__;
  int lcm_sym52__;
  double lcm_sym51__;
  double lcm_sym50__;
  int lcm_sym49__;
  int lcm_sym48__;
  int lcm_sym47__;
  int lcm_sym46__;
  int lcm_sym45__;
  int lcm_sym44__;
  int pos__;
  int R;
  int T;
  std::vector<std::vector<int>> y;
  Eigen::Matrix<double, -1, 1> X;
  std::vector<int> sum_y;
  int occ_obs;
 
 public:
  ~off_dce_model() { }
  
  std::string model_name() const { return "off_dce_model"; }
  
  off_dce_model(stan::io::var_context& context__,
                unsigned int random_seed__ = 0,
                std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "off_dce_model_namespace::off_dce_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","R","int",
          context__.to_vec());
      
      current_statement__ = 30;
      R = context__.vals_i("R")[(1 - 1)];
      context__.validate_dims("data initialization","T","int",
          context__.to_vec());
      
      current_statement__ = 31;
      T = context__.vals_i("T")[(1 - 1)];
      current_statement__ = 32;
      validate_non_negative_index("y", "R", R);
      current_statement__ = 32;
      validate_non_negative_index("y", "T", T);
      context__.validate_dims("data initialization","y","int",
          context__.to_vec(R, T));
      y = std::vector<std::vector<int>>(R, std::vector<int>(T, 0));
      
      {
        std::vector<int> y_flat__;
        current_statement__ = 32;
        assign(y_flat__, nil_index_list(), context__.vals_i("y"),
          "assigning variable y_flat__");
        current_statement__ = 32;
        pos__ = 1;
        lcm_sym45__ = logical_gte(T, 1);
        if (lcm_sym45__) {
          {
            lcm_sym44__ = logical_gte(R, 1);
            if (lcm_sym44__) {
              current_statement__ = 32;
              assign(y,
                cons_list(index_uni(1),
                  cons_list(index_uni(1), nil_index_list())),
                y_flat__[(1 - 1)], "assigning variable y");
              current_statement__ = 32;
              pos__ = 2;
              for (size_t sym2__ = 2; sym2__ <= R; ++sym2__) {
                current_statement__ = 32;
                assign(y,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(1), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 32;
                pos__ = (pos__ + 1);}
            } 
            for (size_t sym1__ = 2; sym1__ <= T; ++sym1__) {
              current_statement__ = 32;
              if (lcm_sym44__) {
                current_statement__ = 32;
                assign(y,
                  cons_list(index_uni(1),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  y_flat__[(pos__ - 1)], "assigning variable y");
                current_statement__ = 32;
                pos__ = (pos__ + 1);
                for (size_t sym2__ = 2; sym2__ <= R; ++sym2__) {
                  current_statement__ = 32;
                  assign(y,
                    cons_list(index_uni(sym2__),
                      cons_list(index_uni(sym1__), nil_index_list())),
                    y_flat__[(pos__ - 1)], "assigning variable y");
                  current_statement__ = 32;
                  pos__ = (pos__ + 1);}
              } }
          }
        } else {
          lcm_sym44__ = logical_gte(R, 1);
        }
      }
      current_statement__ = 33;
      validate_non_negative_index("X", "R", R);
      context__.validate_dims("data initialization","X","double",
          context__.to_vec(R));
      X = Eigen::Matrix<double, -1, 1>(R);
      
      {
        std::vector<double> X_flat__;
        current_statement__ = 33;
        assign(X_flat__, nil_index_list(), context__.vals_r("X"),
          "assigning variable X_flat__");
        current_statement__ = 33;
        pos__ = 1;
        current_statement__ = 33;
        if (lcm_sym44__) {
          current_statement__ = 33;
          assign(X, cons_list(index_uni(1), nil_index_list()),
            X_flat__[(1 - 1)], "assigning variable X");
          current_statement__ = 33;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
            current_statement__ = 33;
            assign(X, cons_list(index_uni(sym1__), nil_index_list()),
              X_flat__[(pos__ - 1)], "assigning variable X");
            current_statement__ = 33;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 34;
      validate_non_negative_index("sum_y", "R", R);
      sum_y = std::vector<int>(R, 0);
      
      
      current_statement__ = 36;
      occ_obs = 0;
      current_statement__ = 41;
      if (lcm_sym44__) {
        current_statement__ = 37;
        assign(sum_y, cons_list(index_uni(1), nil_index_list()),
          sum(y[(1 - 1)]), "assigning variable sum_y");
        current_statement__ = 39;
        if (sum_y[(1 - 1)]) {
          current_statement__ = 38;
          occ_obs = 1;
        } 
        for (size_t i = 2; i <= R; ++i) {
          current_statement__ = 37;
          assign(sum_y, cons_list(index_uni(i), nil_index_list()),
            sum(y[(i - 1)]), "assigning variable sum_y");
          current_statement__ = 39;
          if (sum_y[(i - 1)]) {
            current_statement__ = 38;
            occ_obs = (occ_obs + 1);
          } }
      } 
      current_statement__ = 30;
      current_statement__ = 30;
      check_greater_or_equal(function__, "R", R, 1);
      current_statement__ = 31;
      current_statement__ = 31;
      check_greater_or_equal(function__, "T", T, 1);
      current_statement__ = 32;
      if (lcm_sym44__) {
        current_statement__ = 32;
        if (lcm_sym45__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                 y[(1 - 1)][(1 - 1)], 0);
          for (size_t sym2__ = 2; sym2__ <= T; ++sym2__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(1 - 1)][(sym2__ - 1)], 0);}
        } 
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 32;
          if (lcm_sym45__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                   y[(sym1__ - 1)][(1 - 1)], 0);
            for (size_t sym2__ = 2; sym2__ <= T; ++sym2__) {
              current_statement__ = 32;
              current_statement__ = 32;
              check_greater_or_equal(function__, "y[sym1__, sym2__]",
                                     y[(sym1__ - 1)][(sym2__ - 1)], 0);}
          } }
      } 
      current_statement__ = 32;
      if (lcm_sym44__) {
        current_statement__ = 32;
        if (lcm_sym45__) {
          current_statement__ = 32;
          current_statement__ = 32;
          check_less_or_equal(function__, "y[sym1__, sym2__]",
                              y[(1 - 1)][(1 - 1)], 1);
          for (size_t sym2__ = 2; sym2__ <= T; ++sym2__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(1 - 1)][(sym2__ - 1)], 1);}
        } 
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 32;
          if (lcm_sym45__) {
            current_statement__ = 32;
            current_statement__ = 32;
            check_less_or_equal(function__, "y[sym1__, sym2__]",
                                y[(sym1__ - 1)][(1 - 1)], 1);
            for (size_t sym2__ = 2; sym2__ <= T; ++sym2__) {
              current_statement__ = 32;
              current_statement__ = 32;
              check_less_or_equal(function__, "y[sym1__, sym2__]",
                                  y[(sym1__ - 1)][(sym2__ - 1)], 1);}
          } }
      } 
      current_statement__ = 34;
      if (lcm_sym44__) {
        current_statement__ = 34;
        current_statement__ = 34;
        check_greater_or_equal(function__, "sum_y[sym1__]", sum_y[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_greater_or_equal(function__, "sum_y[sym1__]",
                                 sum_y[(sym1__ - 1)], 0);}
      } 
      current_statement__ = 34;
      if (lcm_sym44__) {
        current_statement__ = 34;
        current_statement__ = 34;
        check_less_or_equal(function__, "sum_y[sym1__]", sum_y[(1 - 1)], T);
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 34;
          current_statement__ = 34;
          check_less_or_equal(function__, "sum_y[sym1__]",
                              sum_y[(sym1__ - 1)], T);}
      } 
      current_statement__ = 35;
      current_statement__ = 35;
      check_greater_or_equal(function__, "occ_obs", occ_obs, 0);
      current_statement__ = 35;
      current_statement__ = 35;
      check_less_or_equal(function__, "occ_obs", occ_obs, R);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "off_dce_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      int lcm_sym43__;
      int lcm_sym42__;
      double lcm_sym41__;
      Eigen::Matrix<local_scalar_t__, -1, -1> lcm_sym40__;
      double lcm_sym39__;
      double lcm_sym38__;
      double lcm_sym37__;
      double lcm_sym36__;
      double lcm_sym35__;
      double lcm_sym34__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym33__;
      int lcm_sym32__;
      int lcm_sym31__;
      local_scalar_t__ alpha_occ;
      
      current_statement__ = 1;
      alpha_occ = in__.scalar();
      local_scalar_t__ beta_occ;
      
      current_statement__ = 2;
      beta_occ = in__.scalar();
      local_scalar_t__ alpha_p;
      
      current_statement__ = 3;
      alpha_p = in__.scalar();
      local_scalar_t__ beta_p;
      
      current_statement__ = 4;
      beta_p = in__.scalar();
      current_statement__ = 5;
      validate_non_negative_index("logit_psi", "R", R);
      Eigen::Matrix<local_scalar_t__, -1, 1> logit_psi;
      logit_psi = Eigen::Matrix<local_scalar_t__, -1, 1>(R);
      
      lcm_sym31__ = logical_gte(R, 1);
      if (lcm_sym31__) {
        lcm_sym41__ = std::numeric_limits<double>::quiet_NaN();
        assign(logit_psi, cons_list(index_uni(1), nil_index_list()),
          lcm_sym41__, "assigning variable logit_psi");
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 5;
          assign(logit_psi, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym41__, "assigning variable logit_psi");}
      } 
      current_statement__ = 6;
      validate_non_negative_index("logit_p", "R", R);
      current_statement__ = 6;
      validate_non_negative_index("logit_p", "T", T);
      Eigen::Matrix<local_scalar_t__, -1, -1> logit_p;
      logit_p = Eigen::Matrix<local_scalar_t__, -1, -1>(R, T);
      
      current_statement__ = 6;
      if (lcm_sym31__) {
        lcm_sym32__ = logical_gte(T, 1);
        if (lcm_sym32__) {
          lcm_sym41__ = std::numeric_limits<double>::quiet_NaN();
          assign(logit_p,
            cons_list(index_uni(1),
              cons_list(index_uni(1), nil_index_list())), lcm_sym41__,
            "assigning variable logit_p");
          for (size_t sym2__ = 2; sym2__ <= T; ++sym2__) {
            current_statement__ = 6;
            assign(logit_p,
              cons_list(index_uni(1),
                cons_list(index_uni(sym2__), nil_index_list())), lcm_sym41__,
              "assigning variable logit_p");}
        } 
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 6;
          if (lcm_sym32__) {
            lcm_sym41__ = std::numeric_limits<double>::quiet_NaN();
            assign(logit_p,
              cons_list(index_uni(sym1__),
                cons_list(index_uni(1), nil_index_list())), lcm_sym41__,
              "assigning variable logit_p");
            for (size_t sym2__ = 2; sym2__ <= T; ++sym2__) {
              current_statement__ = 6;
              assign(logit_p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym41__, "assigning variable logit_p");}
          } }
      } 
      assign(lcm_sym33__, nil_index_list(),
        add(alpha_occ, multiply(beta_occ, X)),
        "assigning variable lcm_sym33__");
      assign(logit_psi, nil_index_list(), lcm_sym33__,
        "assigning variable logit_psi");
      assign(lcm_sym40__, nil_index_list(),
        rep_matrix(add(alpha_p, multiply(beta_p, X)), T),
        "assigning variable lcm_sym40__");
      assign(logit_p, nil_index_list(), lcm_sym40__,
        "assigning variable logit_p");
      {
        current_statement__ = 29;
        if (lcm_sym31__) {
          current_statement__ = 27;
          if (sum_y[(1 - 1)]) {
            current_statement__ = 24;
            lp_accum__.add(
              bernoulli_logit_log<propto__>(1, lcm_sym33__[(1 - 1)]));
            current_statement__ = 25;
            lp_accum__.add(
              bernoulli_logit_log<propto__>(y[(1 - 1)],
                rvalue(lcm_sym40__,
                  cons_list(index_uni(1), nil_index_list()), "lcm_sym40__")));
          } else {
            current_statement__ = 22;
            lp_accum__.add(
              log_sum_exp(
                (bernoulli_logit_lpmf<false>(1, lcm_sym33__[(1 - 1)]) +
                  bernoulli_logit_lpmf<false>(0,
                    rvalue(lcm_sym40__,
                      cons_list(index_uni(1), nil_index_list()),
                      "lcm_sym40__"))),
                bernoulli_logit_lpmf<false>(0, lcm_sym33__[(1 - 1)])));
          }
          for (size_t i = 2; i <= R; ++i) {
            current_statement__ = 27;
            if (sum_y[(i - 1)]) {
              current_statement__ = 24;
              lp_accum__.add(
                bernoulli_logit_log<propto__>(1, lcm_sym33__[(i - 1)]));
              current_statement__ = 25;
              lp_accum__.add(
                bernoulli_logit_log<propto__>(y[(i - 1)],
                  rvalue(lcm_sym40__,
                    cons_list(index_uni(i), nil_index_list()), "lcm_sym40__")));
            } else {
              current_statement__ = 22;
              lp_accum__.add(
                log_sum_exp(
                  (bernoulli_logit_lpmf<false>(1, lcm_sym33__[(i - 1)]) +
                    bernoulli_logit_lpmf<false>(0,
                      rvalue(lcm_sym40__,
                        cons_list(index_uni(i), nil_index_list()),
                        "lcm_sym40__"))),
                  bernoulli_logit_lpmf<false>(0, lcm_sym33__[(i - 1)])));
            }}
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "off_dce_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      int lcm_sym24__;
      int lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym12__;
      double lcm_sym20__;
      int lcm_sym19__;
      Eigen::Matrix<double, -1, -1> lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      local_scalar_t__ lcm_sym15__;
      local_scalar_t__ lcm_sym14__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym11__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym10__;
      Eigen::Matrix<double, -1, 1> lcm_sym9__;
      int lcm_sym8__;
      int lcm_sym7__;
      int lcm_sym6__;
      int lcm_sym5__;
      int lcm_sym4__;
      int lcm_sym3__;
      double lcm_sym2__;
      double lcm_sym1__;
      double alpha_occ;
      
      current_statement__ = 1;
      alpha_occ = in__.scalar();
      double beta_occ;
      
      current_statement__ = 2;
      beta_occ = in__.scalar();
      double alpha_p;
      
      current_statement__ = 3;
      alpha_p = in__.scalar();
      double beta_p;
      
      current_statement__ = 4;
      beta_p = in__.scalar();
      current_statement__ = 5;
      validate_non_negative_index("logit_psi", "R", R);
      Eigen::Matrix<double, -1, 1> logit_psi;
      logit_psi = Eigen::Matrix<double, -1, 1>(R);
      
      lcm_sym5__ = logical_gte(R, 1);
      if (lcm_sym5__) {
        lcm_sym20__ = std::numeric_limits<double>::quiet_NaN();
        assign(logit_psi, cons_list(index_uni(1), nil_index_list()),
          lcm_sym20__, "assigning variable logit_psi");
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          current_statement__ = 5;
          assign(logit_psi, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym20__, "assigning variable logit_psi");}
      } 
      current_statement__ = 6;
      validate_non_negative_index("logit_p", "R", R);
      current_statement__ = 6;
      validate_non_negative_index("logit_p", "T", T);
      Eigen::Matrix<double, -1, -1> logit_p;
      logit_p = Eigen::Matrix<double, -1, -1>(R, T);
      
      current_statement__ = 6;
      if (lcm_sym5__) {
        {
          lcm_sym6__ = logical_gte(T, 1);
          if (lcm_sym6__) {
            lcm_sym20__ = std::numeric_limits<double>::quiet_NaN();
            assign(logit_p,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), lcm_sym20__,
              "assigning variable logit_p");
            for (size_t sym2__ = 2; sym2__ <= T; ++sym2__) {
              current_statement__ = 6;
              assign(logit_p,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym2__), nil_index_list())),
                lcm_sym20__, "assigning variable logit_p");}
          } 
          for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
            current_statement__ = 6;
            if (lcm_sym6__) {
              lcm_sym20__ = std::numeric_limits<double>::quiet_NaN();
              assign(logit_p,
                cons_list(index_uni(sym1__),
                  cons_list(index_uni(1), nil_index_list())), lcm_sym20__,
                "assigning variable logit_p");
              for (size_t sym2__ = 2; sym2__ <= T; ++sym2__) {
                current_statement__ = 6;
                assign(logit_p,
                  cons_list(index_uni(sym1__),
                    cons_list(index_uni(sym2__), nil_index_list())),
                  lcm_sym20__, "assigning variable logit_p");}
            } }
        }
      } else {
        lcm_sym6__ = logical_gte(T, 1);
      }
      vars__.push_back(alpha_occ);
      vars__.push_back(beta_occ);
      vars__.push_back(alpha_p);
      vars__.push_back(beta_p);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      assign(lcm_sym9__, nil_index_list(),
        add(alpha_occ, multiply(beta_occ, X)),
        "assigning variable lcm_sym9__");
      assign(logit_psi, nil_index_list(), lcm_sym9__,
        "assigning variable logit_psi");
      assign(lcm_sym18__, nil_index_list(),
        rep_matrix(add(alpha_p, multiply(beta_p, X)), T),
        "assigning variable lcm_sym18__");
      assign(logit_p, nil_index_list(), lcm_sym18__,
        "assigning variable logit_p");
      if (lcm_sym5__) {
        vars__.push_back(lcm_sym9__[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          vars__.push_back(lcm_sym9__[(sym1__ - 1)]);}
      } 
      if (lcm_sym6__) {
        if (lcm_sym5__) {
          vars__.push_back(
            rvalue(lcm_sym18__,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "lcm_sym18__"));
          for (size_t sym2__ = 2; sym2__ <= R; ++sym2__) {
            vars__.push_back(
              rvalue(lcm_sym18__,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())), "lcm_sym18__"));
          }
        } 
        for (size_t sym1__ = 2; sym1__ <= T; ++sym1__) {
          if (lcm_sym5__) {
            vars__.push_back(
              rvalue(lcm_sym18__,
                cons_list(index_uni(1),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "lcm_sym18__"));
            for (size_t sym2__ = 2; sym2__ <= R; ++sym2__) {
              vars__.push_back(
                rvalue(lcm_sym18__,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(sym1__), nil_index_list())),
                  "lcm_sym18__"));}
          } }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      int occ_fs;
      
      current_statement__ = 8;
      validate_non_negative_index("psi_con", "R", R);
      std::vector<local_scalar_t__> psi_con;
      psi_con = std::vector<local_scalar_t__>(R, 0);
      
      current_statement__ = 9;
      validate_non_negative_index("z", "R", R);
      std::vector<int> z;
      z = std::vector<int>(R, 0);
      
      current_statement__ = 21;
      if (lcm_sym5__) {
        current_statement__ = 19;
        if (logical_eq(sum_y[(1 - 1)], 0)) {
          double psi;
          
          lcm_sym15__ = inv_logit(lcm_sym9__[(1 - 1)]);
          current_statement__ = 14;
          validate_non_negative_index("q", "T", T);
          Eigen::Matrix<double, -1, 1> q;
          q = Eigen::Matrix<double, -1, 1>(T);
          
          assign(lcm_sym11__, nil_index_list(),
            transpose(
              inv_logit(
                minus(
                  rvalue(lcm_sym18__,
                    cons_list(index_uni(1), nil_index_list()), "lcm_sym18__")))),
            "assigning variable lcm_sym11__");
          double qT;
          
          lcm_sym17__ = prod(lcm_sym11__);
          current_statement__ = 16;
          assign(psi_con, cons_list(index_uni(1), nil_index_list()),
            ((lcm_sym15__ * lcm_sym17__) /
              stan::math::fma(lcm_sym15__, lcm_sym17__, (1 - lcm_sym15__))),
            "assigning variable psi_con");
          current_statement__ = 17;
          assign(z, cons_list(index_uni(1), nil_index_list()),
            bernoulli_rng(psi_con[(1 - 1)], base_rng__),
            "assigning variable z");
        } else {
          current_statement__ = 10;
          assign(psi_con, cons_list(index_uni(1), nil_index_list()), 1,
            "assigning variable psi_con");
          current_statement__ = 11;
          assign(z, cons_list(index_uni(1), nil_index_list()), 1,
            "assigning variable z");
        }
        for (size_t i = 2; i <= R; ++i) {
          current_statement__ = 19;
          if (logical_eq(sum_y[(i - 1)], 0)) {
            double psi;
            
            lcm_sym14__ = inv_logit(lcm_sym9__[(i - 1)]);
            current_statement__ = 14;
            validate_non_negative_index("q", "T", T);
            Eigen::Matrix<double, -1, 1> q;
            q = Eigen::Matrix<double, -1, 1>(T);
            
            assign(lcm_sym10__, nil_index_list(),
              transpose(
                inv_logit(
                  minus(
                    rvalue(lcm_sym18__,
                      cons_list(index_uni(i), nil_index_list()),
                      "lcm_sym18__")))), "assigning variable lcm_sym10__");
            double qT;
            
            lcm_sym16__ = prod(lcm_sym10__);
            current_statement__ = 16;
            assign(psi_con, cons_list(index_uni(i), nil_index_list()),
              ((lcm_sym14__ * lcm_sym16__) /
                stan::math::fma(lcm_sym14__, lcm_sym16__, (1 - lcm_sym14__))),
              "assigning variable psi_con");
            current_statement__ = 17;
            assign(z, cons_list(index_uni(i), nil_index_list()),
              bernoulli_rng(psi_con[(i - 1)], base_rng__),
              "assigning variable z");
          } else {
            current_statement__ = 10;
            assign(psi_con, cons_list(index_uni(i), nil_index_list()), 1,
              "assigning variable psi_con");
            current_statement__ = 11;
            assign(z, cons_list(index_uni(i), nil_index_list()), 1,
              "assigning variable z");
          }}
      } 
      lcm_sym19__ = sum(z);
      occ_fs = lcm_sym19__;
      vars__.push_back(lcm_sym19__);
      if (lcm_sym5__) {
        vars__.push_back(psi_con[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          vars__.push_back(psi_con[(sym1__ - 1)]);}
      } 
      if (lcm_sym5__) {
        vars__.push_back(z[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= R; ++sym1__) {
          vars__.push_back(z[(sym1__ - 1)]);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      
      pos__ = 1;
      double alpha_occ;
      
      current_statement__ = 1;
      alpha_occ = context__.vals_r("alpha_occ")[(1 - 1)];
      double beta_occ;
      
      current_statement__ = 2;
      beta_occ = context__.vals_r("beta_occ")[(1 - 1)];
      double alpha_p;
      
      current_statement__ = 3;
      alpha_p = context__.vals_r("alpha_p")[(1 - 1)];
      double beta_p;
      
      current_statement__ = 4;
      beta_p = context__.vals_r("beta_p")[(1 - 1)];
      vars__.push_back(alpha_occ);
      vars__.push_back(beta_occ);
      vars__.push_back(alpha_p);
      vars__.push_back(beta_p);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("alpha_occ");
    names__.push_back("beta_occ");
    names__.push_back("alpha_p");
    names__.push_back("beta_p");
    names__.push_back("logit_psi");
    names__.push_back("logit_p");
    names__.push_back("occ_fs");
    names__.push_back("psi_con");
    names__.push_back("z");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(R);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(R);
    
    dims__.push_back(T);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(R);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(R);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "alpha_occ");
    param_names__.push_back(std::string() + "beta_occ");
    param_names__.push_back(std::string() + "alpha_p");
    param_names__.push_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (size_t sym61__ = 1; sym61__ <= R; ++sym61__) {
        {
          param_names__.push_back(std::string() + "logit_psi" + '.' + std::to_string(sym61__));
        }}
      for (size_t sym61__ = 1; sym61__ <= T; ++sym61__) {
        {
          for (size_t sym62__ = 1; sym62__ <= R; ++sym62__) {
            {
              param_names__.push_back(std::string() + "logit_p" + '.' + std::to_string(sym62__) + '.' + std::to_string(sym61__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "occ_fs");
      for (size_t sym61__ = 1; sym61__ <= R; ++sym61__) {
        {
          param_names__.push_back(std::string() + "psi_con" + '.' + std::to_string(sym61__));
        }}
      for (size_t sym61__ = 1; sym61__ <= R; ++sym61__) {
        {
          param_names__.push_back(std::string() + "z" + '.' + std::to_string(sym61__));
        }}
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "alpha_occ");
    param_names__.push_back(std::string() + "beta_occ");
    param_names__.push_back(std::string() + "alpha_p");
    param_names__.push_back(std::string() + "beta_p");
    if (emit_transformed_parameters__) {
      for (size_t sym61__ = 1; sym61__ <= R; ++sym61__) {
        {
          param_names__.push_back(std::string() + "logit_psi" + '.' + std::to_string(sym61__));
        }}
      for (size_t sym61__ = 1; sym61__ <= T; ++sym61__) {
        {
          for (size_t sym62__ = 1; sym62__ <= R; ++sym62__) {
            {
              param_names__.push_back(std::string() + "logit_p" + '.' + std::to_string(sym62__) + '.' + std::to_string(sym61__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      param_names__.push_back(std::string() + "occ_fs");
      for (size_t sym61__ = 1; sym61__ <= R; ++sym61__) {
        {
          param_names__.push_back(std::string() + "psi_con" + '.' + std::to_string(sym61__));
        }}
      for (size_t sym61__ = 1; sym61__ <= R; ++sym61__) {
        {
          param_names__.push_back(std::string() + "z" + '.' + std::to_string(sym61__));
        }}
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" << R << "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" << R << ",\"cols\":" << T << "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" << R << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << R << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_occ\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"beta_p\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"logit_psi\",\"type\":{\"name\":\"vector\",\"length\":" << R << "},\"block\":\"transformed_parameters\"},{\"name\":\"logit_p\",\"type\":{\"name\":\"matrix\",\"rows\":" << R << ",\"cols\":" << T << "},\"block\":\"transformed_parameters\"},{\"name\":\"occ_fs\",\"type\":{\"name\":\"int\"},\"block\":\"generated_quantities\"},{\"name\":\"psi_con\",\"type\":{\"name\":\"array\",\"length\":" << R << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"generated_quantities\"},{\"name\":\"z\",\"type\":{\"name\":\"array\",\"length\":" << R << ",\"element_type\":{\"name\":\"int\"}},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef off_dce_model_namespace::off_dce_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp off-small.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace off_small_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'off-small.stan', line 10, column 2 to column 12)",
                                                      " (in 'off-small.stan', line 11, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 12, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 13, column 2 to column 13)",
                                                      " (in 'off-small.stan', line 14, column 2 to column 13)",
                                                      " (in 'off-small.stan', line 15, column 2 to column 35)",
                                                      " (in 'off-small.stan', line 16, column 2 to column 35)",
                                                      " (in 'off-small.stan', line 17, column 2 to column 34)",
                                                      " (in 'off-small.stan', line 20, column 2 to column 15)",
                                                      " (in 'off-small.stan', line 21, column 2 to column 15)",
                                                      " (in 'off-small.stan', line 22, column 2 to column 18)",
                                                      " (in 'off-small.stan', line 28, column 4 to line 29, column 42)",
                                                      " (in 'off-small.stan', line 27, column 2 to line 29, column 42)",
                                                      " (in 'off-small.stan', line 32, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 33, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 34, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 35, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 37, column 2 to column 23)",
                                                      " (in 'off-small.stan', line 39, column 2 to column 29)",
                                                      " (in 'off-small.stan', line 2, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 3, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 4, column 2 to column 33)",
                                                      " (in 'off-small.stan', line 5, column 2 to column 17)",
                                                      " (in 'off-small.stan', line 6, column 2 to column 22)",
                                                      " (in 'off-small.stan', line 7, column 2 to column 14)"};



class off_small_model : public model_base_crtp<off_small_model> {

 private:
  double lcm_sym52__;
  double lcm_sym51__;
  double lcm_sym50__;
  double lcm_sym49__;
  double lcm_sym48__;
  double lcm_sym47__;
  int lcm_sym46__;
  int lcm_sym45__;
  int lcm_sym44__;
  int lcm_sym43__;
  int pos__;
  int J;
  int N;
  std::vector<int> person;
  Eigen::Matrix<double, -1, 1> time;
  Eigen::Matrix<double, -1, 1> treatment;
  Eigen::Matrix<double, -1, 1> y;
 
 public:
  ~off_small_model() { }
  
  std::string model_name() const { return "off_small_model"; }
  
  off_small_model(stan::io::var_context& context__,
                  unsigned int random_seed__ = 0,
                  std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "off_small_model_namespace::off_small_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","J","int",
          context__.to_vec());
      
      current_statement__ = 20;
      J = context__.vals_i("J")[(1 - 1)];
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      
      current_statement__ = 21;
      N = context__.vals_i("N")[(1 - 1)];
      current_statement__ = 22;
      validate_non_negative_index("person", "N", N);
      context__.validate_dims("data initialization","person","int",
          context__.to_vec(N));
      person = std::vector<int>(N, 0);
      
      current_statement__ = 22;
      assign(person, nil_index_list(), context__.vals_i("person"),
        "assigning variable person");
      current_statement__ = 23;
      validate_non_negative_index("time", "N", N);
      context__.validate_dims("data initialization","time","double",
          context__.to_vec(N));
      time = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> time_flat__;
        current_statement__ = 23;
        assign(time_flat__, nil_index_list(), context__.vals_r("time"),
          "assigning variable time_flat__");
        current_statement__ = 23;
        pos__ = 1;
        lcm_sym43__ = logical_gte(N, 1);
        if (lcm_sym43__) {
          current_statement__ = 23;
          assign(time, cons_list(index_uni(1), nil_index_list()),
            time_flat__[(1 - 1)], "assigning variable time");
          current_statement__ = 23;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 23;
            assign(time, cons_list(index_uni(sym1__), nil_index_list()),
              time_flat__[(pos__ - 1)], "assigning variable time");
            current_statement__ = 23;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 24;
      validate_non_negative_index("treatment", "N", N);
      context__.validate_dims("data initialization","treatment","double",
          context__.to_vec(N));
      treatment = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> treatment_flat__;
        current_statement__ = 24;
        assign(treatment_flat__, nil_index_list(),
          context__.vals_r("treatment"),
          "assigning variable treatment_flat__");
        current_statement__ = 24;
        pos__ = 1;
        current_statement__ = 24;
        if (lcm_sym43__) {
          current_statement__ = 24;
          assign(treatment, cons_list(index_uni(1), nil_index_list()),
            treatment_flat__[(1 - 1)], "assigning variable treatment");
          current_statement__ = 24;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 24;
            assign(treatment, cons_list(index_uni(sym1__), nil_index_list()),
              treatment_flat__[(pos__ - 1)], "assigning variable treatment");
            current_statement__ = 24;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 25;
      validate_non_negative_index("y", "N", N);
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(N));
      y = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 25;
        assign(y_flat__, nil_index_list(), context__.vals_r("y"),
          "assigning variable y_flat__");
        current_statement__ = 25;
        pos__ = 1;
        current_statement__ = 25;
        if (lcm_sym43__) {
          current_statement__ = 25;
          assign(y, cons_list(index_uni(1), nil_index_list()),
            y_flat__[(1 - 1)], "assigning variable y");
          current_statement__ = 25;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 25;
            assign(y, cons_list(index_uni(sym1__), nil_index_list()),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 25;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 20;
      current_statement__ = 20;
      check_greater_or_equal(function__, "J", J, 0);
      current_statement__ = 21;
      current_statement__ = 21;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 22;
      if (lcm_sym43__) {
        current_statement__ = 22;
        current_statement__ = 22;
        check_greater_or_equal(function__, "person[sym1__]", person[(1 - 1)],
                               1);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 22;
          current_statement__ = 22;
          check_greater_or_equal(function__, "person[sym1__]",
                                 person[(sym1__ - 1)], 1);}
      } 
      current_statement__ = 22;
      if (lcm_sym43__) {
        current_statement__ = 22;
        current_statement__ = 22;
        check_less_or_equal(function__, "person[sym1__]", person[(1 - 1)], J);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 22;
          current_statement__ = 22;
          check_less_or_equal(function__, "person[sym1__]",
                              person[(sym1__ - 1)], J);}
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      current_statement__ = 2;
      validate_non_negative_index("eta1", "J", J);
      num_params_r__ += J;
      current_statement__ = 3;
      validate_non_negative_index("eta2", "J", J);
      num_params_r__ += J;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "off_small_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym42__;
      double lcm_sym41__;
      double lcm_sym40__;
      double lcm_sym39__;
      double lcm_sym38__;
      double lcm_sym37__;
      double lcm_sym36__;
      double lcm_sym35__;
      double lcm_sym34__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym33__;
      Eigen::Matrix<local_scalar_t__, -1, 1> lcm_sym32__;
      int lcm_sym31__;
      int lcm_sym30__;
      local_scalar_t__ beta;
      
      current_statement__ = 1;
      beta = in__.scalar();
      current_statement__ = 2;
      validate_non_negative_index("eta1", "J", J);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta1;
      eta1 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      
      current_statement__ = 2;
      eta1 = in__.vector(J);
      current_statement__ = 3;
      validate_non_negative_index("eta2", "J", J);
      Eigen::Matrix<local_scalar_t__, -1, 1> eta2;
      eta2 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      
      current_statement__ = 3;
      eta2 = in__.vector(J);
      local_scalar_t__ mu_a1;
      
      current_statement__ = 4;
      mu_a1 = in__.scalar();
      local_scalar_t__ mu_a2;
      
      current_statement__ = 5;
      mu_a2 = in__.scalar();
      local_scalar_t__ sigma_a1;
      
      current_statement__ = 6;
      sigma_a1 = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        sigma_a1 = stan::math::lub_constrain(sigma_a1, 0, 100, lp__);
      } else {
        current_statement__ = 6;
        sigma_a1 = stan::math::lub_constrain(sigma_a1, 0, 100);
      }
      local_scalar_t__ sigma_a2;
      
      current_statement__ = 7;
      sigma_a2 = in__.scalar();
      current_statement__ = 7;
      if (jacobian__) {
        current_statement__ = 7;
        sigma_a2 = stan::math::lub_constrain(sigma_a2, 0, 100, lp__);
      } else {
        current_statement__ = 7;
        sigma_a2 = stan::math::lub_constrain(sigma_a2, 0, 100);
      }
      local_scalar_t__ sigma_y;
      
      current_statement__ = 8;
      sigma_y = in__.scalar();
      current_statement__ = 8;
      if (jacobian__) {
        current_statement__ = 8;
        sigma_y = stan::math::lub_constrain(sigma_y, 0, 100, lp__);
      } else {
        current_statement__ = 8;
        sigma_y = stan::math::lub_constrain(sigma_y, 0, 100);
      }
      current_statement__ = 9;
      validate_non_negative_index("a1", "J", J);
      Eigen::Matrix<local_scalar_t__, -1, 1> a1;
      a1 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      
      lcm_sym30__ = logical_gte(J, 1);
      if (lcm_sym30__) {
        lcm_sym42__ = std::numeric_limits<double>::quiet_NaN();
        assign(a1, cons_list(index_uni(1), nil_index_list()), lcm_sym42__,
          "assigning variable a1");
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 9;
          assign(a1, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym42__, "assigning variable a1");}
      } 
      current_statement__ = 10;
      validate_non_negative_index("a2", "J", J);
      Eigen::Matrix<local_scalar_t__, -1, 1> a2;
      a2 = Eigen::Matrix<local_scalar_t__, -1, 1>(J);
      
      current_statement__ = 10;
      if (lcm_sym30__) {
        lcm_sym42__ = std::numeric_limits<double>::quiet_NaN();
        assign(a2, cons_list(index_uni(1), nil_index_list()), lcm_sym42__,
          "assigning variable a2");
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 10;
          assign(a2, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym42__, "assigning variable a2");}
      } 
      current_statement__ = 11;
      validate_non_negative_index("y_hat", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      lcm_sym31__ = logical_gte(N, 1);
      if (lcm_sym31__) {
        lcm_sym42__ = std::numeric_limits<double>::quiet_NaN();
        assign(y_hat, cons_list(index_uni(1), nil_index_list()), lcm_sym42__,
          "assigning variable y_hat");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 11;
          assign(y_hat, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym42__, "assigning variable y_hat");}
      } 
      assign(lcm_sym32__, nil_index_list(),
        add((10 * mu_a1), multiply(sigma_a1, eta1)),
        "assigning variable lcm_sym32__");
      assign(a1, nil_index_list(), lcm_sym32__, "assigning variable a1");
      assign(lcm_sym33__, nil_index_list(),
        add((0.1 * mu_a2), multiply(sigma_a2, eta2)),
        "assigning variable lcm_sym33__");
      assign(a2, nil_index_list(), lcm_sym33__, "assigning variable a2");
      current_statement__ = 13;
      if (lcm_sym31__) {
        current_statement__ = 12;
        assign(y_hat, cons_list(index_uni(1), nil_index_list()),
          stan::math::fma(lcm_sym33__[(person[(1 - 1)] - 1)], time[(1 - 1)],
            stan::math::fma((beta * time[(1 - 1)]), treatment[(1 - 1)],
              lcm_sym32__[(person[(1 - 1)] - 1)])),
          "assigning variable y_hat");
        for (size_t i = 2; i <= N; ++i) {
          current_statement__ = 12;
          assign(y_hat, cons_list(index_uni(i), nil_index_list()),
            stan::math::fma(lcm_sym33__[(person[(i - 1)] - 1)],
              time[(i - 1)],
              stan::math::fma((beta * time[(i - 1)]), treatment[(i - 1)],
                lcm_sym32__[(person[(i - 1)] - 1)])),
            "assigning variable y_hat");}
      } 
      {
        current_statement__ = 14;
        lp_accum__.add(normal_log<propto__>(mu_a1, 0, 1));
        current_statement__ = 15;
        lp_accum__.add(normal_log<propto__>(eta1, 0, 1));
        current_statement__ = 16;
        lp_accum__.add(normal_log<propto__>(mu_a2, 0, 1));
        current_statement__ = 17;
        lp_accum__.add(normal_log<propto__>(eta2, 0, 1));
        current_statement__ = 18;
        lp_accum__.add(normal_log<propto__>(beta, 0, 1));
        current_statement__ = 19;
        lp_accum__.add(normal_log<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "off_small_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      Eigen::Matrix<double, -1, 1> lcm_sym16__;
      Eigen::Matrix<double, -1, 1> lcm_sym15__;
      int lcm_sym14__;
      int lcm_sym13__;
      int lcm_sym12__;
      int lcm_sym11__;
      double beta;
      
      current_statement__ = 1;
      beta = in__.scalar();
      current_statement__ = 2;
      validate_non_negative_index("eta1", "J", J);
      Eigen::Matrix<double, -1, 1> eta1;
      eta1 = Eigen::Matrix<double, -1, 1>(J);
      
      current_statement__ = 2;
      eta1 = in__.vector(J);
      current_statement__ = 3;
      validate_non_negative_index("eta2", "J", J);
      Eigen::Matrix<double, -1, 1> eta2;
      eta2 = Eigen::Matrix<double, -1, 1>(J);
      
      current_statement__ = 3;
      eta2 = in__.vector(J);
      double mu_a1;
      
      current_statement__ = 4;
      mu_a1 = in__.scalar();
      double mu_a2;
      
      current_statement__ = 5;
      mu_a2 = in__.scalar();
      double sigma_a1;
      
      current_statement__ = 6;
      sigma_a1 = in__.scalar();
      current_statement__ = 6;
      sigma_a1 = stan::math::lub_constrain(sigma_a1, 0, 100);
      double sigma_a2;
      
      current_statement__ = 7;
      sigma_a2 = in__.scalar();
      current_statement__ = 7;
      sigma_a2 = stan::math::lub_constrain(sigma_a2, 0, 100);
      double sigma_y;
      
      current_statement__ = 8;
      sigma_y = in__.scalar();
      current_statement__ = 8;
      sigma_y = stan::math::lub_constrain(sigma_y, 0, 100);
      current_statement__ = 9;
      validate_non_negative_index("a1", "J", J);
      Eigen::Matrix<double, -1, 1> a1;
      a1 = Eigen::Matrix<double, -1, 1>(J);
      
      lcm_sym11__ = logical_gte(J, 1);
      if (lcm_sym11__) {
        lcm_sym19__ = std::numeric_limits<double>::quiet_NaN();
        assign(a1, cons_list(index_uni(1), nil_index_list()), lcm_sym19__,
          "assigning variable a1");
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 9;
          assign(a1, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym19__, "assigning variable a1");}
      } 
      current_statement__ = 10;
      validate_non_negative_index("a2", "J", J);
      Eigen::Matrix<double, -1, 1> a2;
      a2 = Eigen::Matrix<double, -1, 1>(J);
      
      current_statement__ = 10;
      if (lcm_sym11__) {
        lcm_sym19__ = std::numeric_limits<double>::quiet_NaN();
        assign(a2, cons_list(index_uni(1), nil_index_list()), lcm_sym19__,
          "assigning variable a2");
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          current_statement__ = 10;
          assign(a2, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym19__, "assigning variable a2");}
      } 
      current_statement__ = 11;
      validate_non_negative_index("y_hat", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      lcm_sym12__ = logical_gte(N, 1);
      if (lcm_sym12__) {
        lcm_sym19__ = std::numeric_limits<double>::quiet_NaN();
        assign(y_hat, cons_list(index_uni(1), nil_index_list()), lcm_sym19__,
          "assigning variable y_hat");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 11;
          assign(y_hat, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym19__, "assigning variable y_hat");}
      } 
      vars__.push_back(beta);
      if (lcm_sym11__) {
        vars__.push_back(eta1[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(eta1[(sym1__ - 1)]);}
      } 
      if (lcm_sym11__) {
        vars__.push_back(eta2[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(eta2[(sym1__ - 1)]);}
      } 
      vars__.push_back(mu_a1);
      vars__.push_back(mu_a2);
      vars__.push_back(sigma_a1);
      vars__.push_back(sigma_a2);
      vars__.push_back(sigma_y);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      assign(lcm_sym15__, nil_index_list(),
        add((10 * mu_a1), multiply(sigma_a1, eta1)),
        "assigning variable lcm_sym15__");
      assign(a1, nil_index_list(), lcm_sym15__, "assigning variable a1");
      assign(lcm_sym16__, nil_index_list(),
        add((0.1 * mu_a2), multiply(sigma_a2, eta2)),
        "assigning variable lcm_sym16__");
      assign(a2, nil_index_list(), lcm_sym16__, "assigning variable a2");
      current_statement__ = 13;
      if (lcm_sym12__) {
        current_statement__ = 12;
        assign(y_hat, cons_list(index_uni(1), nil_index_list()),
          stan::math::fma(lcm_sym16__[(person[(1 - 1)] - 1)], time[(1 - 1)],
            stan::math::fma((beta * time[(1 - 1)]), treatment[(1 - 1)],
              lcm_sym15__[(person[(1 - 1)] - 1)])),
          "assigning variable y_hat");
        for (size_t i = 2; i <= N; ++i) {
          current_statement__ = 12;
          assign(y_hat, cons_list(index_uni(i), nil_index_list()),
            stan::math::fma(lcm_sym16__[(person[(i - 1)] - 1)],
              time[(i - 1)],
              stan::math::fma((beta * time[(i - 1)]), treatment[(i - 1)],
                lcm_sym15__[(person[(i - 1)] - 1)])),
            "assigning variable y_hat");}
      } 
      if (lcm_sym11__) {
        vars__.push_back(lcm_sym15__[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(lcm_sym15__[(sym1__ - 1)]);}
      } 
      if (lcm_sym11__) {
        vars__.push_back(lcm_sym16__[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(lcm_sym16__[(sym1__ - 1)]);}
      } 
      if (lcm_sym12__) {
        vars__.push_back(y_hat[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(y_hat[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      double beta;
      
      current_statement__ = 1;
      beta = context__.vals_r("beta")[(1 - 1)];
      current_statement__ = 2;
      validate_non_negative_index("eta1", "J", J);
      Eigen::Matrix<double, -1, 1> eta1;
      eta1 = Eigen::Matrix<double, -1, 1>(J);
      
      {
        std::vector<double> eta1_flat__;
        current_statement__ = 2;
        assign(eta1_flat__, nil_index_list(), context__.vals_r("eta1"),
          "assigning variable eta1_flat__");
        current_statement__ = 2;
        pos__ = 1;
        lcm_sym1__ = logical_gte(J, 1);
        if (lcm_sym1__) {
          current_statement__ = 2;
          assign(eta1, cons_list(index_uni(1), nil_index_list()),
            eta1_flat__[(1 - 1)], "assigning variable eta1");
          current_statement__ = 2;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
            current_statement__ = 2;
            assign(eta1, cons_list(index_uni(sym1__), nil_index_list()),
              eta1_flat__[(pos__ - 1)], "assigning variable eta1");
            current_statement__ = 2;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 3;
      validate_non_negative_index("eta2", "J", J);
      Eigen::Matrix<double, -1, 1> eta2;
      eta2 = Eigen::Matrix<double, -1, 1>(J);
      
      {
        std::vector<double> eta2_flat__;
        current_statement__ = 3;
        assign(eta2_flat__, nil_index_list(), context__.vals_r("eta2"),
          "assigning variable eta2_flat__");
        current_statement__ = 3;
        pos__ = 1;
        current_statement__ = 3;
        if (lcm_sym1__) {
          current_statement__ = 3;
          assign(eta2, cons_list(index_uni(1), nil_index_list()),
            eta2_flat__[(1 - 1)], "assigning variable eta2");
          current_statement__ = 3;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
            current_statement__ = 3;
            assign(eta2, cons_list(index_uni(sym1__), nil_index_list()),
              eta2_flat__[(pos__ - 1)], "assigning variable eta2");
            current_statement__ = 3;
            pos__ = (pos__ + 1);}
        } 
      }
      double mu_a1;
      
      current_statement__ = 4;
      mu_a1 = context__.vals_r("mu_a1")[(1 - 1)];
      double mu_a2;
      
      current_statement__ = 5;
      mu_a2 = context__.vals_r("mu_a2")[(1 - 1)];
      double sigma_a1;
      
      current_statement__ = 6;
      sigma_a1 = context__.vals_r("sigma_a1")[(1 - 1)];
      current_statement__ = 6;
      sigma_a1 = stan::math::lub_free(sigma_a1, 0, 100);
      double sigma_a2;
      
      current_statement__ = 7;
      sigma_a2 = context__.vals_r("sigma_a2")[(1 - 1)];
      current_statement__ = 7;
      sigma_a2 = stan::math::lub_free(sigma_a2, 0, 100);
      double sigma_y;
      
      current_statement__ = 8;
      sigma_y = context__.vals_r("sigma_y")[(1 - 1)];
      current_statement__ = 8;
      sigma_y = stan::math::lub_free(sigma_y, 0, 100);
      vars__.push_back(beta);
      if (lcm_sym1__) {
        vars__.push_back(eta1[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(eta1[(sym1__ - 1)]);}
      } 
      if (lcm_sym1__) {
        vars__.push_back(eta2[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= J; ++sym1__) {
          vars__.push_back(eta2[(sym1__ - 1)]);}
      } 
      vars__.push_back(mu_a1);
      vars__.push_back(mu_a2);
      vars__.push_back(sigma_a1);
      vars__.push_back(sigma_a2);
      vars__.push_back(sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("beta");
    names__.push_back("eta1");
    names__.push_back("eta2");
    names__.push_back("mu_a1");
    names__.push_back("mu_a2");
    names__.push_back("sigma_a1");
    names__.push_back("sigma_a2");
    names__.push_back("sigma_y");
    names__.push_back("a1");
    names__.push_back("a2");
    names__.push_back("y_hat");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(J);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(J);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(J);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(J);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "beta");
    for (size_t sym53__ = 1; sym53__ <= J; ++sym53__) {
      {
        param_names__.push_back(std::string() + "eta1" + '.' + std::to_string(sym53__));
      }}
    for (size_t sym53__ = 1; sym53__ <= J; ++sym53__) {
      {
        param_names__.push_back(std::string() + "eta2" + '.' + std::to_string(sym53__));
      }}
    param_names__.push_back(std::string() + "mu_a1");
    param_names__.push_back(std::string() + "mu_a2");
    param_names__.push_back(std::string() + "sigma_a1");
    param_names__.push_back(std::string() + "sigma_a2");
    param_names__.push_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (size_t sym53__ = 1; sym53__ <= J; ++sym53__) {
        {
          param_names__.push_back(std::string() + "a1" + '.' + std::to_string(sym53__));
        }}
      for (size_t sym53__ = 1; sym53__ <= J; ++sym53__) {
        {
          param_names__.push_back(std::string() + "a2" + '.' + std::to_string(sym53__));
        }}
      for (size_t sym53__ = 1; sym53__ <= N; ++sym53__) {
        {
          param_names__.push_back(std::string() + "y_hat" + '.' + std::to_string(sym53__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "beta");
    for (size_t sym53__ = 1; sym53__ <= J; ++sym53__) {
      {
        param_names__.push_back(std::string() + "eta1" + '.' + std::to_string(sym53__));
      }}
    for (size_t sym53__ = 1; sym53__ <= J; ++sym53__) {
      {
        param_names__.push_back(std::string() + "eta2" + '.' + std::to_string(sym53__));
      }}
    param_names__.push_back(std::string() + "mu_a1");
    param_names__.push_back(std::string() + "mu_a2");
    param_names__.push_back(std::string() + "sigma_a1");
    param_names__.push_back(std::string() + "sigma_a2");
    param_names__.push_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (size_t sym53__ = 1; sym53__ <= J; ++sym53__) {
        {
          param_names__.push_back(std::string() + "a1" + '.' + std::to_string(sym53__));
        }}
      for (size_t sym53__ = 1; sym53__ <= J; ++sym53__) {
        {
          param_names__.push_back(std::string() + "a2" + '.' + std::to_string(sym53__));
        }}
      for (size_t sym53__ = 1; sym53__ <= N; ++sym53__) {
        {
          param_names__.push_back(std::string() + "y_hat" + '.' + std::to_string(sym53__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eta1\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"eta2\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"parameters\"},{\"name\":\"mu_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"a1\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"},{\"name\":\"a2\",\"type\":{\"name\":\"vector\",\"length\":" << J << "},\"block\":\"transformed_parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef off_small_model_namespace::off_small_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp optimizations.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace optimizations_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'optimizations.stan', line 20, column 4 to column 15)",
                                                      " (in 'optimizations.stan', line 21, column 4 to column 13)",
                                                      " (in 'optimizations.stan', line 22, column 4 to column 26)",
                                                      " (in 'optimizations.stan', line 23, column 4 to column 23)",
                                                      " (in 'optimizations.stan', line 24, column 4 to column 24)",
                                                      " (in 'optimizations.stan', line 27, column 4 to column 11)",
                                                      " (in 'optimizations.stan', line 5, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 2, column 33 to line 6, column 5)",
                                                      " (in 'optimizations.stan', line 9, column 8 to line 10, column 26)",
                                                      " (in 'optimizations.stan', line 8, column 20 to line 12, column 5)",
                                                      " (in 'optimizations.stan', line 30, column 17 to column 28)",
                                                      " (in 'optimizations.stan', line 31, column 33 to line 34, column 5)",
                                                      " (in 'optimizations.stan', line 36, column 8 to column 21)",
                                                      " (in 'optimizations.stan', line 35, column 4 to line 37, column 5)",
                                                      " (in 'optimizations.stan', line 41, column 16 to column 29)",
                                                      " (in 'optimizations.stan', line 40, column 12 to line 41, column 29)",
                                                      " (in 'optimizations.stan', line 39, column 8 to line 41, column 29)",
                                                      " (in 'optimizations.stan', line 38, column 4 to line 41, column 29)",
                                                      " (in 'optimizations.stan', line 44, column 10 to column 16)",
                                                      " (in 'optimizations.stan', line 43, column 8 to line 44, column 16)",
                                                      " (in 'optimizations.stan', line 45, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 42, column 21 to line 46, column 5)",
                                                      " (in 'optimizations.stan', line 42, column 4 to line 46, column 5)",
                                                      " (in 'optimizations.stan', line 49, column 10 to column 19)",
                                                      " (in 'optimizations.stan', line 48, column 8 to line 49, column 19)",
                                                      " (in 'optimizations.stan', line 50, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 47, column 21 to line 51, column 5)",
                                                      " (in 'optimizations.stan', line 47, column 4 to line 51, column 5)",
                                                      " (in 'optimizations.stan', line 54, column 10 to column 19)",
                                                      " (in 'optimizations.stan', line 53, column 8 to line 54, column 19)",
                                                      " (in 'optimizations.stan', line 55, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 52, column 21 to line 56, column 5)",
                                                      " (in 'optimizations.stan', line 52, column 4 to line 56, column 5)",
                                                      " (in 'optimizations.stan', line 57, column 4 to column 10)",
                                                      " (in 'optimizations.stan', line 58, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 60, column 6 to column 12)",
                                                      " (in 'optimizations.stan', line 59, column 4 to line 60, column 12)",
                                                      " (in 'optimizations.stan', line 61, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 64, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 65, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 66, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 68, column 6 to column 19)",
                                                      " (in 'optimizations.stan', line 69, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 70, column 4 to column 11)",
                                                      " (in 'optimizations.stan', line 71, column 4 to column 10)",
                                                      " (in 'optimizations.stan', line 72, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 74, column 6 to column 12)",
                                                      " (in 'optimizations.stan', line 73, column 4 to line 74, column 12)",
                                                      " (in 'optimizations.stan', line 75, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 78, column 4 to column 16)",
                                                      " (in 'optimizations.stan', line 80, column 8 to column 19)",
                                                      " (in 'optimizations.stan', line 82, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 79, column 4 to line 83, column 5)",
                                                      " (in 'optimizations.stan', line 85, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 87, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 84, column 4 to line 88, column 5)",
                                                      " (in 'optimizations.stan', line 90, column 11 to column 23)",
                                                      " (in 'optimizations.stan', line 90, column 4 to column 23)",
                                                      " (in 'optimizations.stan', line 15, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 14, column 18 to line 17, column 5)",
                                                      " (in 'optimizations.stan', line 97, column 20 to column 26)",
                                                      " (in 'optimizations.stan', line 97, column 4 to column 26)",
                                                      " (in 'optimizations.stan', line 98, column 22 to column 28)",
                                                      " (in 'optimizations.stan', line 100, column 6 to column 15)",
                                                      " (in 'optimizations.stan', line 99, column 4 to line 100, column 15)",
                                                      " (in 'optimizations.stan', line 102, column 6 to column 12)",
                                                      " (in 'optimizations.stan', line 101, column 4 to line 102, column 12)",
                                                      " (in 'optimizations.stan', line 106, column 6 to column 15)",
                                                      " (in 'optimizations.stan', line 108, column 6 to column 12)",
                                                      " (in 'optimizations.stan', line 112, column 8 to column 20)",
                                                      " (in 'optimizations.stan', line 115, column 8 to column 21)",
                                                      " (in 'optimizations.stan', line 111, column 4 to line 116, column 5)",
                                                      " (in 'optimizations.stan', line 119, column 12 to column 24)",
                                                      " (in 'optimizations.stan', line 118, column 8 to line 121, column 9)",
                                                      " (in 'optimizations.stan', line 117, column 4 to line 127, column 5)",
                                                      " (in 'optimizations.stan', line 128, column 4 to column 14)",
                                                      " (in 'optimizations.stan', line 132, column 6 to column 21)",
                                                      " (in 'optimizations.stan', line 129, column 4 to line 132, column 21)",
                                                      " (in 'optimizations.stan', line 134, column 4 to column 15)",
                                                      " (in 'optimizations.stan', line 137, column 8 to column 23)",
                                                      " (in 'optimizations.stan', line 138, column 8 to column 24)",
                                                      " (in 'optimizations.stan', line 135, column 4 to line 139, column 5)",
                                                      " (in 'optimizations.stan', line 140, column 4 to column 25)",
                                                      " (in 'optimizations.stan', line 143, column 4 to column 26)",
                                                      " (in 'optimizations.stan', line 144, column 4 to column 22)",
                                                      " (in 'optimizations.stan', line 146, column 6 to column 28)",
                                                      " (in 'optimizations.stan', line 145, column 4 to line 146, column 28)",
                                                      " (in 'optimizations.stan', line 147, column 4 to column 23)",
                                                      " (in 'optimizations.stan', line 4, column 10 to column 17)",
                                                      " (in 'optimizations.stan', line 3, column 8 to line 4, column 17)",
                                                      " (in 'optimizations.stan', line 10, column 12 to column 26)",
                                                      " (in 'optimizations.stan', line 11, column 8 to column 21)",
                                                      " (in 'optimizations.stan', line 16, column 8 to column 18)"};


template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
nrfun_lp(const T0__& x, const int& y, T_lp__& lp__, T_lp_accum__& lp_accum__,
         std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__>::type;
  
  try {
    int lcm_sym35__;
    {
      current_statement__ = 90;
      if (logical_gt(x, 342)) {
        current_statement__ = 89;
        return ;
      } 
      current_statement__ = 7;
      lp_accum__.add(y);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct nrfun_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
operator()(const T0__& x, const int& y, T_lp__& lp__,
           T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return nrfun_lp(x, y, lp__, lp_accum__, pstream__);
}
};

int
rfun(const int& y, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    int lcm_sym38__;
    int lcm_sym37__;
    int lcm_sym36__;
    {
      current_statement__ = 9;
      if (logical_gt(y, 2)) {
        current_statement__ = 91;
        return (y + 24);
      } 
      current_statement__ = 92;
      return (y + 2);
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct rfun_functor__ {
int
operator()(const int& y, std::ostream* pstream__)  const 
{
return rfun(y, pstream__);
}
};

template <bool propto__, typename T_lp__, typename T_lp_accum__>
int
rfun_lp(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  
  try {
    {
      current_statement__ = 59;
      lp_accum__.add(2);
      current_statement__ = 93;
      return 24;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct rfun_lp_functor__ {
template <bool propto__, typename T_lp__, typename T_lp_accum__>
int
operator()(T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__)  const 
{
return rfun_lp(lp__, lp_accum__, pstream__);
}
};

class optimizations_model : public model_base_crtp<optimizations_model> {

 private:
  int pos__;
 
 public:
  ~optimizations_model() { }
  
  std::string model_name() const { return "optimizations_model"; }
  
  optimizations_model(stan::io::var_context& context__,
                      unsigned int random_seed__ = 0,
                      std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "optimizations_model_namespace::optimizations_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      pos__ = 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 3;
      validate_non_negative_index("x_matrix", "3", 3);
      current_statement__ = 3;
      validate_non_negative_index("x_matrix", "2", 2);
      num_params_r__ += 3 * 2;
      current_statement__ = 4;
      validate_non_negative_index("x_vector", "2", 2);
      num_params_r__ += 2;
      current_statement__ = 5;
      validate_non_negative_index("x_cov", "2", 2);
      current_statement__ = 5;
      validate_non_negative_index("x_cov", "2", 2);
      num_params_r__ += 3;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "optimizations_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym79__;
      int lcm_sym78__;
      int lcm_sym77__;
      int lcm_sym76__;
      int lcm_sym75__;
      int lcm_sym74__;
      int lcm_sym73__;
      int lcm_sym72__;
      int lcm_sym71__;
      int lcm_sym70__;
      int lcm_sym69__;
      int lcm_sym68__;
      int lcm_sym67__;
      int lcm_sym66__;
      local_scalar_t__ theta;
      
      current_statement__ = 1;
      theta = in__.scalar();
      local_scalar_t__ phi;
      
      current_statement__ = 2;
      phi = in__.scalar();
      current_statement__ = 3;
      validate_non_negative_index("x_matrix", "3", 3);
      current_statement__ = 3;
      validate_non_negative_index("x_matrix", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_matrix;
      x_matrix = Eigen::Matrix<local_scalar_t__, -1, -1>(3, 2);
      
      current_statement__ = 3;
      x_matrix = in__.matrix(3, 2);
      current_statement__ = 4;
      validate_non_negative_index("x_vector", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> x_vector;
      x_vector = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      
      current_statement__ = 4;
      x_vector = in__.vector(2);
      current_statement__ = 5;
      validate_non_negative_index("x_cov", "2", 2);
      current_statement__ = 5;
      validate_non_negative_index("x_cov", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_cov;
      x_cov = Eigen::Matrix<local_scalar_t__, -1, -1>(2, 2);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> x_cov_in__;
      x_cov_in__ = Eigen::Matrix<local_scalar_t__, -1, 1>(3);
      
      current_statement__ = 5;
      x_cov_in__ = in__.vector(3);
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        assign(x_cov, nil_index_list(),
          stan::math::cov_matrix_constrain(x_cov_in__, 2, lp__),
          "assigning variable x_cov");
      } else {
        current_statement__ = 5;
        assign(x_cov, nil_index_list(),
          stan::math::cov_matrix_constrain(x_cov_in__, 2),
          "assigning variable x_cov");
      }
      {
        double x;
        
        int inline_sym1__;
        
        for (size_t inline_sym2__ = 1; inline_sym2__ <= 1; ++inline_sym2__) {
          current_statement__ = 7;
          lp_accum__.add(3);}
        int inline_sym3__;
        int inline_sym4__;
        
        for (size_t inline_sym5__ = 1; inline_sym5__ <= 1; ++inline_sym5__) {
          {
            inline_sym3__ = 27;
            break;
          }
          inline_sym3__ = 5;
          break;}
        if (pstream__) {
          stan_print(pstream__, inline_sym3__);
          stan_print(pstream__, "\n");
        }
        int inline_sym6__;
        int inline_sym7__;
        
        for (size_t inline_sym8__ = 1; inline_sym8__ <= 1; ++inline_sym8__) {
          {
            inline_sym6__ = 28;
            break;
          }
          inline_sym6__ = 6;
          break;}
        if (inline_sym6__) {
          current_statement__ = 11;
          if (pstream__) {
            stan_print(pstream__, "a");
            stan_print(pstream__, "\n");
          }
        } 
        int inline_sym9__;
        int inline_sym12__;
        int inline_sym10__;
        
        for (size_t inline_sym11__ = 1; inline_sym11__ <= 1; ++inline_sym11__) {
          {
            inline_sym9__ = 31;
            break;
          }
          inline_sym9__ = 9;
          break;}
        int inline_sym13__;
        
        for (size_t inline_sym14__ = 1; inline_sym14__ <= 1; ++inline_sym14__) {
          {
            inline_sym12__ = 29;
            break;
          }
          inline_sym12__ = 7;
          break;}
        if (logical_gte(inline_sym12__, inline_sym9__)) {
          {
            int inline_sym15__;
            int inline_sym16__;
            
            for (size_t inline_sym17__ = 1; inline_sym17__ <= 1;
                 ++inline_sym17__) {
              {
                inline_sym15__ = 32;
                break;
              }
              inline_sym15__ = 10;
              break;}
            lp_accum__.add(inline_sym15__);
            int inline_sym18__;
            
            for (size_t inline_sym19__ = 1; inline_sym19__ <= 1;
                 ++inline_sym19__) {
              current_statement__ = 7;
              lp_accum__.add(3);}
          }
          int inline_sym13__;
          
          lcm_sym75__ = (inline_sym9__ + 1);
          for (size_t inline_sym14__ = 1; inline_sym14__ <= 1;
               ++inline_sym14__) {
            {
              inline_sym12__ = 29;
              lcm_sym75__ = (inline_sym9__ + 1);
              break;
            }
            inline_sym12__ = 7;
            lcm_sym75__ = (inline_sym9__ + 1);
            break;}
          for (size_t i = lcm_sym75__; i <= inline_sym12__; ++i) {
            {
              int inline_sym15__;
              int inline_sym16__;
              
              for (size_t inline_sym17__ = 1; inline_sym17__ <= 1;
                   ++inline_sym17__) {
                {
                  inline_sym15__ = 32;
                  break;
                }
                inline_sym15__ = 10;
                break;}
              lp_accum__.add(inline_sym15__);
              int inline_sym18__;
              
              for (size_t inline_sym19__ = 1; inline_sym19__ <= 1;
                   ++inline_sym19__) {
                current_statement__ = 7;
                lp_accum__.add(3);}
            }
            int inline_sym13__;
            
            for (size_t inline_sym14__ = 1; inline_sym14__ <= 1;
                 ++inline_sym14__) {
              {
                inline_sym12__ = 29;
                break;
              }
              inline_sym12__ = 7;
              break;}}
        } 
        {
          current_statement__ = 13;
          lp_accum__.add(53);
          {
            current_statement__ = 13;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 13;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 13;
            lp_accum__.add(53);
          }
          {
            current_statement__ = 13;
            lp_accum__.add(53);
          }
        }
        {
          {
            {
              current_statement__ = 15;
              lp_accum__.add(53);
              {
                current_statement__ = 15;
                lp_accum__.add(53);
              }
            }
            {
              lcm_sym78__ = (2 * 2);
              if (logical_gte(lcm_sym78__, 2)) {
                lcm_sym76__ = (2 + 1);
                lp_accum__.add(53);
                for (size_t k = lcm_sym76__; k <= lcm_sym78__; ++k) {
                  current_statement__ = 15;
                  lp_accum__.add(53);}
              } 
            }
            {
              lcm_sym78__ = (3 * 2);
              if (logical_gte(lcm_sym78__, 3)) {
                lcm_sym76__ = (3 + 1);
                lp_accum__.add(53);
                for (size_t k = lcm_sym76__; k <= lcm_sym78__; ++k) {
                  current_statement__ = 15;
                  lp_accum__.add(53);}
              } 
            }
          }
          {
            lcm_sym74__ = (2 + 2);
            if (logical_gte(lcm_sym74__, 2)) {
              lcm_sym77__ = (2 * 2);
              if (logical_gte(lcm_sym77__, 2)) {
                {
                  lcm_sym73__ = (2 + 1);
                  lp_accum__.add(53);
                  for (size_t k = lcm_sym73__; k <= lcm_sym77__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);}
                }
              } else {
                lcm_sym73__ = (2 + 1);
              }
              for (size_t j = lcm_sym73__; j <= lcm_sym74__; ++j) {
                lcm_sym78__ = (j * 2);
                if (logical_gte(lcm_sym78__, j)) {
                  lcm_sym76__ = (j + 1);
                  lp_accum__.add(53);
                  for (size_t k = lcm_sym76__; k <= lcm_sym78__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);}
                } }
            } 
          }
          {
            lcm_sym74__ = (3 + 2);
            if (logical_gte(lcm_sym74__, 3)) {
              lcm_sym77__ = (3 * 2);
              if (logical_gte(lcm_sym77__, 3)) {
                {
                  lcm_sym73__ = (3 + 1);
                  lp_accum__.add(53);
                  for (size_t k = lcm_sym73__; k <= lcm_sym77__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);}
                }
              } else {
                lcm_sym73__ = (3 + 1);
              }
              for (size_t j = lcm_sym73__; j <= lcm_sym74__; ++j) {
                lcm_sym78__ = (j * 2);
                if (logical_gte(lcm_sym78__, j)) {
                  lcm_sym76__ = (j + 1);
                  lp_accum__.add(53);
                  for (size_t k = lcm_sym76__; k <= lcm_sym78__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);}
                } }
            } 
          }
          {
            lcm_sym74__ = (4 + 2);
            if (logical_gte(lcm_sym74__, 4)) {
              lcm_sym77__ = (4 * 2);
              if (logical_gte(lcm_sym77__, 4)) {
                {
                  lcm_sym73__ = (4 + 1);
                  lp_accum__.add(53);
                  for (size_t k = lcm_sym73__; k <= lcm_sym77__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);}
                }
              } else {
                lcm_sym73__ = (4 + 1);
              }
              for (size_t j = lcm_sym73__; j <= lcm_sym74__; ++j) {
                lcm_sym78__ = (j * 2);
                if (logical_gte(lcm_sym78__, j)) {
                  lcm_sym76__ = (j + 1);
                  lp_accum__.add(53);
                  for (size_t k = lcm_sym76__; k <= lcm_sym78__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);}
                } }
            } 
          }
          {
            lcm_sym74__ = (5 + 2);
            if (logical_gte(lcm_sym74__, 5)) {
              lcm_sym77__ = (5 * 2);
              if (logical_gte(lcm_sym77__, 5)) {
                {
                  lcm_sym73__ = (5 + 1);
                  lp_accum__.add(53);
                  for (size_t k = lcm_sym73__; k <= lcm_sym77__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);}
                }
              } else {
                lcm_sym73__ = (5 + 1);
              }
              for (size_t j = lcm_sym73__; j <= lcm_sym74__; ++j) {
                lcm_sym78__ = (j * 2);
                if (logical_gte(lcm_sym78__, j)) {
                  lcm_sym76__ = (j + 1);
                  lp_accum__.add(53);
                  for (size_t k = lcm_sym76__; k <= lcm_sym78__; ++k) {
                    current_statement__ = 15;
                    lp_accum__.add(53);}
                } }
            } 
          }
        }
        current_statement__ = 23;
        for (size_t i = 1; i <= 5; ++i) {
          current_statement__ = 20;
          if (logical_gt(i, 4)) {
            break;
          } 
          current_statement__ = 21;
          lp_accum__.add(2);}
        current_statement__ = 28;
        for (size_t i = 1; i <= 5; ++i) {
          current_statement__ = 25;
          if (logical_gt(i, 4)) {
            continue;
          } 
          current_statement__ = 26;
          lp_accum__.add(2);}
        current_statement__ = 33;
        for (size_t i = 1; i <= 5; ++i) {
          current_statement__ = 30;
          if (logical_gt(i, 4)) {
            continue;
          } 
          current_statement__ = 31;
          lp_accum__.add(2);}
        current_statement__ = 34;
        x = 3;
        current_statement__ = 35;
        lp_accum__.add(3);
        current_statement__ = 37;
        if (logical_gt(theta, 2)) {
          current_statement__ = 36;
          x = 2;
        } 
        current_statement__ = 38;
        lp_accum__.add(x);
        current_statement__ = 39;
        lp_accum__.add(247);
        current_statement__ = 40;
        x = 576;
        current_statement__ = 41;
        lp_accum__.add(576);
        lcm_sym72__ = logical_gt(theta, 46);
        if (lcm_sym72__) {
          current_statement__ = 42;
          x = 5880;
        } 
        current_statement__ = 43;
        lp_accum__.add(x);
        double z;
        
        current_statement__ = 45;
        z = x;
        current_statement__ = 46;
        lp_accum__.add(x);
        current_statement__ = 48;
        if (lcm_sym72__) {
          current_statement__ = 47;
          z = x;
        } 
        current_statement__ = 49;
        lp_accum__.add(z);
        current_statement__ = 50;
        lp_accum__.add(2);
        {
          double y;
          
          current_statement__ = 52;
          lp_accum__.add(24);
        }
        {
          double y;
          
          current_statement__ = 55;
          lp_accum__.add(245);
        }
        {
          current_statement__ = 57;
          lp_accum__.add(2);
        }
        int inline_sym20__;
        int inline_sym21__;
        
        for (size_t inline_sym22__ = 1; inline_sym22__ <= 1; ++inline_sym22__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          break;}
        current_statement__ = 62;
        while (576) {
          break;
        }
        int inline_sym23__;
        int inline_sym24__;
        
        for (size_t inline_sym25__ = 1; inline_sym25__ <= 1; ++inline_sym25__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          inline_sym23__ = 24;
          break;}
        while (inline_sym23__) {
          {
            break;
          }
          int inline_sym24__;
          
          for (size_t inline_sym25__ = 1; inline_sym25__ <= 1;
               ++inline_sym25__) {
            current_statement__ = 59;
            lp_accum__.add(2);
            inline_sym23__ = 24;
            break;}
        }
        current_statement__ = 65;
        for (size_t i = 31; i <= 225; ++i) { continue;}
        current_statement__ = 67;
        for (size_t i = 31; i <= 225; ++i) { break;}
        int inline_sym26__;
        int inline_sym27__;
        
        for (size_t inline_sym28__ = 1; inline_sym28__ <= 1; ++inline_sym28__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          inline_sym26__ = 24;
          break;}
        for (size_t i = inline_sym26__; i <= 225; ++i) { continue;}
        int inline_sym29__;
        int inline_sym30__;
        
        for (size_t inline_sym31__ = 1; inline_sym31__ <= 1; ++inline_sym31__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          inline_sym29__ = 24;
          break;}
        for (size_t i = inline_sym29__; i <= 225; ++i) { break;}
        int inline_sym32__;
        int inline_sym33__;
        
        for (size_t inline_sym34__ = 1; inline_sym34__ <= 1; ++inline_sym34__) {
          current_statement__ = 59;
          lp_accum__.add(2);
          break;}
        {
          current_statement__ = 70;
          lp_accum__.add(1);
          current_statement__ = 71;
          lp_accum__.add(24);
        }
        {
          {
            current_statement__ = 73;
            lp_accum__.add(1);
          }
        }
        double temp;
        
        {
          current_statement__ = 77;
          if (pstream__) {
            stan_print(pstream__, "hello");
            stan_print(pstream__, "\n");
          }
        }
        double temp2;
        
        {
          current_statement__ = 80;
          lp_accum__.add(4);
          current_statement__ = 81;
          lp_accum__.add(6);
          {
            current_statement__ = 80;
            lp_accum__.add(4);
            current_statement__ = 81;
            lp_accum__.add(6);
          }
        }
        double dataonlyvar;
        
        current_statement__ = 83;
        dataonlyvar = 3;
        current_statement__ = 84;
        lp_accum__.add(dataonlyvar);
        local_scalar_t__ paramvar;
        
        {
          current_statement__ = 86;
          paramvar = (theta * 34);
        }
        current_statement__ = 88;
        lp_accum__.add(paramvar);
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "optimizations_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym65__;
      double lcm_sym64__;
      double lcm_sym63__;
      double lcm_sym62__;
      double lcm_sym61__;
      double lcm_sym60__;
      double lcm_sym59__;
      double lcm_sym58__;
      double lcm_sym57__;
      double lcm_sym56__;
      int lcm_sym55__;
      int lcm_sym54__;
      double theta;
      
      current_statement__ = 1;
      theta = in__.scalar();
      double phi;
      
      current_statement__ = 2;
      phi = in__.scalar();
      current_statement__ = 3;
      validate_non_negative_index("x_matrix", "3", 3);
      current_statement__ = 3;
      validate_non_negative_index("x_matrix", "2", 2);
      Eigen::Matrix<double, -1, -1> x_matrix;
      x_matrix = Eigen::Matrix<double, -1, -1>(3, 2);
      
      current_statement__ = 3;
      x_matrix = in__.matrix(3, 2);
      current_statement__ = 4;
      validate_non_negative_index("x_vector", "2", 2);
      Eigen::Matrix<double, -1, 1> x_vector;
      x_vector = Eigen::Matrix<double, -1, 1>(2);
      
      current_statement__ = 4;
      x_vector = in__.vector(2);
      current_statement__ = 5;
      validate_non_negative_index("x_cov", "2", 2);
      current_statement__ = 5;
      validate_non_negative_index("x_cov", "2", 2);
      Eigen::Matrix<double, -1, -1> x_cov;
      x_cov = Eigen::Matrix<double, -1, -1>(2, 2);
      
      Eigen::Matrix<double, -1, 1> x_cov_in__;
      x_cov_in__ = Eigen::Matrix<double, -1, 1>(3);
      
      current_statement__ = 5;
      x_cov_in__ = in__.vector(3);
      current_statement__ = 5;
      assign(x_cov, nil_index_list(),
        stan::math::cov_matrix_constrain(x_cov_in__, 2),
        "assigning variable x_cov");
      vars__.push_back(theta);
      vars__.push_back(phi);
      {
        {
          vars__.push_back(
            rvalue(x_matrix,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "x_matrix"));
          {
            vars__.push_back(
              rvalue(x_matrix,
                cons_list(index_uni(2),
                  cons_list(index_uni(1), nil_index_list())), "x_matrix"));
          }
          {
            vars__.push_back(
              rvalue(x_matrix,
                cons_list(index_uni(3),
                  cons_list(index_uni(1), nil_index_list())), "x_matrix"));
          }
        }
        {
          {
            vars__.push_back(
              rvalue(x_matrix,
                cons_list(index_uni(1),
                  cons_list(index_uni(2), nil_index_list())), "x_matrix"));
            {
              vars__.push_back(
                rvalue(x_matrix,
                  cons_list(index_uni(2),
                    cons_list(index_uni(2), nil_index_list())), "x_matrix"));
            }
            {
              vars__.push_back(
                rvalue(x_matrix,
                  cons_list(index_uni(3),
                    cons_list(index_uni(2), nil_index_list())), "x_matrix"));
            }
          }
        }
      }
      {
        vars__.push_back(x_vector[(1 - 1)]);
        {
          vars__.push_back(x_vector[(2 - 1)]);
        }
      }
      {
        {
          vars__.push_back(
            rvalue(x_cov,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "x_cov"));
          {
            vars__.push_back(
              rvalue(x_cov,
                cons_list(index_uni(2),
                  cons_list(index_uni(1), nil_index_list())), "x_cov"));
          }
        }
        {
          {
            vars__.push_back(
              rvalue(x_cov,
                cons_list(index_uni(1),
                  cons_list(index_uni(2), nil_index_list())), "x_cov"));
            {
              vars__.push_back(
                rvalue(x_cov,
                  cons_list(index_uni(2),
                    cons_list(index_uni(2), nil_index_list())), "x_cov"));
            }
          }
        }
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym53__;
      double lcm_sym52__;
      double lcm_sym51__;
      double lcm_sym50__;
      double lcm_sym49__;
      double lcm_sym48__;
      double lcm_sym47__;
      double lcm_sym46__;
      double lcm_sym45__;
      double lcm_sym44__;
      double lcm_sym43__;
      double lcm_sym42__;
      double lcm_sym41__;
      double lcm_sym40__;
      int lcm_sym39__;
      int pos__;
      
      pos__ = 1;
      double theta;
      
      current_statement__ = 1;
      theta = context__.vals_r("theta")[(1 - 1)];
      double phi;
      
      current_statement__ = 2;
      phi = context__.vals_r("phi")[(1 - 1)];
      current_statement__ = 3;
      validate_non_negative_index("x_matrix", "3", 3);
      current_statement__ = 3;
      validate_non_negative_index("x_matrix", "2", 2);
      Eigen::Matrix<double, -1, -1> x_matrix;
      x_matrix = Eigen::Matrix<double, -1, -1>(3, 2);
      
      {
        std::vector<double> x_matrix_flat__;
        current_statement__ = 3;
        assign(x_matrix_flat__, nil_index_list(),
          context__.vals_r("x_matrix"), "assigning variable x_matrix_flat__");
        current_statement__ = 3;
        pos__ = 1;
        {
          {
            current_statement__ = 3;
            assign(x_matrix,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              x_matrix_flat__[(1 - 1)], "assigning variable x_matrix");
            current_statement__ = 3;
            pos__ = 2;
            {
              current_statement__ = 3;
              assign(x_matrix,
                cons_list(index_uni(2),
                  cons_list(index_uni(1), nil_index_list())),
                x_matrix_flat__[(pos__ - 1)], "assigning variable x_matrix");
              current_statement__ = 3;
              pos__ = (pos__ + 1);
            }
            {
              current_statement__ = 3;
              assign(x_matrix,
                cons_list(index_uni(3),
                  cons_list(index_uni(1), nil_index_list())),
                x_matrix_flat__[(pos__ - 1)], "assigning variable x_matrix");
              current_statement__ = 3;
              pos__ = (pos__ + 1);
            }
          }
          {
            {
              current_statement__ = 3;
              assign(x_matrix,
                cons_list(index_uni(1),
                  cons_list(index_uni(2), nil_index_list())),
                x_matrix_flat__[(pos__ - 1)], "assigning variable x_matrix");
              current_statement__ = 3;
              pos__ = (pos__ + 1);
              {
                current_statement__ = 3;
                assign(x_matrix,
                  cons_list(index_uni(2),
                    cons_list(index_uni(2), nil_index_list())),
                  x_matrix_flat__[(pos__ - 1)], "assigning variable x_matrix");
                current_statement__ = 3;
                pos__ = (pos__ + 1);
              }
              {
                current_statement__ = 3;
                assign(x_matrix,
                  cons_list(index_uni(3),
                    cons_list(index_uni(2), nil_index_list())),
                  x_matrix_flat__[(pos__ - 1)], "assigning variable x_matrix");
                current_statement__ = 3;
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 4;
      validate_non_negative_index("x_vector", "2", 2);
      Eigen::Matrix<double, -1, 1> x_vector;
      x_vector = Eigen::Matrix<double, -1, 1>(2);
      
      {
        std::vector<double> x_vector_flat__;
        current_statement__ = 4;
        assign(x_vector_flat__, nil_index_list(),
          context__.vals_r("x_vector"), "assigning variable x_vector_flat__");
        current_statement__ = 4;
        pos__ = 1;
        {
          current_statement__ = 4;
          assign(x_vector, cons_list(index_uni(1), nil_index_list()),
            x_vector_flat__[(1 - 1)], "assigning variable x_vector");
          current_statement__ = 4;
          pos__ = 2;
          {
            current_statement__ = 4;
            assign(x_vector, cons_list(index_uni(2), nil_index_list()),
              x_vector_flat__[(pos__ - 1)], "assigning variable x_vector");
            current_statement__ = 4;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 5;
      validate_non_negative_index("x_cov", "2", 2);
      current_statement__ = 5;
      validate_non_negative_index("x_cov", "2", 2);
      Eigen::Matrix<double, -1, -1> x_cov;
      x_cov = Eigen::Matrix<double, -1, -1>(2, 2);
      
      {
        std::vector<double> x_cov_flat__;
        current_statement__ = 5;
        assign(x_cov_flat__, nil_index_list(), context__.vals_r("x_cov"),
          "assigning variable x_cov_flat__");
        current_statement__ = 5;
        pos__ = 1;
        {
          {
            current_statement__ = 5;
            assign(x_cov,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              x_cov_flat__[(1 - 1)], "assigning variable x_cov");
            current_statement__ = 5;
            pos__ = 2;
            {
              current_statement__ = 5;
              assign(x_cov,
                cons_list(index_uni(2),
                  cons_list(index_uni(1), nil_index_list())),
                x_cov_flat__[(pos__ - 1)], "assigning variable x_cov");
              current_statement__ = 5;
              pos__ = (pos__ + 1);
            }
          }
          {
            {
              current_statement__ = 5;
              assign(x_cov,
                cons_list(index_uni(1),
                  cons_list(index_uni(2), nil_index_list())),
                x_cov_flat__[(pos__ - 1)], "assigning variable x_cov");
              current_statement__ = 5;
              pos__ = (pos__ + 1);
              {
                current_statement__ = 5;
                assign(x_cov,
                  cons_list(index_uni(2),
                    cons_list(index_uni(2), nil_index_list())),
                  x_cov_flat__[(pos__ - 1)], "assigning variable x_cov");
                current_statement__ = 5;
                pos__ = (pos__ + 1);
              }
            }
          }
        }
      }
      current_statement__ = 5;
      validate_non_negative_index("x_cov_free__",
                                  "(2 + ((2 * (2 - 1)) / 2))", 3);
      Eigen::Matrix<double, -1, 1> x_cov_free__;
      x_cov_free__ = Eigen::Matrix<double, -1, 1>(3);
      
      current_statement__ = 5;
      assign(x_cov_free__, nil_index_list(),
        stan::math::cov_matrix_free(x_cov), "assigning variable x_cov_free__");
      vars__.push_back(theta);
      vars__.push_back(phi);
      {
        {
          vars__.push_back(
            rvalue(x_matrix,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "x_matrix"));
          {
            vars__.push_back(
              rvalue(x_matrix,
                cons_list(index_uni(2),
                  cons_list(index_uni(1), nil_index_list())), "x_matrix"));
          }
          {
            vars__.push_back(
              rvalue(x_matrix,
                cons_list(index_uni(3),
                  cons_list(index_uni(1), nil_index_list())), "x_matrix"));
          }
        }
        {
          {
            vars__.push_back(
              rvalue(x_matrix,
                cons_list(index_uni(1),
                  cons_list(index_uni(2), nil_index_list())), "x_matrix"));
            {
              vars__.push_back(
                rvalue(x_matrix,
                  cons_list(index_uni(2),
                    cons_list(index_uni(2), nil_index_list())), "x_matrix"));
            }
            {
              vars__.push_back(
                rvalue(x_matrix,
                  cons_list(index_uni(3),
                    cons_list(index_uni(2), nil_index_list())), "x_matrix"));
            }
          }
        }
      }
      {
        vars__.push_back(x_vector[(1 - 1)]);
        {
          vars__.push_back(x_vector[(2 - 1)]);
        }
      }
      {
        vars__.push_back(x_cov_free__[(1 - 1)]);
        {
          vars__.push_back(x_cov_free__[(2 - 1)]);
        }
        {
          vars__.push_back(x_cov_free__[(3 - 1)]);
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("theta");
    names__.push_back("phi");
    names__.push_back("x_matrix");
    names__.push_back("x_vector");
    names__.push_back("x_cov");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(3);
    
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "theta");
    param_names__.push_back(std::string() + "phi");
    for (size_t sym80__ = 1; sym80__ <= 2; ++sym80__) {
      {
        for (size_t sym81__ = 1; sym81__ <= 3; ++sym81__) {
          {
            param_names__.push_back(std::string() + "x_matrix" + '.' + std::to_string(sym81__) + '.' + std::to_string(sym80__));
          }}
      }}
    for (size_t sym80__ = 1; sym80__ <= 2; ++sym80__) {
      {
        param_names__.push_back(std::string() + "x_vector" + '.' + std::to_string(sym80__));
      }}
    for (size_t sym80__ = 1; sym80__ <= 2; ++sym80__) {
      {
        for (size_t sym81__ = 1; sym81__ <= 2; ++sym81__) {
          {
            param_names__.push_back(std::string() + "x_cov" + '.' + std::to_string(sym81__) + '.' + std::to_string(sym80__));
          }}
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "theta");
    param_names__.push_back(std::string() + "phi");
    for (size_t sym80__ = 1; sym80__ <= 2; ++sym80__) {
      {
        for (size_t sym81__ = 1; sym81__ <= 3; ++sym81__) {
          {
            param_names__.push_back(std::string() + "x_matrix" + '.' + std::to_string(sym81__) + '.' + std::to_string(sym80__));
          }}
      }}
    for (size_t sym80__ = 1; sym80__ <= 2; ++sym80__) {
      {
        param_names__.push_back(std::string() + "x_vector" + '.' + std::to_string(sym80__));
      }}
    for (size_t sym80__ = 1; sym80__ <= 3; ++sym80__) {
      {
        param_names__.push_back(std::string() + "x_cov" + '.' + std::to_string(sym80__));
      }}
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"matrix\",\"rows\":" << 2 << ",\"cols\":" << 2 << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_matrix\",\"type\":{\"name\":\"matrix\",\"rows\":" << 3 << ",\"cols\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"x_vector\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"x_cov\",\"type\":{\"name\":\"vector\",\"length\":" << 3 << "},\"block\":\"parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef optimizations_model_namespace::optimizations_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp partial-eval.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace partial_eval_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'partial-eval.stan', line 10, column 2 to column 19)",
                                                      " (in 'partial-eval.stan', line 11, column 2 to column 17)",
                                                      " (in 'partial-eval.stan', line 12, column 2 to column 12)",
                                                      " (in 'partial-eval.stan', line 13, column 2 to column 34)",
                                                      " (in 'partial-eval.stan', line 14, column 2 to column 34)",
                                                      " (in 'partial-eval.stan', line 17, column 2 to column 18)",
                                                      " (in 'partial-eval.stan', line 20, column 4 to line 21, column 42)",
                                                      " (in 'partial-eval.stan', line 19, column 2 to line 21, column 42)",
                                                      " (in 'partial-eval.stan', line 24, column 2 to column 22)",
                                                      " (in 'partial-eval.stan', line 25, column 2 to column 34)",
                                                      " (in 'partial-eval.stan', line 26, column 2 to column 24)",
                                                      " (in 'partial-eval.stan', line 27, column 2 to column 29)",
                                                      " (in 'partial-eval.stan', line 2, column 2 to column 17)",
                                                      " (in 'partial-eval.stan', line 3, column 2 to column 22)",
                                                      " (in 'partial-eval.stan', line 4, column 2 to column 36)",
                                                      " (in 'partial-eval.stan', line 5, column 2 to column 21)",
                                                      " (in 'partial-eval.stan', line 6, column 2 to column 39)",
                                                      " (in 'partial-eval.stan', line 7, column 2 to column 14)"};



class partial_eval_model : public model_base_crtp<partial_eval_model> {

 private:
  double lcm_sym41__;
  double lcm_sym40__;
  double lcm_sym39__;
  double lcm_sym38__;
  double lcm_sym37__;
  double lcm_sym36__;
  int lcm_sym35__;
  int lcm_sym34__;
  int lcm_sym33__;
  int lcm_sym32__;
  int pos__;
  int N;
  int n_pair;
  std::vector<int> pair;
  Eigen::Matrix<double, -1, 1> pre_test;
  Eigen::Matrix<double, -1, 1> treatment;
  Eigen::Matrix<double, -1, 1> y;
 
 public:
  ~partial_eval_model() { }
  
  std::string model_name() const { return "partial_eval_model"; }
  
  partial_eval_model(stan::io::var_context& context__,
                     unsigned int random_seed__ = 0,
                     std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "partial_eval_model_namespace::partial_eval_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","N","int",
          context__.to_vec());
      
      current_statement__ = 13;
      N = context__.vals_i("N")[(1 - 1)];
      context__.validate_dims("data initialization","n_pair","int",
          context__.to_vec());
      
      current_statement__ = 14;
      n_pair = context__.vals_i("n_pair")[(1 - 1)];
      current_statement__ = 15;
      validate_non_negative_index("pair", "N", N);
      context__.validate_dims("data initialization","pair","int",
          context__.to_vec(N));
      pair = std::vector<int>(N, 0);
      
      current_statement__ = 15;
      assign(pair, nil_index_list(), context__.vals_i("pair"),
        "assigning variable pair");
      current_statement__ = 16;
      validate_non_negative_index("pre_test", "N", N);
      context__.validate_dims("data initialization","pre_test","double",
          context__.to_vec(N));
      pre_test = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> pre_test_flat__;
        current_statement__ = 16;
        assign(pre_test_flat__, nil_index_list(),
          context__.vals_r("pre_test"), "assigning variable pre_test_flat__");
        current_statement__ = 16;
        pos__ = 1;
        lcm_sym32__ = logical_gte(N, 1);
        if (lcm_sym32__) {
          current_statement__ = 16;
          assign(pre_test, cons_list(index_uni(1), nil_index_list()),
            pre_test_flat__[(1 - 1)], "assigning variable pre_test");
          current_statement__ = 16;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 16;
            assign(pre_test, cons_list(index_uni(sym1__), nil_index_list()),
              pre_test_flat__[(pos__ - 1)], "assigning variable pre_test");
            current_statement__ = 16;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 17;
      validate_non_negative_index("treatment", "N", N);
      context__.validate_dims("data initialization","treatment","double",
          context__.to_vec(N));
      treatment = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> treatment_flat__;
        current_statement__ = 17;
        assign(treatment_flat__, nil_index_list(),
          context__.vals_r("treatment"),
          "assigning variable treatment_flat__");
        current_statement__ = 17;
        pos__ = 1;
        current_statement__ = 17;
        if (lcm_sym32__) {
          current_statement__ = 17;
          assign(treatment, cons_list(index_uni(1), nil_index_list()),
            treatment_flat__[(1 - 1)], "assigning variable treatment");
          current_statement__ = 17;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 17;
            assign(treatment, cons_list(index_uni(sym1__), nil_index_list()),
              treatment_flat__[(pos__ - 1)], "assigning variable treatment");
            current_statement__ = 17;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 18;
      validate_non_negative_index("y", "N", N);
      context__.validate_dims("data initialization","y","double",
          context__.to_vec(N));
      y = Eigen::Matrix<double, -1, 1>(N);
      
      {
        std::vector<double> y_flat__;
        current_statement__ = 18;
        assign(y_flat__, nil_index_list(), context__.vals_r("y"),
          "assigning variable y_flat__");
        current_statement__ = 18;
        pos__ = 1;
        current_statement__ = 18;
        if (lcm_sym32__) {
          current_statement__ = 18;
          assign(y, cons_list(index_uni(1), nil_index_list()),
            y_flat__[(1 - 1)], "assigning variable y");
          current_statement__ = 18;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
            current_statement__ = 18;
            assign(y, cons_list(index_uni(sym1__), nil_index_list()),
              y_flat__[(pos__ - 1)], "assigning variable y");
            current_statement__ = 18;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 13;
      current_statement__ = 13;
      check_greater_or_equal(function__, "N", N, 0);
      current_statement__ = 14;
      current_statement__ = 14;
      check_greater_or_equal(function__, "n_pair", n_pair, 0);
      current_statement__ = 15;
      if (lcm_sym32__) {
        current_statement__ = 15;
        current_statement__ = 15;
        check_greater_or_equal(function__, "pair[sym1__]", pair[(1 - 1)], 1);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "pair[sym1__]",
                                 pair[(sym1__ - 1)], 1);}
      } 
      current_statement__ = 15;
      if (lcm_sym32__) {
        current_statement__ = 15;
        current_statement__ = 15;
        check_less_or_equal(function__, "pair[sym1__]", pair[(1 - 1)], n_pair);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_less_or_equal(function__, "pair[sym1__]", pair[(sym1__ - 1)],
                              n_pair);}
      } 
      current_statement__ = 17;
      current_statement__ = 17;
      check_greater_or_equal(function__, "treatment", treatment, 0);
      current_statement__ = 17;
      current_statement__ = 17;
      check_less_or_equal(function__, "treatment", treatment, 1);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      current_statement__ = 1;
      validate_non_negative_index("a", "n_pair", n_pair);
      num_params_r__ += n_pair;
      current_statement__ = 2;
      validate_non_negative_index("beta", "2", 2);
      num_params_r__ += 2;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "partial_eval_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym31__;
      double lcm_sym30__;
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      int lcm_sym24__;
      current_statement__ = 1;
      validate_non_negative_index("a", "n_pair", n_pair);
      Eigen::Matrix<local_scalar_t__, -1, 1> a;
      a = Eigen::Matrix<local_scalar_t__, -1, 1>(n_pair);
      
      current_statement__ = 1;
      a = in__.vector(n_pair);
      current_statement__ = 2;
      validate_non_negative_index("beta", "2", 2);
      Eigen::Matrix<local_scalar_t__, -1, 1> beta;
      beta = Eigen::Matrix<local_scalar_t__, -1, 1>(2);
      
      current_statement__ = 2;
      beta = in__.vector(2);
      local_scalar_t__ mu_a;
      
      current_statement__ = 3;
      mu_a = in__.scalar();
      local_scalar_t__ sigma_a;
      
      current_statement__ = 4;
      sigma_a = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        sigma_a = stan::math::lub_constrain(sigma_a, 0, 100, lp__);
      } else {
        current_statement__ = 4;
        sigma_a = stan::math::lub_constrain(sigma_a, 0, 100);
      }
      local_scalar_t__ sigma_y;
      
      current_statement__ = 5;
      sigma_y = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        sigma_y = stan::math::lub_constrain(sigma_y, 0, 100, lp__);
      } else {
        current_statement__ = 5;
        sigma_y = stan::math::lub_constrain(sigma_y, 0, 100);
      }
      current_statement__ = 6;
      validate_non_negative_index("y_hat", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      lcm_sym24__ = logical_gte(N, 1);
      if (lcm_sym24__) {
        lcm_sym31__ = std::numeric_limits<double>::quiet_NaN();
        assign(y_hat, cons_list(index_uni(1), nil_index_list()), lcm_sym31__,
          "assigning variable y_hat");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 6;
          assign(y_hat, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym31__, "assigning variable y_hat");}
      } 
      current_statement__ = 8;
      if (lcm_sym24__) {
        current_statement__ = 7;
        assign(y_hat, cons_list(index_uni(1), nil_index_list()),
          stan::math::fma(beta[(2 - 1)], pre_test[(1 - 1)],
            stan::math::fma(beta[(1 - 1)], treatment[(1 - 1)],
              a[(pair[(1 - 1)] - 1)])), "assigning variable y_hat");
        for (size_t i = 2; i <= N; ++i) {
          current_statement__ = 7;
          assign(y_hat, cons_list(index_uni(i), nil_index_list()),
            stan::math::fma(beta[(2 - 1)], pre_test[(i - 1)],
              stan::math::fma(beta[(1 - 1)], treatment[(i - 1)],
                a[(pair[(i - 1)] - 1)])), "assigning variable y_hat");}
      } 
      {
        current_statement__ = 9;
        lp_accum__.add(normal_log<propto__>(mu_a, 0, 1));
        current_statement__ = 10;
        lp_accum__.add(normal_log<propto__>(a, (100 * mu_a), sigma_a));
        current_statement__ = 11;
        lp_accum__.add(normal_log<propto__>(beta, 0, 100));
        current_statement__ = 12;
        lp_accum__.add(normal_log<propto__>(y, y_hat, sigma_y));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "partial_eval_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      double lcm_sym19__;
      double lcm_sym18__;
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      int lcm_sym14__;
      int lcm_sym13__;
      int lcm_sym12__;
      int lcm_sym11__;
      current_statement__ = 1;
      validate_non_negative_index("a", "n_pair", n_pair);
      Eigen::Matrix<double, -1, 1> a;
      a = Eigen::Matrix<double, -1, 1>(n_pair);
      
      current_statement__ = 1;
      a = in__.vector(n_pair);
      current_statement__ = 2;
      validate_non_negative_index("beta", "2", 2);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(2);
      
      current_statement__ = 2;
      beta = in__.vector(2);
      double mu_a;
      
      current_statement__ = 3;
      mu_a = in__.scalar();
      double sigma_a;
      
      current_statement__ = 4;
      sigma_a = in__.scalar();
      current_statement__ = 4;
      sigma_a = stan::math::lub_constrain(sigma_a, 0, 100);
      double sigma_y;
      
      current_statement__ = 5;
      sigma_y = in__.scalar();
      current_statement__ = 5;
      sigma_y = stan::math::lub_constrain(sigma_y, 0, 100);
      current_statement__ = 6;
      validate_non_negative_index("y_hat", "N", N);
      Eigen::Matrix<local_scalar_t__, -1, 1> y_hat;
      y_hat = Eigen::Matrix<local_scalar_t__, -1, 1>(N);
      
      lcm_sym11__ = logical_gte(N, 1);
      if (lcm_sym11__) {
        lcm_sym17__ = std::numeric_limits<double>::quiet_NaN();
        assign(y_hat, cons_list(index_uni(1), nil_index_list()), lcm_sym17__,
          "assigning variable y_hat");
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          current_statement__ = 6;
          assign(y_hat, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym17__, "assigning variable y_hat");}
      } 
      if (logical_gte(n_pair, 1)) {
        vars__.push_back(a[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_pair; ++sym1__) {
          vars__.push_back(a[(sym1__ - 1)]);}
      } 
      {
        vars__.push_back(beta[(1 - 1)]);
        {
          vars__.push_back(beta[(2 - 1)]);
        }
      }
      vars__.push_back(mu_a);
      vars__.push_back(sigma_a);
      vars__.push_back(sigma_y);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 8;
      if (lcm_sym11__) {
        current_statement__ = 7;
        assign(y_hat, cons_list(index_uni(1), nil_index_list()),
          stan::math::fma(beta[(2 - 1)], pre_test[(1 - 1)],
            stan::math::fma(beta[(1 - 1)], treatment[(1 - 1)],
              a[(pair[(1 - 1)] - 1)])), "assigning variable y_hat");
        for (size_t i = 2; i <= N; ++i) {
          current_statement__ = 7;
          assign(y_hat, cons_list(index_uni(i), nil_index_list()),
            stan::math::fma(beta[(2 - 1)], pre_test[(i - 1)],
              stan::math::fma(beta[(1 - 1)], treatment[(i - 1)],
                a[(pair[(i - 1)] - 1)])), "assigning variable y_hat");}
      } 
      if (lcm_sym11__) {
        vars__.push_back(y_hat[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= N; ++sym1__) {
          vars__.push_back(y_hat[(sym1__ - 1)]);}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym10__;
      double lcm_sym9__;
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("a", "n_pair", n_pair);
      Eigen::Matrix<double, -1, 1> a;
      a = Eigen::Matrix<double, -1, 1>(n_pair);
      
      {
        std::vector<double> a_flat__;
        current_statement__ = 1;
        assign(a_flat__, nil_index_list(), context__.vals_r("a"),
          "assigning variable a_flat__");
        current_statement__ = 1;
        pos__ = 1;
        lcm_sym1__ = logical_gte(n_pair, 1);
        if (lcm_sym1__) {
          current_statement__ = 1;
          assign(a, cons_list(index_uni(1), nil_index_list()),
            a_flat__[(1 - 1)], "assigning variable a");
          current_statement__ = 1;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= n_pair; ++sym1__) {
            current_statement__ = 1;
            assign(a, cons_list(index_uni(sym1__), nil_index_list()),
              a_flat__[(pos__ - 1)], "assigning variable a");
            current_statement__ = 1;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 2;
      validate_non_negative_index("beta", "2", 2);
      Eigen::Matrix<double, -1, 1> beta;
      beta = Eigen::Matrix<double, -1, 1>(2);
      
      {
        std::vector<double> beta_flat__;
        current_statement__ = 2;
        assign(beta_flat__, nil_index_list(), context__.vals_r("beta"),
          "assigning variable beta_flat__");
        current_statement__ = 2;
        pos__ = 1;
        {
          current_statement__ = 2;
          assign(beta, cons_list(index_uni(1), nil_index_list()),
            beta_flat__[(1 - 1)], "assigning variable beta");
          current_statement__ = 2;
          pos__ = 2;
          {
            current_statement__ = 2;
            assign(beta, cons_list(index_uni(2), nil_index_list()),
              beta_flat__[(pos__ - 1)], "assigning variable beta");
            current_statement__ = 2;
            pos__ = (pos__ + 1);
          }
        }
      }
      double mu_a;
      
      current_statement__ = 3;
      mu_a = context__.vals_r("mu_a")[(1 - 1)];
      double sigma_a;
      
      current_statement__ = 4;
      sigma_a = context__.vals_r("sigma_a")[(1 - 1)];
      current_statement__ = 4;
      sigma_a = stan::math::lub_free(sigma_a, 0, 100);
      double sigma_y;
      
      current_statement__ = 5;
      sigma_y = context__.vals_r("sigma_y")[(1 - 1)];
      current_statement__ = 5;
      sigma_y = stan::math::lub_free(sigma_y, 0, 100);
      if (lcm_sym1__) {
        vars__.push_back(a[(1 - 1)]);
        for (size_t sym1__ = 2; sym1__ <= n_pair; ++sym1__) {
          vars__.push_back(a[(sym1__ - 1)]);}
      } 
      {
        vars__.push_back(beta[(1 - 1)]);
        {
          vars__.push_back(beta[(2 - 1)]);
        }
      }
      vars__.push_back(mu_a);
      vars__.push_back(sigma_a);
      vars__.push_back(sigma_y);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("a");
    names__.push_back("beta");
    names__.push_back("mu_a");
    names__.push_back("sigma_a");
    names__.push_back("sigma_y");
    names__.push_back("y_hat");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(n_pair);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(2);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    for (size_t sym42__ = 1; sym42__ <= n_pair; ++sym42__) {
      {
        param_names__.push_back(std::string() + "a" + '.' + std::to_string(sym42__));
      }}
    for (size_t sym42__ = 1; sym42__ <= 2; ++sym42__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym42__));
      }}
    param_names__.push_back(std::string() + "mu_a");
    param_names__.push_back(std::string() + "sigma_a");
    param_names__.push_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (size_t sym42__ = 1; sym42__ <= N; ++sym42__) {
        {
          param_names__.push_back(std::string() + "y_hat" + '.' + std::to_string(sym42__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    for (size_t sym42__ = 1; sym42__ <= n_pair; ++sym42__) {
      {
        param_names__.push_back(std::string() + "a" + '.' + std::to_string(sym42__));
      }}
    for (size_t sym42__ = 1; sym42__ <= 2; ++sym42__) {
      {
        param_names__.push_back(std::string() + "beta" + '.' + std::to_string(sym42__));
      }}
    param_names__.push_back(std::string() + "mu_a");
    param_names__.push_back(std::string() + "sigma_a");
    param_names__.push_back(std::string() + "sigma_y");
    if (emit_transformed_parameters__) {
      for (size_t sym42__ = 1; sym42__ <= N; ++sym42__) {
        {
          param_names__.push_back(std::string() + "y_hat" + '.' + std::to_string(sym42__));
        }}
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" << n_pair << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"a\",\"type\":{\"name\":\"vector\",\"length\":" << n_pair << "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"vector\",\"length\":" << 2 << "},\"block\":\"parameters\"},{\"name\":\"mu_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_a\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma_y\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"y_hat\",\"type\":{\"name\":\"vector\",\"length\":" << N << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef partial_eval_model_namespace::partial_eval_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif



  $ ../../../../../install/default/bin/stanc --O 2 --print-cpp stalled1-failure.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace stalled1_failure_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T>& dst, const std::vector<S>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1>& dst, const Eigen::Matrix<T, -1, -1>& src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1>
resize_to_match__(Eigen::Matrix<T, 1, -1>& dst, const Eigen::Matrix<T, 1, -1>& src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1>
resize_to_match__(Eigen::Matrix<T, -1, 1>& dst, const Eigen::Matrix<T, -1, 1>& src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) {
  return x;
}

std::vector<stan::math::var> to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}


using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'stalled1-failure.stan', line 30, column 4 to column 16)",
                                                      " (in 'stalled1-failure.stan', line 31, column 4 to column 16)",
                                                      " (in 'stalled1-failure.stan', line 32, column 4 to column 16)",
                                                      " (in 'stalled1-failure.stan', line 33, column 4 to column 17)",
                                                      " (in 'stalled1-failure.stan', line 34, column 4 to column 22)",
                                                      " (in 'stalled1-failure.stan', line 35, column 4 to column 19)",
                                                      " (in 'stalled1-failure.stan', line 39, column 4 to column 15)",
                                                      " (in 'stalled1-failure.stan', line 44, column 3 to column 31)",
                                                      " (in 'stalled1-failure.stan', line 45, column 3 to column 31)",
                                                      " (in 'stalled1-failure.stan', line 46, column 3 to column 31)",
                                                      " (in 'stalled1-failure.stan', line 47, column 3 to column 32)",
                                                      " (in 'stalled1-failure.stan', line 48, column 3 to column 31)",
                                                      " (in 'stalled1-failure.stan', line 50, column 6 to column 32)",
                                                      " (in 'stalled1-failure.stan', line 51, column 6 to column 103)",
                                                      " (in 'stalled1-failure.stan', line 49, column 18 to line 52, column 4)",
                                                      " (in 'stalled1-failure.stan', line 49, column 3 to line 52, column 4)",
                                                      " (in 'stalled1-failure.stan', line 15, column 4 to column 19)",
                                                      " (in 'stalled1-failure.stan', line 16, column 4 to column 22)",
                                                      " (in 'stalled1-failure.stan', line 17, column 4 to column 22)",
                                                      " (in 'stalled1-failure.stan', line 18, column 4 to column 17)",
                                                      " (in 'stalled1-failure.stan', line 19, column 4 to column 17)",
                                                      " (in 'stalled1-failure.stan', line 23, column 4 to column 10)",
                                                      " (in 'stalled1-failure.stan', line 24, column 4 to column 19)",
                                                      " (in 'stalled1-failure.stan', line 25, column 4 to column 11)",
                                                      " (in 'stalled1-failure.stan', line 26, column 4 to column 21)"};



class stalled1_failure_model : public model_base_crtp<stalled1_failure_model> {

 private:
  double lcm_sym41__;
  double lcm_sym40__;
  double lcm_sym39__;
  double lcm_sym38__;
  int lcm_sym37__;
  int lcm_sym36__;
  int lcm_sym35__;
  int lcm_sym34__;
  double lcm_sym33__;
  int lcm_sym32__;
  int lcm_sym31__;
  Eigen::Matrix<double, -1, 1> lcm_sym30__;
  int pos__;
  int I;
  std::vector<int> n;
  std::vector<int> N;
  Eigen::Matrix<double, -1, 1> x1;
  Eigen::Matrix<double, -1, 1> x2;
  int K;
  Eigen::Matrix<double, -1, 1> x1x2;
 
 public:
  ~stalled1_failure_model() { }
  
  std::string model_name() const { return "stalled1_failure_model"; }
  
  stalled1_failure_model(stan::io::var_context& context__,
                         unsigned int random_seed__ = 0,
                         std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "stalled1_failure_model_namespace::stalled1_failure_model";
    (void) function__;  // suppress unused var warning
    
    try {
      
      
      
      
      
      
      
      
      
      
      
      
      
      pos__ = 1;
      context__.validate_dims("data initialization","I","int",
          context__.to_vec());
      
      current_statement__ = 17;
      I = context__.vals_i("I")[(1 - 1)];
      current_statement__ = 18;
      validate_non_negative_index("n", "I", I);
      context__.validate_dims("data initialization","n","int",
          context__.to_vec(I));
      n = std::vector<int>(I, 0);
      
      current_statement__ = 18;
      assign(n, nil_index_list(), context__.vals_i("n"),
        "assigning variable n");
      current_statement__ = 19;
      validate_non_negative_index("N", "I", I);
      context__.validate_dims("data initialization","N","int",
          context__.to_vec(I));
      N = std::vector<int>(I, 0);
      
      current_statement__ = 19;
      assign(N, nil_index_list(), context__.vals_i("N"),
        "assigning variable N");
      current_statement__ = 20;
      validate_non_negative_index("x1", "I", I);
      context__.validate_dims("data initialization","x1","double",
          context__.to_vec(I));
      x1 = Eigen::Matrix<double, -1, 1>(I);
      
      {
        std::vector<double> x1_flat__;
        current_statement__ = 20;
        assign(x1_flat__, nil_index_list(), context__.vals_r("x1"),
          "assigning variable x1_flat__");
        current_statement__ = 20;
        pos__ = 1;
        lcm_sym31__ = logical_gte(I, 1);
        if (lcm_sym31__) {
          current_statement__ = 20;
          assign(x1, cons_list(index_uni(1), nil_index_list()),
            x1_flat__[(1 - 1)], "assigning variable x1");
          current_statement__ = 20;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
            current_statement__ = 20;
            assign(x1, cons_list(index_uni(sym1__), nil_index_list()),
              x1_flat__[(pos__ - 1)], "assigning variable x1");
            current_statement__ = 20;
            pos__ = (pos__ + 1);}
        } 
      }
      current_statement__ = 21;
      validate_non_negative_index("x2", "I", I);
      context__.validate_dims("data initialization","x2","double",
          context__.to_vec(I));
      x2 = Eigen::Matrix<double, -1, 1>(I);
      
      {
        std::vector<double> x2_flat__;
        current_statement__ = 21;
        assign(x2_flat__, nil_index_list(), context__.vals_r("x2"),
          "assigning variable x2_flat__");
        current_statement__ = 21;
        pos__ = 1;
        current_statement__ = 21;
        if (lcm_sym31__) {
          current_statement__ = 21;
          assign(x2, cons_list(index_uni(1), nil_index_list()),
            x2_flat__[(1 - 1)], "assigning variable x2");
          current_statement__ = 21;
          pos__ = 2;
          for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
            current_statement__ = 21;
            assign(x2, cons_list(index_uni(sym1__), nil_index_list()),
              x2_flat__[(pos__ - 1)], "assigning variable x2");
            current_statement__ = 21;
            pos__ = (pos__ + 1);}
        } 
      }
      
      current_statement__ = 23;
      validate_non_negative_index("x1x2", "I", I);
      x1x2 = Eigen::Matrix<double, -1, 1>(I);
      
      current_statement__ = 23;
      if (lcm_sym31__) {
        lcm_sym33__ = std::numeric_limits<double>::quiet_NaN();
        assign(x1x2, cons_list(index_uni(1), nil_index_list()), lcm_sym33__,
          "assigning variable x1x2");
        for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 23;
          assign(x1x2, cons_list(index_uni(sym1__), nil_index_list()),
            lcm_sym33__, "assigning variable x1x2");}
      } 
      current_statement__ = 24;
      K = 8;
      current_statement__ = 25;
      assign(x1x2, nil_index_list(), elt_multiply(x1, x2),
        "assigning variable x1x2");
      current_statement__ = 17;
      current_statement__ = 17;
      check_greater_or_equal(function__, "I", I, 0);
      current_statement__ = 18;
      if (lcm_sym31__) {
        current_statement__ = 18;
        current_statement__ = 18;
        check_greater_or_equal(function__, "n[sym1__]", n[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 18;
          current_statement__ = 18;
          check_greater_or_equal(function__, "n[sym1__]", n[(sym1__ - 1)], 0);
        }
      } 
      current_statement__ = 19;
      if (lcm_sym31__) {
        current_statement__ = 19;
        current_statement__ = 19;
        check_greater_or_equal(function__, "N[sym1__]", N[(1 - 1)], 0);
        for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 19;
          current_statement__ = 19;
          check_greater_or_equal(function__, "N[sym1__]", N[(sym1__ - 1)], 0);
        }
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      num_params_r__ += 1;
      current_statement__ = 6;
      validate_non_negative_index("b", "I", I);
      current_statement__ = 6;
      validate_non_negative_index("b", "K", K);
      num_params_r__ += I * K;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__>& params_r__, std::vector<int>& params_i__,
               std::ostream* pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "stalled1_failure_model_namespace::log_prob";
(void) function__;  // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    
    try {
      double lcm_sym29__;
      double lcm_sym28__;
      double lcm_sym27__;
      double lcm_sym26__;
      double lcm_sym25__;
      double lcm_sym24__;
      double lcm_sym23__;
      double lcm_sym22__;
      double lcm_sym21__;
      double lcm_sym20__;
      int lcm_sym19__;
      local_scalar_t__ lcm_sym18__;
      local_scalar_t__ alpha0;
      
      current_statement__ = 1;
      alpha0 = in__.scalar();
      local_scalar_t__ alpha1;
      
      current_statement__ = 2;
      alpha1 = in__.scalar();
      local_scalar_t__ alpha2;
      
      current_statement__ = 3;
      alpha2 = in__.scalar();
      local_scalar_t__ alpha12;
      
      current_statement__ = 4;
      alpha12 = in__.scalar();
      local_scalar_t__ tau;
      
      current_statement__ = 5;
      tau = in__.scalar();
      current_statement__ = 5;
      if (jacobian__) {
        current_statement__ = 5;
        tau = stan::math::lb_constrain(tau, 0, lp__);
      } else {
        current_statement__ = 5;
        tau = stan::math::lb_constrain(tau, 0);
      }
      current_statement__ = 6;
      validate_non_negative_index("b", "I", I);
      current_statement__ = 6;
      validate_non_negative_index("b", "K", 8);
      std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> b;
      b = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(I, Eigen::Matrix<local_scalar_t__, -1, 1>(8));
      
      lcm_sym19__ = logical_gte(I, 1);
      if (lcm_sym19__) {
        current_statement__ = 6;
        assign(b, cons_list(index_uni(1), nil_index_list()), in__.vector(8),
          "assigning variable b");
        for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 6;
          assign(b, cons_list(index_uni(sym1__), nil_index_list()),
            in__.vector(8), "assigning variable b");}
      } 
      local_scalar_t__ sigma;
      
      current_statement__ = 7;
      sigma = std::numeric_limits<double>::quiet_NaN();
      lcm_sym18__ = (1 / stan::math::sqrt(tau));
      sigma = lcm_sym18__;
      {
        current_statement__ = 8;
        lp_accum__.add(normal_log<propto__>(alpha0, 0.0, 1.0E3));
        current_statement__ = 9;
        lp_accum__.add(normal_log<propto__>(alpha1, 0.0, 1.0E3));
        current_statement__ = 10;
        lp_accum__.add(normal_log<propto__>(alpha2, 0.0, 1.0E3));
        current_statement__ = 11;
        lp_accum__.add(normal_log<propto__>(alpha12, 0.0, 1.0E3));
        current_statement__ = 12;
        lp_accum__.add(gamma_log<propto__>(tau, 1.0E-3, 1.0E-3));
        current_statement__ = 16;
        if (lcm_sym19__) {
          current_statement__ = 13;
          lp_accum__.add(normal_log<propto__>(b[(1 - 1)], 0.0, lcm_sym18__));
          current_statement__ = 14;
          lp_accum__.add(
            binomial_logit_log<propto__>(n[(1 - 1)], N[(1 - 1)],
              add(
                stan::math::fma(alpha12, elt_multiply(x1, x2)[(1 - 1)],
                  stan::math::fma(alpha2, x2[(1 - 1)],
                    stan::math::fma(alpha1, x1[(1 - 1)], alpha0))),
                b[(1 - 1)])));
          for (size_t i = 2; i <= I; ++i) {
            current_statement__ = 13;
            lp_accum__.add(normal_log<propto__>(b[(i - 1)], 0.0, lcm_sym18__));
            current_statement__ = 14;
            lp_accum__.add(
              binomial_logit_log<propto__>(n[(i - 1)], N[(i - 1)],
                add(
                  stan::math::fma(alpha12, elt_multiply(x1, x2)[(i - 1)],
                    stan::math::fma(alpha2, x2[(i - 1)],
                      stan::math::fma(alpha1, x1[(i - 1)], alpha0))),
                  b[(i - 1)])));}
        } 
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob() 
    
  template <typename RNG>
  void write_array(RNG& base_rng__, std::vector<double>& params_r__,
                   std::vector<int>& params_i__, std::vector<double>& vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream* pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "stalled1_failure_model_namespace::write_array";
(void) function__;  // suppress unused var warning

    (void) function__;  // suppress unused var warning

    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    
    try {
      double lcm_sym17__;
      double lcm_sym16__;
      double lcm_sym15__;
      double lcm_sym14__;
      double lcm_sym13__;
      int lcm_sym12__;
      int lcm_sym11__;
      int lcm_sym10__;
      double lcm_sym9__;
      double alpha0;
      
      current_statement__ = 1;
      alpha0 = in__.scalar();
      double alpha1;
      
      current_statement__ = 2;
      alpha1 = in__.scalar();
      double alpha2;
      
      current_statement__ = 3;
      alpha2 = in__.scalar();
      double alpha12;
      
      current_statement__ = 4;
      alpha12 = in__.scalar();
      double tau;
      
      current_statement__ = 5;
      tau = in__.scalar();
      current_statement__ = 5;
      tau = stan::math::lb_constrain(tau, 0);
      current_statement__ = 6;
      validate_non_negative_index("b", "I", I);
      current_statement__ = 6;
      validate_non_negative_index("b", "K", 8);
      std::vector<Eigen::Matrix<double, -1, 1>> b;
      b = std::vector<Eigen::Matrix<double, -1, 1>>(I, Eigen::Matrix<double, -1, 1>(8));
      
      lcm_sym10__ = logical_gte(I, 1);
      if (lcm_sym10__) {
        current_statement__ = 6;
        assign(b, cons_list(index_uni(1), nil_index_list()), in__.vector(8),
          "assigning variable b");
        for (size_t sym1__ = 2; sym1__ <= I; ++sym1__) {
          current_statement__ = 6;
          assign(b, cons_list(index_uni(sym1__), nil_index_list()),
            in__.vector(8), "assigning variable b");}
      } 
      double sigma;
      
      current_statement__ = 7;
      sigma = std::numeric_limits<double>::quiet_NaN();
      vars__.push_back(alpha0);
      vars__.push_back(alpha1);
      vars__.push_back(alpha2);
      vars__.push_back(alpha12);
      vars__.push_back(tau);
      {
        if (lcm_sym10__) {
          vars__.push_back(b[(1 - 1)][(1 - 1)]);
          for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
            vars__.push_back(b[(sym2__ - 1)][(1 - 1)]);}
        } 
        {
          if (lcm_sym10__) {
            vars__.push_back(b[(1 - 1)][(2 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(2 - 1)]);}
          } 
        }
        {
          if (lcm_sym10__) {
            vars__.push_back(b[(1 - 1)][(3 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(3 - 1)]);}
          } 
        }
        {
          if (lcm_sym10__) {
            vars__.push_back(b[(1 - 1)][(4 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(4 - 1)]);}
          } 
        }
        {
          if (lcm_sym10__) {
            vars__.push_back(b[(1 - 1)][(5 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(5 - 1)]);}
          } 
        }
        {
          if (lcm_sym10__) {
            vars__.push_back(b[(1 - 1)][(6 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(6 - 1)]);}
          } 
        }
        {
          if (lcm_sym10__) {
            vars__.push_back(b[(1 - 1)][(7 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(7 - 1)]);}
          } 
        }
        {
          if (lcm_sym10__) {
            vars__.push_back(b[(1 - 1)][(8 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(8 - 1)]);}
          } 
        }
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      lcm_sym9__ = (1 / stan::math::sqrt(tau));
      sigma = lcm_sym9__;
      vars__.push_back(lcm_sym9__);
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array() 
    
  void transform_inits(const stan::io::var_context& context__,
                       std::vector<int>& params_i__,
                       std::vector<double>& vars__, std::ostream* pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);
    
    try {
      double lcm_sym8__;
      double lcm_sym7__;
      double lcm_sym6__;
      double lcm_sym5__;
      double lcm_sym4__;
      double lcm_sym3__;
      int lcm_sym2__;
      int lcm_sym1__;
      int pos__;
      
      pos__ = 1;
      double alpha0;
      
      current_statement__ = 1;
      alpha0 = context__.vals_r("alpha0")[(1 - 1)];
      double alpha1;
      
      current_statement__ = 2;
      alpha1 = context__.vals_r("alpha1")[(1 - 1)];
      double alpha2;
      
      current_statement__ = 3;
      alpha2 = context__.vals_r("alpha2")[(1 - 1)];
      double alpha12;
      
      current_statement__ = 4;
      alpha12 = context__.vals_r("alpha12")[(1 - 1)];
      double tau;
      
      current_statement__ = 5;
      tau = context__.vals_r("tau")[(1 - 1)];
      current_statement__ = 5;
      tau = stan::math::lb_free(tau, 0);
      current_statement__ = 6;
      validate_non_negative_index("b", "I", I);
      current_statement__ = 6;
      validate_non_negative_index("b", "K", 8);
      std::vector<Eigen::Matrix<double, -1, 1>> b;
      b = std::vector<Eigen::Matrix<double, -1, 1>>(I, Eigen::Matrix<double, -1, 1>(8));
      
      {
        std::vector<double> b_flat__;
        current_statement__ = 6;
        assign(b_flat__, nil_index_list(), context__.vals_r("b"),
          "assigning variable b_flat__");
        current_statement__ = 6;
        pos__ = 1;
        {
          lcm_sym1__ = logical_gte(I, 1);
          if (lcm_sym1__) {
            current_statement__ = 6;
            assign(b,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())),
              b_flat__[(1 - 1)], "assigning variable b");
            current_statement__ = 6;
            pos__ = 2;
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              current_statement__ = 6;
              assign(b,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(1), nil_index_list())),
                b_flat__[(pos__ - 1)], "assigning variable b");
              current_statement__ = 6;
              pos__ = (pos__ + 1);}
          } 
          {
            current_statement__ = 6;
            if (lcm_sym1__) {
              current_statement__ = 6;
              assign(b,
                cons_list(index_uni(1),
                  cons_list(index_uni(2), nil_index_list())),
                b_flat__[(pos__ - 1)], "assigning variable b");
              current_statement__ = 6;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 6;
                assign(b,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(2), nil_index_list())),
                  b_flat__[(pos__ - 1)], "assigning variable b");
                current_statement__ = 6;
                pos__ = (pos__ + 1);}
            } 
          }
          {
            current_statement__ = 6;
            if (lcm_sym1__) {
              current_statement__ = 6;
              assign(b,
                cons_list(index_uni(1),
                  cons_list(index_uni(3), nil_index_list())),
                b_flat__[(pos__ - 1)], "assigning variable b");
              current_statement__ = 6;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 6;
                assign(b,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(3), nil_index_list())),
                  b_flat__[(pos__ - 1)], "assigning variable b");
                current_statement__ = 6;
                pos__ = (pos__ + 1);}
            } 
          }
          {
            current_statement__ = 6;
            if (lcm_sym1__) {
              current_statement__ = 6;
              assign(b,
                cons_list(index_uni(1),
                  cons_list(index_uni(4), nil_index_list())),
                b_flat__[(pos__ - 1)], "assigning variable b");
              current_statement__ = 6;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 6;
                assign(b,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(4), nil_index_list())),
                  b_flat__[(pos__ - 1)], "assigning variable b");
                current_statement__ = 6;
                pos__ = (pos__ + 1);}
            } 
          }
          {
            current_statement__ = 6;
            if (lcm_sym1__) {
              current_statement__ = 6;
              assign(b,
                cons_list(index_uni(1),
                  cons_list(index_uni(5), nil_index_list())),
                b_flat__[(pos__ - 1)], "assigning variable b");
              current_statement__ = 6;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 6;
                assign(b,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(5), nil_index_list())),
                  b_flat__[(pos__ - 1)], "assigning variable b");
                current_statement__ = 6;
                pos__ = (pos__ + 1);}
            } 
          }
          {
            current_statement__ = 6;
            if (lcm_sym1__) {
              current_statement__ = 6;
              assign(b,
                cons_list(index_uni(1),
                  cons_list(index_uni(6), nil_index_list())),
                b_flat__[(pos__ - 1)], "assigning variable b");
              current_statement__ = 6;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 6;
                assign(b,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(6), nil_index_list())),
                  b_flat__[(pos__ - 1)], "assigning variable b");
                current_statement__ = 6;
                pos__ = (pos__ + 1);}
            } 
          }
          {
            current_statement__ = 6;
            if (lcm_sym1__) {
              current_statement__ = 6;
              assign(b,
                cons_list(index_uni(1),
                  cons_list(index_uni(7), nil_index_list())),
                b_flat__[(pos__ - 1)], "assigning variable b");
              current_statement__ = 6;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 6;
                assign(b,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(7), nil_index_list())),
                  b_flat__[(pos__ - 1)], "assigning variable b");
                current_statement__ = 6;
                pos__ = (pos__ + 1);}
            } 
          }
          {
            current_statement__ = 6;
            if (lcm_sym1__) {
              current_statement__ = 6;
              assign(b,
                cons_list(index_uni(1),
                  cons_list(index_uni(8), nil_index_list())),
                b_flat__[(pos__ - 1)], "assigning variable b");
              current_statement__ = 6;
              pos__ = (pos__ + 1);
              for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
                current_statement__ = 6;
                assign(b,
                  cons_list(index_uni(sym2__),
                    cons_list(index_uni(8), nil_index_list())),
                  b_flat__[(pos__ - 1)], "assigning variable b");
                current_statement__ = 6;
                pos__ = (pos__ + 1);}
            } 
          }
        }
      }
      vars__.push_back(alpha0);
      vars__.push_back(alpha1);
      vars__.push_back(alpha2);
      vars__.push_back(alpha12);
      vars__.push_back(tau);
      {
        lcm_sym1__ = logical_gte(I, 1);
        if (lcm_sym1__) {
          vars__.push_back(b[(1 - 1)][(1 - 1)]);
          for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
            vars__.push_back(b[(sym2__ - 1)][(1 - 1)]);}
        } 
        {
          if (lcm_sym1__) {
            vars__.push_back(b[(1 - 1)][(2 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(2 - 1)]);}
          } 
        }
        {
          if (lcm_sym1__) {
            vars__.push_back(b[(1 - 1)][(3 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(3 - 1)]);}
          } 
        }
        {
          if (lcm_sym1__) {
            vars__.push_back(b[(1 - 1)][(4 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(4 - 1)]);}
          } 
        }
        {
          if (lcm_sym1__) {
            vars__.push_back(b[(1 - 1)][(5 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(5 - 1)]);}
          } 
        }
        {
          if (lcm_sym1__) {
            vars__.push_back(b[(1 - 1)][(6 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(6 - 1)]);}
          } 
        }
        {
          if (lcm_sym1__) {
            vars__.push_back(b[(1 - 1)][(7 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(7 - 1)]);}
          } 
        }
        {
          if (lcm_sym1__) {
            vars__.push_back(b[(1 - 1)][(8 - 1)]);
            for (size_t sym2__ = 2; sym2__ <= I; ++sym2__) {
              vars__.push_back(b[(sym2__ - 1)][(8 - 1)]);}
          } 
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits() 
    
  void get_param_names(std::vector<std::string>& names__) const {
    
    names__.resize(0);
    names__.push_back("alpha0");
    names__.push_back("alpha1");
    names__.push_back("alpha2");
    names__.push_back("alpha12");
    names__.push_back("tau");
    names__.push_back("b");
    names__.push_back("sigma");
    } // get_param_names() 
    
  void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(I);
    
    dims__.push_back(K);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dimss__.push_back(dims__);
    dims__.resize(0);
    
    } // get_dims() 
    
  void constrained_param_names(std::vector<std::string>& param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "alpha0");
    param_names__.push_back(std::string() + "alpha1");
    param_names__.push_back(std::string() + "alpha2");
    param_names__.push_back(std::string() + "alpha12");
    param_names__.push_back(std::string() + "tau");
    for (size_t sym42__ = 1; sym42__ <= K; ++sym42__) {
      {
        for (size_t sym43__ = 1; sym43__ <= I; ++sym43__) {
          {
            param_names__.push_back(std::string() + "b" + '.' + std::to_string(sym43__) + '.' + std::to_string(sym42__));
          }}
      }}
    if (emit_transformed_parameters__) {
      param_names__.push_back(std::string() + "sigma");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  void unconstrained_param_names(std::vector<std::string>& param_names__,
                                 bool emit_transformed_parameters__ = true,
                                 bool emit_generated_quantities__ = true) const {
    
    param_names__.push_back(std::string() + "alpha0");
    param_names__.push_back(std::string() + "alpha1");
    param_names__.push_back(std::string() + "alpha2");
    param_names__.push_back(std::string() + "alpha12");
    param_names__.push_back(std::string() + "tau");
    for (size_t sym42__ = 1; sym42__ <= K; ++sym42__) {
      {
        for (size_t sym43__ = 1; sym43__ <= I; ++sym43__) {
          {
            param_names__.push_back(std::string() + "b" + '.' + std::to_string(sym43__) + '.' + std::to_string(sym42__));
          }}
      }}
    if (emit_transformed_parameters__) {
      param_names__.push_back(std::string() + "sigma");
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" << I << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"alpha0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha1\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha2\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha12\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"b\",\"type\":{\"name\":\"array\",\"length\":" << I << ",\"element_type\":{\"name\":\"vector\",\"length\":" << K << "}},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool emit_transformed_parameters__ = true,
                     bool emit_generated_quantities__ = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
          emit_transformed_parameters__, emit_generated_quantities__, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    template <bool propto__, bool jacobian__, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto__,jacobian__,T_>(vec_params_r, vec_params_i, pstream);
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }

};
}
typedef stalled1_failure_model_namespace::stalled1_failure_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif




Warning: deprecated language construct used in 'stalled1-failure.stan', line 1, column 0:
   -------------------------------------------------
     1:  # Using Data Cloning to Calculate MLEs for the Seeds Model in vol1 
         ^
     2:  # http://www.openbugs.net/Examples/DataCloning.html
     3:  
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 2, column 0:
   -------------------------------------------------
     1:  # Using Data Cloning to Calculate MLEs for the Seeds Model in vol1 
     2:  # http://www.openbugs.net/Examples/DataCloning.html
         ^
     3:  
     4:  # The basic idea is that we raise the likelihood in the 
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 4, column 0:
   -------------------------------------------------
     2:  # http://www.openbugs.net/Examples/DataCloning.html
     3:  
     4:  # The basic idea is that we raise the likelihood in the 
         ^
     5:  # posterior to the power of K so that the posterior
     6:  # estimates would concentrate on the MLE estimates. 
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 5, column 0:
   -------------------------------------------------
     3:  
     4:  # The basic idea is that we raise the likelihood in the 
     5:  # posterior to the power of K so that the posterior
         ^
     6:  # estimates would concentrate on the MLE estimates. 
     7:  # Reference: 
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 6, column 0:
   -------------------------------------------------
     4:  # The basic idea is that we raise the likelihood in the 
     5:  # posterior to the power of K so that the posterior
     6:  # estimates would concentrate on the MLE estimates. 
         ^
     7:  # Reference: 
     8:  #   Ecology Letters
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 7, column 0:
   -------------------------------------------------
     5:  # posterior to the power of K so that the posterior
     6:  # estimates would concentrate on the MLE estimates. 
     7:  # Reference: 
         ^
     8:  #   Ecology Letters
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 8, column 0:
   -------------------------------------------------
     6:  # estimates would concentrate on the MLE estimates. 
     7:  # Reference: 
     8:  #   Ecology Letters
         ^
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
    10:  #   DOI: 10.1111/j.1461-0248.2007.01047.x
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 9, column 0:
   -------------------------------------------------
     7:  # Reference: 
     8:  #   Ecology Letters
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
         ^
    10:  #   DOI: 10.1111/j.1461-0248.2007.01047.x
    11:  #   http://onlinelibrary.wiley.com/doi/10.1111/j.1461-0248.2007.01047.x/abstract
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 10, column 0:
   -------------------------------------------------
     8:  #   Ecology Letters
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
    10:  #   DOI: 10.1111/j.1461-0248.2007.01047.x
         ^
    11:  #   http://onlinelibrary.wiley.com/doi/10.1111/j.1461-0248.2007.01047.x/abstract
    12:  
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 11, column 0:
   -------------------------------------------------
     9:  #   Subhash R. Lele Brian Dennis Frithjof Lutscher
    10:  #   DOI: 10.1111/j.1461-0248.2007.01047.x
    11:  #   http://onlinelibrary.wiley.com/doi/10.1111/j.1461-0248.2007.01047.x/abstract
         ^
    12:  
    13:  
   -------------------------------------------------

Comments beginning with # are deprecated. Please use // in place of # for line comments.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 25, column 7:
   -------------------------------------------------
    23:      int K; 
    24:      vector[I] x1x2;
    25:      K <- 8; // {1, 2, 4, 8, 16, 32, 64, 128, 256}
                ^
    26:      x1x2 <- x1 .* x2;
    27:  } 
   -------------------------------------------------

assignment operator <- is deprecated in the Stan language; use = instead.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 26, column 10:
   -------------------------------------------------
    24:      vector[I] x1x2;
    25:      K <- 8; // {1, 2, 4, 8, 16, 32, 64, 128, 256}
    26:      x1x2 <- x1 .* x2;
                   ^
    27:  } 
    28:  
   -------------------------------------------------

assignment operator <- is deprecated in the Stan language; use = instead.


Warning: deprecated language construct used in 'stalled1-failure.stan', line 40, column 11:
   -------------------------------------------------
    38:  transformed parameters {
    39:      real sigma; 
    40:      sigma <- 1 / sqrt(tau); 
                    ^
    41:  } 
    42:  
   -------------------------------------------------

assignment operator <- is deprecated in the Stan language; use = instead.

